<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Printing and Parsing *B*</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../../css/custom.css">
        <link rel="stylesheet" href="../../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Little Languages" href="../../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Little Languages" href="../../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../../">Little Languages</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../../posts/b/text.html">Printing and Parsing *B*</a></h3>
    </div>
    <div class="panel-body">
        <p><a href="testing.html">Previously</a> we wrote some <code>QuickCheck</code> to test the evaluation of <em>B</em>. Now we want to be able to more easily play around with it.</p>
<h1 id="parsing-b">Parsing <em>B</em></h1>
<p>We’ll be using <code>parsers</code> for our parsing needs, which is compatible with <code>parsec</code>, <code>attoparsec</code> and <code>trifecta</code>. If you’re familiar with <code>parsec</code> then you should be fine, although we’ll be driving it via <code>trifecta</code>.</p>
<p>We’ll use this is a little helper to test our parsers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.Trifecta.Parser</span>
<span class="kw">import </span><span class="dt">Text.Trifecta.Result</span>
<span class="kw">import </span><span class="dt">Text.Trifecta.Delta</span>
<span class="kw">import </span><span class="dt">Text.PrettyPrint.ANSI.Leijen</span>

<span class="ot">parse ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> a
parse p s <span class="fu">=</span> <span class="kw">case</span> parseString p (<span class="dt">Lines</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>) s <span class="kw">of</span>
  <span class="dt">Failure</span> d <span class="ot">-&gt;</span> <span class="dt">Failure</span> (plain d)
  <span class="dt">Success</span> s <span class="ot">-&gt;</span> <span class="dt">Success</span> s</code></pre></div>
<p>I’m going to amend the <code>Term</code> type for this section, so that I can better demonstrate a few things about <code>parsers</code>. The change is to add variables into the mix:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> <span class="fu">=</span>
    <span class="dt">TmVar</span> <span class="dt">String</span>
  <span class="fu">|</span> <span class="dt">TmFalse</span>
  <span class="fu">|</span> <span class="dt">TmTrue</span>
  <span class="fu">|</span> <span class="dt">TmIf</span> <span class="dt">Term</span> <span class="dt">Term</span> <span class="dt">Term</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<h2 id="charparsing">CharParsing</h2>
<p>We’ll start off using the <code>CharParsing</code> class, which is used for parsing character streams.</p>
<p>Variables will start with a lowercase letter, followed by some number (possibly 0) of alpha-numeric characters or underscores.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmVar ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
           <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmVar <span class="fu">=</span>
  (\x y <span class="ot">-&gt;</span> <span class="dt">TmVar</span> (x <span class="fu">:</span> y)) <span class="fu">&lt;$&gt;</span> 
    lower <span class="fu">&lt;*&gt;</span> 
    many (alphaNum <span class="fu">&lt;|&gt;</span> char <span class="ch">'_'</span>)</code></pre></div>
<p>We’ll use capital letters for our Boolean constructors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmTrue ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
            <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmTrue <span class="fu">=</span>
  <span class="dt">TmTrue</span> <span class="fu">&lt;$</span> 
    string <span class="st">&quot;True&quot;</span>

<span class="ot">parseTmFalse ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
             <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmFalse <span class="fu">=</span>
  <span class="dt">TmFalse</span> <span class="fu">&lt;$</span> 
    string <span class="st">&quot;False&quot;</span></code></pre></div>
<p>and we’ll follow convention for the if-expression:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmIf ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
          <span class="ot">=&gt;</span> m <span class="dt">Term</span> 
          <span class="ot">-&gt;</span> m <span class="dt">Term</span>
parseTmIf parse <span class="fu">=</span>
  <span class="dt">TmIf</span> <span class="fu">&lt;$</span>
    string <span class="st">&quot;if&quot;</span>   <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*&gt;</span> parse <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*</span>
    string <span class="st">&quot;then&quot;</span> <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*&gt;</span> parse <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*</span>
    string <span class="st">&quot;else&quot;</span> <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*&gt;</span> parse</code></pre></div>
<p>where we pass in the combined parsing function as an argument.</p>
<p><code>CharParsing</code> has <code>Alternative</code> as an indirect superclass, so we can combine these rules directly with <code>asum</code>. While we’re here, we’ll also add support for parsing terms that are in parentheses:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTermRules ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
               <span class="ot">=&gt;</span> [m <span class="dt">Term</span>]
parseTermRules <span class="fu">=</span>
  [ parseTmVar
  , parseTmTrue
  , parseTmFalse
  , parseTmIf parseTerm
  ]
  
<span class="ot">parens ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
       <span class="ot">=&gt;</span> m a 
       <span class="ot">-&gt;</span> m a
parens <span class="fu">=</span>
  between (char <span class="ch">'('</span> <span class="fu">&lt;*</span> spaces) (spaces <span class="fu">&lt;*</span> char <span class="ch">')'</span>)
  
<span class="ot">parseTerm ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
          <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTerm <span class="fu">=</span> 
  asum parseTermRules <span class="fu">&lt;|&gt;</span> 
  parens parseTerm</code></pre></div>
<p>Now we’ll try it on a few things.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;False&quot;</span>
<span class="dt">Success</span> <span class="dt">TmFalse</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;potato&quot;</span>
<span class="dt">Success</span> (<span class="dt">TmVar</span> <span class="st">&quot;potato&quot;</span>)</code></pre></div>
<p>Looking good so far.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;if False then False else True&quot;</span>
<span class="dt">Success</span> (<span class="dt">TmVar</span> <span class="st">&quot;if&quot;</span>)</code></pre></div>
<p>Ouch. It turns out that order that we specify our rules matters here.</p>
<p>Let’s fix that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTermRules ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
               <span class="ot">=&gt;</span> [m <span class="dt">Term</span>]
parseTermRules <span class="fu">=</span>
  [ parseTmTrue
  , parseTmFalse
  , parseTmIf parseTerm
  , parseTmVar
  ]</code></pre></div>
<p>Now we should be able to parse if-expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;if False then False else True&quot;</span>
<span class="dt">Success</span> (<span class="dt">TmIf</span> <span class="dt">TmFalse</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>)</code></pre></div>
<p>and no potatoes were harmed during the fix:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;potato&quot;</span>
<span class="dt">Success</span> (<span class="dt">TmVar</span> <span class="st">&quot;potato&quot;</span>)</code></pre></div>
<p>However, there is room for improvement:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;Potato&quot;</span>
<span class="dt">Failure</span> (interactive)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> expected<span class="fu">:</span> <span class="st">&quot;(&quot;</span>,
    <span class="st">&quot;False&quot;</span>, <span class="st">&quot;True&quot;</span>, <span class="st">&quot;if&quot;</span>,
    lowercase letter
<span class="dt">Potato</span><span class="fu">&lt;</span><span class="dt">EOF</span><span class="fu">&gt;</span>
<span class="fu">^</span></code></pre></div>
<p>That’s a bit ugly, and the ugliness can be addressed by giving names to each of our parsers.</p>
<p>We do this with the <code>&lt;?&gt;</code> operator, which has an operator precedence of 0:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmVar ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
           <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmVar <span class="fu">=</span>
  (\x y <span class="ot">-&gt;</span> <span class="dt">TmVar</span> (x <span class="fu">:</span> y)) <span class="fu">&lt;$&gt;</span> 
    lower <span class="fu">&lt;*&gt;</span> 
    many (alphaNum <span class="fu">&lt;|&gt;</span> char <span class="ch">'_'</span>)
  <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Var&quot;</span>

<span class="ot">parseTmTrue ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
            <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmTrue <span class="fu">=</span>
  <span class="dt">TmTrue</span> <span class="fu">&lt;$</span> 
    string <span class="st">&quot;True&quot;</span>
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;True&quot;</span>

<span class="ot">parseTmFalse ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
             <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmFalse <span class="fu">=</span>
  <span class="dt">TmFalse</span> <span class="fu">&lt;$</span> 
    string <span class="st">&quot;False&quot;</span>
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;False&quot;</span>

<span class="ot">parseTmIf ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
          <span class="ot">=&gt;</span> m <span class="dt">Term</span> 
          <span class="ot">-&gt;</span> m <span class="dt">Term</span>
parseTmIf parse <span class="fu">=</span>
  <span class="dt">TmIf</span> <span class="fu">&lt;$</span>
    string <span class="st">&quot;if&quot;</span>   <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*&gt;</span> parse <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*</span>
    string <span class="st">&quot;then&quot;</span> <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*&gt;</span> parse <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*</span>
    string <span class="st">&quot;else&quot;</span> <span class="fu">&lt;*</span> spaces <span class="fu">&lt;*&gt;</span> parse
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;if-then-else&quot;</span>
  
<span class="ot">parseTerm ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
          <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTerm <span class="fu">=</span> 
  asum parseTermRules <span class="fu">&lt;|&gt;</span> 
  parens parseTerm
  <span class="fu">&lt;?&gt;</span> <span class="st">&quot;term&quot;</span></code></pre></div>
<p>Now our error message makes more sense:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;Potato&quot;</span>
<span class="dt">Failure</span> (interactive)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> expected<span class="fu">:</span> term
<span class="dt">Potato</span><span class="fu">&lt;</span><span class="dt">EOF</span><span class="fu">&gt;</span>
<span class="fu">^</span></code></pre></div>
<p>aside from the recurring presence of potatoes in our examples.</p>
<p>Alas, our work is not done, since we’d like this to be an error:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;if potato thenFalseelseTrue&quot;</span>
<span class="dt">Success</span> (<span class="dt">TmIf</span> (<span class="dt">TmVar</span> <span class="st">&quot;potato&quot;</span>) <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>)</code></pre></div>
<p>We could go and fiddle with our parsers, but there’s a quicker way.</p>
<h2 id="tokenparsing">TokenParsing</h2>
<p>We’ll step things up a little by using the <code>TokenParsing</code> class, which is used for parsing token streams. This provides a few benefits - the first of which being that we don’t have to worry about whitespace as much.</p>
<p>For our identifiers, we just wrap our character-based parser up with <code>token</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmVar ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
           <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmVar <span class="fu">=</span>
  (token (\x y <span class="ot">-&gt;</span> <span class="dt">TmVar</span> (x <span class="fu">:</span> y)) <span class="fu">&lt;$&gt;</span> 
    lower <span class="fu">&lt;*&gt;</span> 
    many (alphaNum <span class="fu">&lt;|&gt;</span> char <span class="ch">'_'</span>))
  <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Var&quot;</span></code></pre></div>
<p>For the other constructors we can just use <code>symbol</code> to parse a literal string with whitespace around it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmTrue ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
            <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmTrue <span class="fu">=</span>
  <span class="dt">TmTrue</span> <span class="fu">&lt;$</span> 
    symbol <span class="st">&quot;True&quot;</span>
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;True&quot;</span>

<span class="ot">parseTmFalse ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
             <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmFalse <span class="fu">=</span>
  <span class="dt">TmFalse</span> <span class="fu">&lt;$</span> 
    symbol <span class="st">&quot;False&quot;</span>
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;False&quot;</span>

<span class="ot">parseTmIf ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
          <span class="ot">=&gt;</span> m <span class="dt">Term</span> 
          <span class="ot">-&gt;</span> m <span class="dt">Term</span>
parseTmIf parse <span class="fu">=</span>
  <span class="dt">TmIf</span> <span class="fu">&lt;$</span>
    symbol <span class="st">&quot;if&quot;</span>   <span class="fu">&lt;*</span> parse <span class="fu">&lt;*</span>
    symbol <span class="st">&quot;then&quot;</span> <span class="fu">&lt;*</span> parse <span class="fu">&lt;*</span>
    symbol <span class="st">&quot;else&quot;</span> <span class="fu">&lt;*</span> parse
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;if-then-else&quot;</span></code></pre></div>
<p>We still have our list of rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTermRules ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
               <span class="ot">=&gt;</span> [m <span class="dt">Term</span>]
parseTermRules <span class="fu">=</span>
  [ parseTmVar
  , parseTmTrue
  , parseTmFalse
  , parseTmIf parseTerm
  ]</code></pre></div>
<p>But now we can use the whitespace-aware <code>parens</code> from <code>Text.Parser.Token</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTerm ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
          <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTerm <span class="fu">=</span> 
  asum parseTermRules <span class="fu">&lt;|&gt;</span> 
  parens parseTerm
  <span class="fu">&lt;?&gt;</span> <span class="st">&quot;term&quot;</span></code></pre></div>
<p>This fixes our whitespace problems:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> parse parseTerm <span class="st">&quot;if potato then FalseelseTrue&quot;</span><span class="ch">'</span>
<span class="dt">Failure</span> (interactive)<span class="fu">:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">16</span><span class="fu">:</span> error<span class="fu">:</span> expected<span class="fu">:</span> term
    <span class="kw">if</span> potato <span class="kw">then</span> <span class="dt">FalseelseTrue</span><span class="fu">&lt;</span><span class="dt">EOF</span><span class="fu">&gt;</span>
                   <span class="fu">^</span></code></pre></div>
<p>but we still need to be careful with the order of our rules.</p>
<h2 id="token-parsing-with-style">Token parsing with style</h2>
<p>The <code>TokenParsing</code> class has support for something like lexing, by way of various <code>IdentifierStyle</code>s.</p>
<p>The style has - a name - a parser for the first character - a parser for characters - a set of reserved words - highlighting hints for regular words and reserved words</p>
<p>From this we can extract a parser for reserved words, and a parser for regular words that won’t accept the reserved words. The highlighting comes into play later on, when we mine <code>trifecta</code> for all the prettiness we can get.</p>
<p>We gleefully exploit this by setting up styles for our the two semantic classes that we have - identifiers and constructors - and reserving our keywords in whichever styles are able to conflict with them.</p>
<p>For example, since “if”, “then” and “else” could conflict with our variables, we reserve them in the indentifier style:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">HashSet</span> <span class="kw">as</span> <span class="dt">HS</span>

<span class="ot">identifierStyle ::</span> <span class="dt">TokenParsing</span> m
                <span class="ot">=&gt;</span> <span class="dt">IdentifierStyle</span> m
identifierStyle <span class="fu">=</span>
    <span class="dt">IdentifierStyle</span> {
      _styleName              <span class="fu">=</span> <span class="st">&quot;identifier&quot;</span>
    , _styleStart             <span class="fu">=</span> lower <span class="fu">&lt;|&gt;</span> char <span class="ch">'_'</span>
    , _styleLetter            <span class="fu">=</span> alphaNum <span class="fu">&lt;|&gt;</span> char <span class="ch">'_'</span>
    , _styleReserved          <span class="fu">=</span> HS.fromList reservedIdentifiers
    , _styleHighlight         <span class="fu">=</span> <span class="dt">Identifier</span>
    , _styleReservedHighlight <span class="fu">=</span> <span class="dt">ReservedIdentifier</span>
  }
  <span class="kw">where</span>
    reservedIdentifiers <span class="fu">=</span>
      [ <span class="st">&quot;if&quot;</span>
      , <span class="st">&quot;then&quot;</span>
      , <span class="st">&quot;else&quot;</span>
      ]</code></pre></div>
<p>We make use of the style via <code>reserve</code> and <code>ident</code>, to create a pair of helpers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reservedIdentifier ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
                   <span class="ot">=&gt;</span> <span class="dt">String</span>
                   <span class="ot">-&gt;</span> m ()
reservedIdentifier <span class="fu">=</span>
  reserve identifierStyle

<span class="ot">identifier ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m <span class="dt">String</span>
identifier <span class="fu">=</span>
  ident identifierStyle</code></pre></div>
<p>We do something similar for constructors. In this case it feels less exploitative, since ‘True’ and ‘False’ are genuinely constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">constructorStyle ::</span> <span class="dt">TokenParsing</span> m
                 <span class="ot">=&gt;</span> <span class="dt">IdentifierStyle</span> m
constructorStyle <span class="fu">=</span>
    <span class="dt">IdentifierStyle</span> {
      _styleName              <span class="fu">=</span> <span class="st">&quot;constructor&quot;</span>
    , _styleStart             <span class="fu">=</span> upper
    , _styleLetter            <span class="fu">=</span> alphaNum <span class="fu">&lt;|&gt;</span> char <span class="ch">'_'</span>
    , _styleReserved          <span class="fu">=</span> HS.fromList reservedConstructors
    , _styleHighlight         <span class="fu">=</span> <span class="dt">Constructor</span>
    , _styleReservedHighlight <span class="fu">=</span> <span class="dt">ReservedConstructor</span>
    }
  <span class="kw">where</span>
    reservedConstructors <span class="fu">=</span>
      [ <span class="st">&quot;False&quot;</span>
      , <span class="st">&quot;True&quot;</span>
      ]</code></pre></div>
<p>with the corresponding helpers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reservedConstructor ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
                    <span class="ot">=&gt;</span> <span class="dt">String</span>
                    <span class="ot">-&gt;</span> m ()
reservedConstructor <span class="fu">=</span>
  reserve constructorStyle

<span class="ot">constructor ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
            <span class="ot">=&gt;</span> m <span class="dt">String</span>
constructor <span class="fu">=</span>
  ident constructorStyle</code></pre></div>
<p>Now that we have that out of the way, we can use those styles with the parsers for <code>Term</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmVar ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
           <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmVar <span class="fu">=</span>
  <span class="dt">TmVar</span> <span class="fu">&lt;$&gt;</span> identifier <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Var&quot;</span>

<span class="ot">parseTmTrue ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
            <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmTrue <span class="fu">=</span>
  <span class="dt">TmTrue</span> <span class="fu">&lt;$</span> 
    reservedConstructor <span class="st">&quot;True&quot;</span>
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;True&quot;</span>

<span class="ot">parseTmFalse ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) 
             <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmFalse <span class="fu">=</span>
  <span class="dt">TmFalse</span> <span class="fu">&lt;$</span> 
    reservedConstructor <span class="st">&quot;False&quot;</span>
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;False&quot;</span>

<span class="ot">parseTmIf ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
          <span class="ot">=&gt;</span> m <span class="dt">Term</span> 
          <span class="ot">-&gt;</span> m <span class="dt">Term</span>
parseTmIf parse <span class="fu">=</span>
  <span class="dt">TmIf</span> <span class="fu">&lt;$</span>
    reservedIdentifier <span class="st">&quot;if&quot;</span>   <span class="fu">&lt;*</span> parse <span class="fu">&lt;*</span>
    reservedIdentifier <span class="st">&quot;then&quot;</span> <span class="fu">&lt;*</span> parse <span class="fu">&lt;*</span>
    reservedIdentifier <span class="st">&quot;else&quot;</span> <span class="fu">&lt;*</span> parse
    <span class="fu">&lt;?&gt;</span> <span class="st">&quot;if-then-else&quot;</span></code></pre></div>
<p>and now we don’t have to be wary of the order in which we combine the parsing rules.</p>
<h1 id="pretty-printing-b">Pretty Printing <em>B</em></h1>
<p>We’ll use <code>ansi-wl-pprint</code> for our pretty printing needs.</p>
<p>Pretty printing libraries give us the ability to turn our structured data into text, with abstractions for controlling the layout of the text and nice compositional properties.</p>
<p>Pretty printing libraries have some similarity to combinator based parsing libraries - they’re both easy once they click, but there can be some stumbling blocks when you’re new to them. It’s worth spending some time to get used to a pretty printing library, so that you can use it at a moments notice without having to stumble.</p>
<p>There are many pretty printing libraries out there, but I’ve reached for <code>ansi-wl-pprint</code>. It uses a fairly common set of abstractions for pretty printing, and it has support for coloured output. It’s also used by <code>trifecta</code>, which we abuse shortly.</p>
<p>The main data type in this library is the abstract document, <code>Doc</code>.</p>
<p>There is a <code>Show</code> instance for <code>Doc</code>, or we can use <code>putDoc</code> to pretty print the <code>Doc</code> with colourisation.</p>
<p>We can convert <code>String</code>s to <code>Doc</code>s:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> text <span class="st">&quot;potato&quot;</span>
potato</code></pre></div>
<p>And, although the syntax highlighting of my blog isn’t going to play along, we can alter that in various ways</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> green <span class="fu">.</span> text <span class="fu">$</span> <span class="st">&quot;potato&quot;</span>
potato
<span class="fu">&gt;</span> bold <span class="fu">.</span> green <span class="fu">.</span> text <span class="fu">$</span> <span class="st">&quot;potato&quot;</span>
potato
<span class="fu">&gt;</span> underline <span class="fu">.</span> bold <span class="fu">.</span> green <span class="fu">.</span> text <span class="fu">$</span> <span class="st">&quot;potato&quot;</span>
potato</code></pre></div>
<p>We can also set the number of columns in the display and the ribbon width, which is the number of non-indentation characters per line.</p>
<p>It can be useful to play around with this to get a feel for it. I’ll be using this little function for my experiments, which allows me to set the number of columns and ribbon width:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">render ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Doc</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
render r w f d <span class="fu">=</span> putStr <span class="fu">$</span> displayS (renderPretty r w (plain (f d))) <span class="st">&quot;&quot;</span></code></pre></div>
<p>In this function, <code>w</code> is the number of columns to use, and <code>r</code> * <code>w</code> is the ribbon width. We also uses <code>plain</code> to strip the various escape codes for colourisation, which I do so I can use it for doctests.</p>
<p>We’re going to proceed with rule-based pretty printers for each of our terms, and lean on the <code>Alternative</code> instance of <code>Maybe</code> to stitch them all together.</p>
<p>The cases for <code>TmTrue</code> and <code>TmFalse</code> are straightforward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTmTrue ::</span> <span class="dt">Term</span>
             <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmTrue <span class="dt">TmTrue</span> <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> text <span class="st">&quot;True&quot;</span>
prettyTmTrue _ <span class="fu">=</span>
  <span class="dt">Nothing</span>

<span class="ot">prettyTmFalse ::</span> <span class="dt">Term</span>
              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmFalse <span class="dt">TmFalse</span> <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> text <span class="st">&quot;False&quot;</span>
prettyTmFalse _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>For the <code>TmIf</code> case we use a few more combinators. We use <code>&lt;+&gt;</code> for horizontal concatenation with a space. We use <code>&lt;/&gt;</code> for soft line breaks, which will become a space if the combined arguments fit the page with, and a new line if they don’t.</p>
<p>We pass in the combined pretty printer for terms in order to pretty print the sub-terms:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTmIf ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>)
           <span class="ot">-&gt;</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmIf prettyTerm (<span class="dt">TmIf</span> tm1 tm2 tm3) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span>
    text <span class="st">&quot;if&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm1 <span class="fu">&lt;/&gt;</span>
    text <span class="st">&quot;then&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm2 <span class="fu">&lt;/&gt;</span>
    text <span class="st">&quot;else&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm3
prettyTmIf _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>After that we gather up the rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTermRules ::</span> [<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>]
prettyTermRules <span class="fu">=</span>
  [ prettyTmFalse
  , prettyTmTrue
  , prettyTmIf prettyTerm
  ]</code></pre></div>
<p>and combine them all:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTerm ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyTerm tm <span class="fu">=</span>
  fromMaybe (text <span class="st">&quot;???&quot;</span>) <span class="fu">.</span>
  asum <span class="fu">.</span>
  fmap (<span class="fu">$</span> tm) <span class="fu">$</span>
  prettyTermRules</code></pre></div>
<p>and we have our pretty printer.</p>
<p>(If we every see a “???”, then things have gone pretty badly.)</p>
<p>We can play around with this to see how it looks.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> render <span class="fl">0.5</span> <span class="dv">40</span> prettyTerm <span class="fu">$</span> <span class="dt">TmTrue</span>
<span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.5</span> <span class="dv">40</span> prettyTerm <span class="fu">$</span> <span class="dt">TmFalse</span>
<span class="dt">False</span></code></pre></div>
<p>Looking good so far.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">let</span> ifTerm <span class="fu">=</span> <span class="dt">TmIf</span> <span class="dt">TmFalse</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>

<span class="fu">&gt;</span> render <span class="fl">0.25</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.50</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span> <span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.75</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span></code></pre></div>
<p>Hmm. I’m not 100% sold on the middle one of those.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">let</span> nestedIfTerm <span class="fu">=</span> <span class="dt">TmIf</span> ifTerm ifTerm ifTerm

<span class="fu">&gt;</span> render <span class="fl">0.25</span> <span class="dv">40</span> prettyTerm nestedIfTerm 
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.50</span> <span class="dv">40</span> prettyTerm nestedIfTerm 
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.75</span> <span class="dv">40</span> prettyTerm nestedIfTerm 
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span> <span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span> <span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span> <span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span></code></pre></div>
<p>Aargh! My eyes! I thought this was meant to be <em>pretty</em>!</p>
<h2 id="improving-the-layout">Improving the layout</h2>
<p>For the first of those examples, we can improve things by changing from soft line breaks to hard line breaks.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.PrettyPrint.ANSI.Leijen</span> <span class="kw">as</span> <span class="dt">PP</span> ((&lt;$&gt;))

<span class="ot">prettyTmIf ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>)
           <span class="ot">-&gt;</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmIf prettyTerm (<span class="dt">TmIf</span> tm1 tm2 tm3) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span>
    text <span class="st">&quot;if&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm1 <span class="fu">PP.&lt;$&gt;</span>
    text <span class="st">&quot;then&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm2 <span class="fu">PP.&lt;$&gt;</span>
    text <span class="st">&quot;else&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm3
prettyTmIf _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>Note that several pretty printing libraries use <code>&lt;$&gt;</code> for vertical composition, so there’s usually some importing hoops to jump through so that you’d don’t clash with the operator form of <code>fmap</code>.</p>
<p>Now we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">let</span> ifTerm <span class="fu">=</span> <span class="dt">TmIf</span> <span class="dt">TmFalse</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>

<span class="fu">&gt;</span> render <span class="fl">0.25</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.50</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span> 
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.75</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span> 
<span class="kw">then</span> <span class="dt">False</span> 
<span class="kw">else</span> <span class="dt">True</span></code></pre></div>
<p>which looks a bit neater, but it’s using a lot of vertical space that it doesn’t need to.</p>
<p>On top of that, this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> render <span class="fl">0.25</span> <span class="dv">40</span> prettyTerm nestedIfTerm 
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.50</span> <span class="dv">40</span> prettyTerm nestedIfTerm 
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;</span> render <span class="fl">0.75</span> <span class="dv">40</span> prettyTerm nestedIfTerm 
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span></code></pre></div>
<p>is still an abomination.</p>
<p>We can improve things for the nested if-expression using <code>align</code>. When <code>align d</code> is used, all new lines in <code>d</code> start on the same column as the first column of <code>align d</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTmIf ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>)
           <span class="ot">-&gt;</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmIf prettyTerm (<span class="dt">TmIf</span> tm1 tm2 tm3) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">.</span> align <span class="fu">$</span>
    text <span class="st">&quot;if&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm1 <span class="fu">PP.&lt;$&gt;</span>
    text <span class="st">&quot;then&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm2 <span class="fu">PP.&lt;$&gt;</span>
    text <span class="st">&quot;else&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm3
prettyTmIf _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>This neatens things up somewhat:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> render <span class="fl">0.25</span> <span class="dv">40</span> prettyTerm nestedIfTerm
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span>
   <span class="kw">then</span> <span class="dt">False</span>
   <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
     <span class="kw">then</span> <span class="dt">False</span>
     <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span>
     <span class="kw">then</span> <span class="dt">False</span>
     <span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;&gt;&gt;</span> render <span class="fl">0.50</span> <span class="dv">40</span> prettyTerm nestedIfTerm
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span>
   <span class="kw">then</span> <span class="dt">False</span>
   <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
     <span class="kw">then</span> <span class="dt">False</span>
     <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span>
     <span class="kw">then</span> <span class="dt">False</span>
     <span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;&gt;&gt;</span> render <span class="fl">0.75</span> <span class="dv">40</span> prettyTerm nestedIfTerm
<span class="kw">if</span> <span class="kw">if</span> <span class="dt">False</span>
   <span class="kw">then</span> <span class="dt">False</span>
   <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">then</span> <span class="kw">if</span> <span class="dt">False</span>
     <span class="kw">then</span> <span class="dt">False</span>
     <span class="kw">else</span> <span class="dt">True</span>
<span class="kw">else</span> <span class="kw">if</span> <span class="dt">True</span>
     <span class="kw">then</span> <span class="dt">False</span>
     <span class="kw">else</span> <span class="dt">True</span></code></pre></div>
<p>Finally, we can improve the use of vertical space with <code>group</code>. When <code>group d</code> is used, it attempts removes all of the linebreaks in <code>d</code>. If that fits on the current line it is used, otherwise it falls back to <code>d</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTmIf ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>)
           <span class="ot">-&gt;</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmIf prettyTerm (<span class="dt">TmIf</span> tm1 tm2 tm3) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">.</span> group <span class="fu">.</span> align <span class="fu">$</span>
    text <span class="st">&quot;if&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm1 <span class="fu">PP.&lt;$&gt;</span>
    text <span class="st">&quot;then&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm2 <span class="fu">PP.&lt;$&gt;</span>
    text <span class="st">&quot;else&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm3
prettyTmIf _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>We can see the effect on the simple if-expression here:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> render <span class="fl">0.25</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;&gt;&gt;</span> render <span class="fl">0.50</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span>
<span class="kw">then</span> <span class="dt">False</span>
<span class="kw">else</span> <span class="dt">True</span>

<span class="fu">&gt;&gt;&gt;</span> render <span class="fl">0.75</span> <span class="dv">40</span> prettyTerm ifTerm
<span class="kw">if</span> <span class="dt">False</span> <span class="kw">then</span> <span class="dt">False</span> <span class="kw">else</span> <span class="dt">True</span></code></pre></div>
<p>The selection of combinators in <code>ansi-wl-pprint</code> is pretty versatile, so we could keep fiddling with this for ages.</p>
<p>I’m going to stop here, but it’s worth spending some time having a look at what it offers and having a play around with it.</p>
<h2 id="token-printing">Token printing</h2>
<p>Token printing isn’t really a thing, but it’s handy to be able to think of your parsing and printing as being closely related.</p>
<p>For now, we’re just going to steal the highlighting from <code>trifecta</code> so that the parser and printer agree, and we’ll use the same names for our helper functions for different semantic groups of things in both the parser and the printer.</p>
<p>As well as helping make things consistently pretty, this helps set the stage for bidirectional parsing and printing later on.</p>
<p>We import a few things to effect our heist:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Text.Parser.Token.Highlight</span>  (<span class="dt">Highlight</span> (..))
<span class="kw">import           </span><span class="dt">Text.PrettyPrint.ANSI.Leijen</span> (<span class="dt">Doc</span>, text)
<span class="kw">import           </span><span class="dt">Text.Trifecta.Highlight</span>      (withHighlight)

<span class="ot">reservedIdentifier ::</span> <span class="dt">String</span>
                   <span class="ot">-&gt;</span> <span class="dt">Doc</span>
reservedIdentifier <span class="fu">=</span>
  withHighlight <span class="dt">ReservedIdentifier</span> <span class="fu">.</span>
  text

<span class="ot">identifier ::</span> <span class="dt">String</span>
           <span class="ot">-&gt;</span> <span class="dt">Doc</span>
identifier <span class="fu">=</span>
  withHighlight <span class="dt">Identifier</span> <span class="fu">.</span>
  text

<span class="ot">reservedConstructor ::</span> <span class="dt">String</span>
                    <span class="ot">-&gt;</span> <span class="dt">Doc</span>
reservedConstructor <span class="fu">=</span>
  withHighlight <span class="dt">ReservedConstructor</span> <span class="fu">.</span>
  text

<span class="ot">constructor ::</span> <span class="dt">String</span>
            <span class="ot">-&gt;</span> <span class="dt">Doc</span>
constructor <span class="fu">=</span>
  withHighlight <span class="dt">Constructor</span> <span class="fu">.</span>
  text</code></pre></div>
<p>and then we spend our loot to update our pretty printers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTmFalse ::</span> <span class="dt">Term</span>
              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmFalse <span class="dt">TmFalse</span> <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> reservedConstructor <span class="st">&quot;False&quot;</span>
prettyTmFalse _ <span class="fu">=</span>
  <span class="dt">Nothing</span>

<span class="ot">prettyTmTrue ::</span> <span class="dt">Term</span>
             <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmTrue <span class="dt">TmTrue</span> <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> reservedConstructor <span class="st">&quot;True&quot;</span>
prettyTmTrue _ <span class="fu">=</span>
  <span class="dt">Nothing</span>

<span class="ot">prettyTmIf ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>)
           <span class="ot">-&gt;</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmIf prettyTerm (<span class="dt">TmIf</span> tm1 tm2 tm3) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">.</span> group <span class="fu">.</span> align <span class="fu">$</span>
    reservedIdentifier <span class="st">&quot;if&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm1 <span class="fu">PP.&lt;$&gt;</span>
    reservedIdentifier <span class="st">&quot;then&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm2 <span class="fu">PP.&lt;$&gt;</span>
    reservedIdentifier <span class="st">&quot;else&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm tm3
prettyTmIf _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<h1 id="testing-the-parser-and-the-printer">Testing the parser and the printer</h1>
<p>We can use a few little helper functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyToString ::</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
prettyToString d <span class="fu">=</span>
  displayS (renderPretty <span class="fl">0.75</span> <span class="dv">80</span> (plain d)) <span class="st">&quot;&quot;</span>

<span class="ot">parseFromString ::</span> <span class="dt">Parser</span> a
                <span class="ot">-&gt;</span> <span class="dt">String</span>
                <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Doc</span> a
parseFromString p s <span class="fu">=</span>
  <span class="kw">case</span> parseString p (<span class="dt">Lines</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span>) s <span class="kw">of</span>
    <span class="dt">Success</span> r <span class="ot">-&gt;</span> <span class="dt">Right</span> r
    <span class="dt">Failure</span> d <span class="ot">-&gt;</span> <span class="dt">Left</span> d</code></pre></div>
<p>to check that pretty printing a term and parsing the resulting the string always gives us back the original term:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propPrettyParse ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
propPrettyParse (<span class="dt">AnyTerm</span> tm) <span class="fu">=</span>
  <span class="kw">let</span>
    roundTrip <span class="fu">=</span>
      parseFromString parseTerm <span class="fu">.</span>
      prettyToString <span class="fu">.</span>
      prettyTerm
  <span class="kw">in</span>
    <span class="kw">case</span> roundTrip tm <span class="kw">of</span>
      <span class="dt">Left</span> _ <span class="ot">-&gt;</span> property <span class="dt">False</span>
      <span class="dt">Right</span> tm' <span class="ot">-&gt;</span> tm <span class="fu">===</span> tm'</code></pre></div>
<p>Tests like this can give us quite a bit of confidence in the correct paths, but it doesn’t tell us much about our parsing errors.</p>
<h2 id="doctests-are-your-friend">Doctests are your friend</h2>
<p>This is one of the places where I like to use doctests.</p>
<p>They’re great as unit tests, they’re great as examples in documentation, and if you make them part of your build step there’s minimal hassle involved in keeping them up to date.</p>
<p>Here’s the haddock for <code>parseTmIf</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A parser for 'TmIf'.</span>
<span class="fu">--</span>
<span class="co">-- This parser should handle if-expressions:</span>
<span class="co">-- &gt;&gt;&gt; parse (parseTmIf parseTerm) &quot;if False then False else True&quot;</span>
<span class="co">-- Success (TmIf TmFalse TmFalse TmTrue)</span>
<span class="fu">--</span>
<span class="co">-- The sub-terms have to parse successfully:</span>
<span class="co">-- &gt;&gt;&gt; parse (parseTmIf parseTerm) &quot;if potato then False else True&quot;</span>
<span class="co">-- Failure (interactive):1:4: error: expected: term</span>
<span class="co">-- if potato then False else True&lt;EOF&gt;</span>
<span class="co">--    ^</span>
<span class="fu">--</span>
<span class="co">-- and we need to use the right keywords in the right spots:</span>
<span class="co">-- &gt;&gt;&gt; parse (parseTmIf parseTerm) &quot;if False potato False else True&quot;</span>
<span class="co">-- Failure (interactive):1:10: error: expected: &quot;then&quot;</span>
<span class="co">-- if False potato False else True&lt;EOF&gt;</span>
<span class="co">--          ^</span>
<span class="co">-- </span>
<span class="co">-- We also can't get away with truncating the expression:</span>
<span class="co">-- &gt;&gt;&gt; parse (parseTmIf parseTerm) &quot;if False then False else&quot;</span>
<span class="co">-- Failure (interactive):1:25: error: unexpected</span>
<span class="co">--     EOF, expected: end of &quot;else&quot;,</span>
<span class="co">--     term</span>
<span class="co">-- if False then False else&lt;EOF&gt;</span>
<span class="co">--                         ^</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse (parseTmIf parseTerm) &quot;if False then False&quot;</span>
<span class="co">-- Failure (interactive):1:20: error: unexpected</span>
<span class="co">--     EOF, expected: &quot;else&quot;,</span>
<span class="co">--     end of &quot;False&quot;</span>
<span class="co">-- if False then False&lt;EOF&gt;</span>
<span class="co">--                    ^</span>
<span class="fu">--</span></code></pre></div>
<p>In this case I’m using doctests for unit testing, so I have a test suite for doctests in my .cabal file.</p>
<p>I also have two modules for different approaches to parsing and printing, which collect the various approaches and capture their outputs in doctests. This is mostly in case I end up forgetting why I did something, but it’s been handy for blogging as well.</p>
<p>Doctests are also pretty good for a quick and dirty version of test-driven development. The next time pretty printers turn up in this series, we’ll be using a function that had my scratching my head for a while. Eventually I wrote all of the doctests that I wanted and started coding against them.</p>
<h1 id="a-repl-for-b">A REPL for <em>B</em></h1>
<p>We now have everything that we need for a read-eval-print-loop (REPL).</p>
<p>We’ll use <code>haskeline</code> for this.</p>
<p>It’s a Haskell version of readline, so it’s just we want for a REPL. This gives us some very nice things, including the ability to use up and down to move through history, Ctrl-R and Ctrl-S to search through the history, and Ctrl-A and Ctrl-E to go to the start or end of the line.</p>
<p>It has support for emacs or vim bindings, persistent history and command completion, so we can easily get quite a bit fancier if we want to.</p>
<p>For now we’re going to start slowly.</p>
<p>Haskeline programs run inside the <code>InputT</code> monad transformer. We use <code>runInputT</code> with <code>defaultSettings</code> to kick things off:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runInputT defaultSettings loop
  <span class="kw">where</span>
<span class="ot">    loop ::</span> <span class="dt">InputT</span> <span class="dt">IO</span> ()
    loop <span class="fu">=</span> <span class="kw">do</span>
       <span class="fu">...</span> <span class="co">-- here is where our loop goes</span>
       loop</code></pre></div>
<p>From there, we add reading and printing lines:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runInputT defaultSettings loop
  <span class="kw">where</span>
<span class="ot">    loop ::</span> <span class="dt">InputT</span> <span class="dt">IO</span> ()
    loop <span class="fu">=</span> <span class="kw">do</span>
      i <span class="ot">&lt;-</span> getInputLine <span class="st">&quot;&gt; &quot;</span>
      <span class="kw">case</span> i <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()
        <span class="dt">Just</span> <span class="st">&quot;quit&quot;</span> <span class="ot">-&gt;</span> return ()
        <span class="dt">Just</span> i' <span class="ot">-&gt;</span> <span class="kw">do</span>
          o <span class="ot">&lt;-</span> parseAndEval i' <span class="co">-- we still need to supply parseAndEval</span>
          outputStrLn o
       loop</code></pre></div>
<p>We can quit the loop with Ctrl-D on a blank line, in which case <code>getInputLine</code> returns <code>Nothing</code>.</p>
<p>We’re going to write the function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseAndEval ::</span> <span class="dt">String</span>
             <span class="ot">-&gt;</span> <span class="dt">Doc</span></code></pre></div>
<p>but in order to get the pretty colours from <code>ansi-wl-pprint</code> we need to use <code>putDoc</code>, which has the type <code>Doc -&gt; IO ()</code>.</p>
<p>To do that, we remember that <code>InputT</code> has a <code>MonadIO</code> instance, and replace <code>outputStrLn</code> with <code>liftIO . putDoc . (&lt;&gt; line)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> runInputT defaultSettings loop
  <span class="kw">where</span>
<span class="ot">    loop ::</span> <span class="dt">InputT</span> <span class="dt">IO</span> ()
    loop <span class="fu">=</span> <span class="kw">do</span>
      i <span class="ot">&lt;-</span> getInputLine <span class="st">&quot;&gt; &quot;</span>
      <span class="kw">case</span> i <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()
        <span class="dt">Just</span> <span class="st">&quot;quit&quot;</span> <span class="ot">-&gt;</span> return ()
        <span class="dt">Just</span> i' <span class="ot">-&gt;</span> <span class="kw">do</span>
          liftIO <span class="fu">.</span> putDoc <span class="fu">.</span> (<span class="fu">&lt;&gt;</span> line) <span class="fu">.</span> parseAndEval <span class="fu">$</span> i'
          loop</code></pre></div>
<p>Now we just have to write <code>parseAndEval</code>, which is a pure function. The parser from <code>trifecta</code> reports errors using the <code>Doc</code> type from <code>ansi-wl-pprint</code>, so that makes our task much easier.</p>
<p>Once we’ve realised that, all we really need to do is parse the string and then evaluate the resulting term:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseAndEval ::</span> <span class="dt">String</span>
             <span class="ot">-&gt;</span> <span class="dt">Doc</span>
parseAndEval s <span class="fu">=</span>
  <span class="kw">case</span> parse parseTerm s <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> err
    <span class="dt">Right</span> tm <span class="ot">-&gt;</span>
       prettyTerm tm <span class="fu">&lt;+&gt;</span> 
       text <span class="st">&quot;==&gt;&quot;</span> <span class="fu">&lt;+&gt;</span> 
       prettyTerm (eval tm)</code></pre></div>
<p>Now we have our first REPL!</p>
<h1 id="there-has-to-be-more-than-b">There has to be more than <em>B</em></h1>
<p>At this point we have some familiarity with the basic pieces we’ll be using when working with language.</p>
<p>We’re going to step things up to include languages with multiple types shortly, but before then we’re going to look at a few more uni-typed languages in order to fill up our bag of tricks.</p>
<p>To begin with, we’ll look at <em>N</em>, the language of natural numbers.</p>
<p><a href="../n.html">Read on!</a></p>
<h1 id="exercises-for-the-adventurous">Exercises for the adventurous</h1>
<ul>
<li><code>trifecta</code> can gather source locations as it parses. Add source annotations to <code>Term</code> and change the parser to annotate terms with the source locations of all of their sub-terms.
<ul>
<li>Don’t panic if you struggle with this - I’ll be covering it in one of the next few posts.</li>
</ul></li>
</ul>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on June 27, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
