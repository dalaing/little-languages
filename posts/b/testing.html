<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Testing B</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../../css/custom.css">
        <link rel="stylesheet" href="../../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Little Languages" href="../../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Little Languages" href="../../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../../">Little Languages</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../../posts/b/testing.html">Testing B</a></h3>
    </div>
    <div class="panel-body">
        <h1 id="quickcheck-for-b">QuickCheck for <em>B</em></h1>
<p><a href="semantics.html">Previously</a> we defined the semantics for <em>B</em>, and ended up with a set of properties we wanted to check.</p>
<p>If you’re not familiar with <code>QuickCheck</code>, I have written a little tour of the package <a href="../packages/quickcheck.html">here</a>. I’d recommend have a read through and then coming back here.</p>
<p>If you are familiar with <code>QuickCheck</code> and decide to skip that post, the things you’ll need to know for this are:</p>
<ul>
<li>we’re using shrinking wherever we can (including using <code>forAllShrink</code> instead of <code>forAll</code>)</li>
<li>we’re using pretty simple size strategies when recursively generating terms, at least for the time being</li>
</ul>
<p>Now that that’s out of the way, let’s sink our teeth into writing some <code>QuickCheck</code> code for <em>B</em>.</p>
<h2 id="generators">Generators</h2>
<p>We start of with some simple helper functions, to generate each of the terms in <em>B</em>.</p>
<p>As usual, the cases for <code>TmFalse</code> and <code>TmTrue</code> are simple:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTmFalse ::</span> <span class="dt">Gen</span> <span class="dt">Term</span>
genTmFalse <span class="fu">=</span> 
  pure <span class="dt">TmFalse</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTmTrue ::</span> <span class="dt">Gen</span> <span class="dt">Term</span>
genTmTrue <span class="fu">=</span> 
  pure <span class="dt">TmTrue</span></code></pre></div>
<p>We provide a very generic generator for <code>TmIf</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTmIf ::</span> <span class="dt">Gen</span> <span class="dt">Term</span> 
        <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Term</span> 
        <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Term</span> 
        <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Term</span>
genTmIf g1 g2 g3 <span class="fu">=</span>
  <span class="dt">TmIf</span> <span class="fu">&lt;$&gt;</span> g1 <span class="fu">&lt;*&gt;</span> g2 <span class="fu">&lt;*&gt;</span> g3</code></pre></div>
<p>I find that it’s usually good to build up an army of generators, in order to make it easier to think of and add new properties as soon as you think of them.</p>
<p>With these generators in place, we can build a generator for <code>Term</code>.</p>
<p>Since <code>Term</code> is a recursive data type, we’ll have to take some care with <code>QuickCheck</code>’s size parameter.</p>
<p>We’ll be interpreting the size parameter as an upper bound on the size of a <code>Term</code> - with the various caveats and addendums that were mentioned earlier in the <code>Tree</code> example - where <code>size</code> is given by:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">size ::</span> <span class="dt">Term</span> 
     <span class="ot">-&gt;</span> <span class="dt">Int</span>
size <span class="dt">TmFalse</span> <span class="fu">=</span> 
  <span class="dv">1</span>
size <span class="dt">TmTrue</span> <span class="fu">=</span> 
  <span class="dv">1</span>
size (<span class="dt">TmIf</span> t1 t2 t3) <span class="fu">=</span>
  <span class="dv">1</span> <span class="fu">+</span> size t1 <span class="fu">+</span> size t2 <span class="fu">+</span> size t3</code></pre></div>
<p>which is just counting the number of constructors used to build that particular <code>Term</code>.</p>
<p>We end up with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTerm ::</span> <span class="dt">Gen</span> <span class="dt">Term</span>
genTerm <span class="fu">=</span> 
  sized genTerm'
  
<span class="ot">genTerm' ::</span> <span class="dt">Int</span> 
         <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Term</span>
genTerm' s <span class="fu">=</span> 
    (<span class="kw">if</span> s <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> [] <span class="kw">else</span> nonZeroSizedGens) <span class="fu">++</span>
    zeroSizedGens
  <span class="kw">where</span>
    zeroSizedGens <span class="fu">=</span> [
        genTmFalse
      , genTmTrue
      ]
    nonZeroSizedGens <span class="fu">=</span> 
      <span class="kw">let</span>
        s' <span class="fu">=</span> s <span class="ot">`div`</span> <span class="dv">3</span>
        child <span class="fu">=</span> genTerm s'
      <span class="kw">in</span> 
        [genTmIf child child child]</code></pre></div>
<p>This is a bit of a mess, but we can clean it up by writing helper functions to do size-aware generation for each constructor of our term that has a recursive component.</p>
<p>In this case, we only need such a helper for ‘TmIf’.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTermTmIf ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Term</span>)
            <span class="ot">-&gt;</span> <span class="dt">Int</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Gen</span> <span class="dt">Term</span>)
genTermTmIf _  <span class="dv">0</span> <span class="fu">=</span>
  <span class="dt">Nothing</span>
genTermTmIf gen s <span class="fu">=</span>
  <span class="kw">let</span>
    child <span class="fu">=</span> gen (s <span class="ot">`div`</span> <span class="dv">3</span>)
  <span class="kw">in</span>
    <span class="dt">Just</span> <span class="fu">$</span> genTmIf child child child</code></pre></div>
<p>The function gets passed a size-aware generator for terms and the size that we’re after, and returns the appropriate ‘Gen’ when the size is larger than 0.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTerm ::</span> <span class="dt">Gen</span> <span class="dt">Term</span>
genTerm <span class="fu">=</span> sized genTerm'

<span class="ot">genTerm' ::</span> <span class="dt">Int</span>
         <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Term</span>
genTerm' s <span class="fu">=</span>
  oneof <span class="fu">$</span> [
      genTmFalse
    , genTmTrue
    ] <span class="fu">++</span> mapMaybe (\f <span class="ot">-&gt;</span> f genTerm' s) [
      genTermTmIf
    ]</code></pre></div>
<h2 id="shrinking-functions">Shrinking functions</h2>
<p>There’s nothing to shrink for the <code>TmFalse</code> and <code>TmTrue</code> cases:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkTmFalse ::</span> <span class="dt">Term</span> 
              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Term</span>]
shrinkTmFalse <span class="dt">TmFalse</span> <span class="fu">=</span> 
  <span class="dt">Just</span> []
shrinkTmFalse _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkTmTrue ::</span> <span class="dt">Term</span> 
             <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Term</span>]
shrinkTmTrue <span class="dt">TmTrue</span> <span class="fu">=</span> 
  <span class="dt">Just</span> []
shrinkTmTrue _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>With <code>TmIf</code>, we want to return - the immediate sub-terms, and - versions of the <code>TmIf</code> term where each of the sub-terms have been shrunk</p>
<p>We pass in the combined shrinking function for terms as a function argument, just like we did with the values and small-step rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkTmIf ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> [<span class="dt">Term</span>]) 
           <span class="ot">-&gt;</span> <span class="dt">Term</span> 
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Term</span>]
shrinkTmIf shr (<span class="dt">TmIf</span> t1 t2 t3) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span>
  [t1, t2, t3] <span class="fu">++</span>
  fmap (\t1' <span class="ot">-&gt;</span> <span class="dt">TmIf</span> t1' t2 t3) (shr t1) <span class="fu">++</span>
  fmap (\t2' <span class="ot">-&gt;</span> <span class="dt">TmIf</span> t1 t2' t3) (shr t2) <span class="fu">++</span>
  fmap (\t3' <span class="ot">-&gt;</span> <span class="dt">TmIf</span> t1 t2 t3') (shr t3)
shrinkTmIf _ _ <span class="fu">=</span> 
  <span class="dt">Nothing</span> </code></pre></div>
<p>and we combine these shrinking functions together in the usual fashion:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkTermRules ::</span> [<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Term</span>]]
shrinkTermRules <span class="fu">=</span> [
   shrinkTmFalse
 , shrinkTmTrue
 , shrinkTmIf shrinkTerm 
 ]

<span class="ot">shrinkTerm ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> [<span class="dt">Term</span>]
shrinkTerm tm <span class="fu">=</span>
  fromMaybe [] <span class="fu">.</span>
  asum <span class="fu">.</span>
  fmap (<span class="fu">$</span> tm) <span class="fu">$</span>
  shrinkTermRules</code></pre></div>
<p>Now we just need to wrap that up in a newtype and make an <code>Arbitrary</code> instance for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">AnyTerm</span> <span class="fu">=</span>
  <span class="dt">AnyTerm</span> {<span class="ot"> getAnyTerm ::</span> <span class="dt">Term</span> }
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">AnyTerm</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span>
    fmap <span class="dt">AnyTerm</span> genTerm
  shrink <span class="fu">=</span>
    fmap <span class="dt">AnyTerm</span> <span class="fu">.</span> shrinkTerm <span class="fu">.</span> getAnyTerm</code></pre></div>
<h2 id="checking-our-work">Checking our work</h2>
<p>Before we get too excited, it’s always a good idea to spend a little time in GHCi and check our working.</p>
<p>Generating terms seems to work:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> sample genTerm
<span class="dt">TmTrue</span>
<span class="dt">TmTrue</span>
<span class="dt">TmTrue</span>
<span class="dt">TmTrue</span>
<span class="dt">TmTrue</span>
<span class="dt">TmIf</span> (<span class="dt">TmIf</span> <span class="dt">TmFalse</span> (<span class="dt">TmIf</span> <span class="dt">TmTrue</span> <span class="dt">TmTrue</span> <span class="dt">TmFalse</span>) <span class="dt">TmFalse</span>) <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>
<span class="dt">TmFalse</span>
<span class="dt">TmTrue</span>
<span class="dt">TmTrue</span>
<span class="dt">TmIf</span> <span class="dt">TmTrue</span> (<span class="dt">TmIf</span> <span class="dt">TmFalse</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>) <span class="dt">TmTrue</span>
<span class="dt">TmTrue</span></code></pre></div>
<p>And so does shrinking terms (with some liberties taken around the formatting):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> shrinkTerm <span class="dt">TmTrue</span>
[]
<span class="fu">&gt;</span> shrinkTerm <span class="fu">$</span> <span class="dt">TmIf</span> <span class="dt">TmTrue</span> (<span class="dt">TmIf</span> <span class="dt">TmFalse</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>) <span class="dt">TmTrue</span>
[ <span class="dt">TmTrue</span>
, <span class="dt">TmIf</span> <span class="dt">TmFalse</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>
, <span class="dt">TmTrue</span>
, <span class="dt">TmIf</span> <span class="dt">TmTrue</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>
, <span class="dt">TmIf</span> <span class="dt">TmTrue</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>
, <span class="dt">TmIf</span> <span class="dt">TmTrue</span> <span class="dt">TmTrue</span> <span class="dt">TmTrue</span>
]</code></pre></div>
<p>Now we’re ready to do some stuff!</p>
<h1 id="properties">Properties</h1>
<p>We’re now going to convert the various properties that we want to hold into <code>QuickCheck</code>.</p>
<ul>
<li><p>Every value is a normal form</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propValueNormal ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
propValueNormal (<span class="dt">AnyTerm</span> tm) <span class="fu">=</span>
  isValue tm <span class="fu">==&gt;</span> isNormalForm tm</code></pre></div></li>
<li><p><em>B</em> has no stuck terms</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propNormalValue ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
propNormalValue (<span class="dt">AnyTerm</span> tm) <span class="fu">=</span>
  isNormalForm tm <span class="fu">==&gt;</span> isValue tm</code></pre></div></li>
<li><p><em>B</em> is determinate</p>
<p>Which means that for a given term, the output of all of the steps that apply to that term should agree.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propSmallDeterminate ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
propSmallDeterminate (<span class="dt">AnyTerm</span> tm )<span class="fu">=</span>
  canStep tm <span class="fu">==&gt;</span>
<span class="kw">let</span>
  distinctResults <span class="fu">=</span>
    length <span class="fu">.</span>
    group <span class="fu">.</span>
    mapMaybe (<span class="fu">$</span> tm) <span class="fu">$</span>
    smallStepRules
<span class="kw">in</span>
  distinctResults <span class="fu">===</span> <span class="dv">1</span></code></pre></div></li>
<li><p><em>B</em> is normalizing</p>
<p>Which we demonstrate by showing that the <code>smallStep</code> function always reduces the size of a term.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propSmallShrinks ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
propSmallShrinks (<span class="dt">AnyTerm</span> tm) <span class="fu">=</span>
  <span class="kw">case</span> smallStep tm <span class="kw">of</span>
<span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">True</span>
<span class="dt">Just</span> tm' <span class="ot">-&gt;</span> size tm' <span class="fu">&lt;</span> size tm</code></pre></div></li>
</ul>
<p>We also throw in some extra tests, to make sure that we’re not going to far off track.</p>
<p>We check that for each term, there is exactly one rule from the value or small step rules that holds:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propSmallUnique ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
propSmallUnique (<span class="dt">AnyTerm</span> tm) <span class="fu">=</span>
  <span class="kw">let</span>
    matches <span class="fu">=</span>
      length <span class="fu">.</span>
      mapMaybe (<span class="fu">$</span> tm) <span class="fu">$</span>
      valueRules <span class="fu">++</span> smallStepRules
  <span class="kw">in</span>
    matches <span class="fu">===</span> <span class="dv">1</span></code></pre></div>
<p>which will confirm that the rules are distinct and exhaustive.</p>
<p>Something a little weaker than this is implied by the first few rules, so this is mostly redundant. I’m throwing it in here as an early-warning canary, but I’ll take it out if it gets in my way. It’s already paid for itself as I’ve experimented with various things.</p>
<p>We also check that the small step evaluation function matches the big step evaluation function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propSmallBig ::</span> <span class="dt">AnyTerm</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
propSmallBig (<span class="dt">AnyTerm</span> tm) <span class="fu">=</span>
  Term.Eval.SmallStep.eval tm <span class="fu">===</span> Term.Eval.BigStep.eval tm</code></pre></div>
<p>This also acts as a sanity check, and has also helped me to spot bugs sooner than I would have otherwise.</p>
<p>I could have removed a few of the other properties once <code>propSmallUnique</code> was written, but I didn’t. I like to have <code>QuickCheck</code> tests written out explicitly for the properties that I want to hold. I’m fine with having a bit of redundancy between the properties if those properties are well known in the domain.</p>
<h1 id="syntax-for-our-semantics">Syntax for our semantics</h1>
<p>The above tests all pass and so we should be getting confident in our little language - so let’s take it our for a spin.</p>
<p>A great way to play with a language is through a read-eval-print-loop (REPL), which is what we’re going to look at next. This will mean we’ll have to work out how to parse and print expressions in our language, which will provide some additional entertainment.</p>
<p><a href="text.html">Read on!</a></p>
<h1 id="exercises-for-the-adventurous">Exercises for the adventurous</h1>
<ul>
<li>Add some more properties that are reasonable for <em>B</em>.</li>
<li>Are any of the properties redundant? Think about how we might work that out. Would you prefer a minimum set of properties, or an overlapping set of properties that map neatly to the concepts from PLT?</li>
<li>Investigate small check. What is the maximum depth term we need to be confident in all of our properties?</li>
<li>Write a REPL for <em>B</em>.</li>
</ul>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on June 27, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
