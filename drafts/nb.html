<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - NB - our first combination of types</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../css/custom.css">
        <link rel="stylesheet" href="../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Little Languages" href="../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Little Languages" href="../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../">Little Languages</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../drafts/nb.html">NB - our first combination of types</a></h3>
    </div>
    <div class="panel-body">
        <p>Previously we’ve looked at a couple of different little languages - <a href="b.html"><em>B</em></a>, <a href="n.html"><em>N</em></a> and <a href="i.html"><em>I</em></a>.</p>
<p>So far we’ve been able to get away with reusing the tests suites and REPL, and things have been going smoothly.</p>
<h1 id="combining-n-and-b">Combining <em>N</em> and <em>B</em></h1>
<p>Let’s see what happens if we put together a project with a term type that combines the terms from <em>N</em> and <em>B</em>:</p>
<p><img width="145" alt=" \begin{aligned} t =&amp; \ \text{O} \\   |&amp; \ \text{S t} \\   |&amp; \ \text{pred t} \\   |&amp; \ \text{true} \\   |&amp; \ \text{false}  \\   |&amp; \ \text{if $t$ then $t$ else $t$} \end{aligned} " height="137" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-65px;" /></p>
<p>and in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> <span class="fu">=</span>
    <span class="dt">TmZero</span>
  <span class="fu">|</span> <span class="dt">TmSucc</span> <span class="dt">Term</span>
  <span class="fu">|</span> <span class="dt">TmPred</span> <span class="dt">Term</span>
  <span class="fu">|</span> <span class="dt">TmFalse</span>
  <span class="fu">|</span> <span class="dt">TmTrue</span>
  <span class="fu">|</span> <span class="dt">TmIf</span> <span class="dt">Term</span> <span class="dt">Term</span> <span class="dt">Term</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>and copy the various rules across.</p>
<p>We should still end up with an evaluator, parsing and pretty printing functions and support for test data generation - albeit with a long list of rules contributing to each of them.</p>
<p>One thing that has changed is that we have some test failures:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">term
  eval
    every normal form is a value<span class="fu">:</span>    <span class="dt">FAIL</span>
      <span class="fu">***</span> <span class="dt">Failed</span><span class="fu">!</span> <span class="dt">Falsifiable</span> (after <span class="dv">9</span> tests)<span class="fu">:</span>
      <span class="dt">AnyTerm</span> {getAnyTerm <span class="fu">=</span> <span class="dt">TmPred</span> <span class="dt">TmFalse</span>}
    small step rules are unique<span class="fu">:</span>     <span class="dt">FAIL</span>
      <span class="fu">***</span> <span class="dt">Failed</span><span class="fu">!</span> <span class="dt">Falsifiable</span> (after <span class="dv">4</span> tests)<span class="fu">:</span>
      <span class="dt">AnyTerm</span> {getAnyTerm <span class="fu">=</span> <span class="dt">TmPred</span> <span class="dt">TmTrue</span>}
      <span class="dv">0</span> <span class="fu">/=</span> <span class="dv">1</span>
    small step and big step agree<span class="fu">:</span>   <span class="dt">FAIL</span>
      <span class="fu">***</span> <span class="dt">Failed</span><span class="fu">!</span> <span class="dt">Falsifiable</span> (after <span class="dv">24</span> tests and <span class="dv">3</span> shrinks)<span class="fu">:</span>
      <span class="dt">AnyTerm</span> {getAnyTerm <span class="fu">=</span> <span class="dt">TmIf</span> <span class="dt">TmTrue</span> (<span class="dt">TmPred</span> <span class="dt">TmTrue</span>) <span class="dt">TmZero</span>}
      <span class="dt">TmPred</span> <span class="dt">TmTrue</span> <span class="fu">/=</span> <span class="dt">TmIf</span> <span class="dt">TmTrue</span> (<span class="dt">TmPred</span> <span class="dt">TmTrue</span>) <span class="dt">TmZero</span></code></pre></div>
<p>They first two arise from the fact that we have some terms for which the step function is not defined - ie normal forms - other than the values.</p>
<p>This includes things like <code>TmSucc TmFalse</code> and <code>TmIf TmZero TmFalse TmTrue</code>. It happens that these look like nonsensical terms, so it would be nice to rule those out.</p>
<h1 id="typing-rules">Typing rules</h1>
<p>This is where type systems enter the story.</p>
<p>We’ll be looking at the type systems through a system of rules similar to what we had when we looked at small-step semantics.</p>
<p>Where we used to use</p>
<p><img width="198" alt=" \prftree[r]{Step-Rule}{\text{before} \longrightarrow \text{after}} " height="23" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p>to represent the rule that makes term <img width="46" alt="\text{before}" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFwAAAAZCAQAAAAWc4EMAAACPElEQVR4nO2Y0ZGEIAyGaYVKbIQ6KGObsAdboAMa8NlHXnzQC1Fmk4Dgrp4zN3NxbkRN8n8KmzCn1O+YURb+HrEJj0W5y5msmtWoXioofwPXCTkH2OtlcAs5IrCB8wpXj5i7AXyGHBrOHYJ3d2C17Tp4/N7TPu6ewr4DvCfgD9p1cPcP/rHsnwbXsFYdHMPhz6uHkhfrviMeFg4PGQKOLIs14Bn9PdR3anZXir4djvoTSgfgPbYPDY5DsSEZQBv3NDEiScX0sRguezNL9zV4h72idzh+99QJrrZ6b+CJwXxDU6kIzvudAYwgsBe2GGLMi13xpaIhPmBlT+YhA90OTJhhxHFsgeMppQxcrlC57oPoh7HRzJUMY9aGNADN5FUc9tot5wuu0kvVlaqQyf0t3ReCo0ASk+AW51CaZwvCFYFaSk3wrYknmZFMpSL30nMJ7vedS67DZ0nmbCudAJ8IzLJPKz08iZLgczGjxVnUJCb3aSl9CL4W0tHSJ8HXCrglMblPS+kL8FqLuhf8dDM8Bk/rNBTX7DF4KGbsEauu2lLKZMurrSceeZXQh0ulvAXgd8uqLaUmuGUVoMPXkMEDezEK2rGfYbKQNa0cvKWUgc9CZhJtoM+mUJPOmH/hHMuKDEdbu7qSEFkg7UQe+sIOge8nNPgb5i9fne8ytkZOPSas2CWgmpJwdJh6hLOFkBk3PrlZ3BxFb088Vnbw/hlwfxf9Z/YhjmNqShUzWDOL07Jbd1xVK/7f/K+lqPQDPKPaG0MVK40AAAAASUVORK5CYII=" class="inline-math" style="margin:0; vertical-align:-1px;" /> take a single step to become the term <img width="35" alt="\text{after}" height="12" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEcAAAAZCAQAAADJPfsTAAAB6ElEQVR4nM2Wy7WEIAyGaYVKaIQ6KMMm6MEW0oENuGbpxoXeJCISZJSZOfc44cwZ5ZF8vP6o1CdmlcPfT5hTsxpVpyY1PI1CMCtjWPxf8e1hmxFC479hHMN15iksWpsQn02EoVp4BsdnOId1T+FAFQd+CUer5ZdwqO7fcIzqMWDAy+yLFodlwNATPzk+yIZh6Oq7WHQxymMb+YN08MmT5w3ePcApVho8RrV1GHYSyktO6Zov/BSwr091c6wLYoRFD2PEIGyfPE1RtSzHo7a+tjKjeFuwyNm+s1mWwWW/LpscvW3xFnwe1cmA534ADCfqd3CmQrUNr2I+aojtJBSVDAiZ0taDt+N4EfwA3MNCpb0wjZ267P0bnLGyAWO22lDfoDqWw2HA+/spziLum0v3Ei5Hncwh84IDu3jiP8VZKzi7PDTiaF5OSIf5W5yrcA04IX7LvA5+j7O3ToWvt3EczyjXmSM4nGrucID1uzTdvllXaxFe9nmFY/gwm6Jvn5S5CUcqQWjCyb+BTLZB/rRdGtcrP5eXONt8jmQ24N3aPkV1UoiBkWXi0Nk6gNBhmYu0yGiBdadMuMIs3yy65H0UcMt5a3OzihLEuBkLVD7DHKdLqh9Scr7ydDId9SEP1mI20xRpRujNjf0B6atvv0w4XdkAAAAASUVORK5CYII=" class="inline-math" style="margin:0; vertical-align:-1px;" />, we will use</p>
<p><img width="120" alt=" \prftree[r]{Type-Rule}{\text{t} \colon \text{T}} " height="22" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPEAAAAtCAQAAADVPkXWAAAEoUlEQVR4nO2bzbWzIBCGaYVKaMQ6LMMm7MEW6MAGXLvMJovkg0EjMIMgn7nBn9dzz0lIgiOPjDMDl7EjSjCZdLQ/trNlIzp6ZVfHquw+TS8v9Xdq1eytjicMlzle0DJ83o/w/tfDIJSlkj3AFqle66NVrwawPu8GrNUN8ijg2r4sqS6xc1oMUltCDWIZwyDBttppExMmnt1jGdf2NUk1f11hxIw1ahhLEIWYKbivbFCXQNx4LRRipgaxBNGI5/Ycd30BxAMKV2jEZQxDCHGTHS9cADG+PBrxkPms21chxPWNOKxUxJIY2L9XCHEL7X5UkdrjyRFj0Yi1xJSsmGOe1dWnRTA9nxpItTQGDmmNzl1F4FytwqJzUxn8hqsQ4h7a7T5mO9qVlrlHjHirXQdTGLEuPzzhU10umJ/hZtjfKuZu4ddz7too597CDdDDe1+V+uYwDaFMDJZoxDURbI0on58tc4FixDl2HUxhxFomQXGBNd5A9ADcdpsdtNiqvKqSHkw/tsfCiLnq+6X6pmpcGF+8Jc+ug2kdsbnowWmpvacg5fxG78Z4eKgEVKlikpO/WIqY+kyhKCEHcZ5dB1MMsUDPvd6bQ5JwzI3zq5YYOD24sXqzP4sr8Bh9INrfjjjXroMphphBXXhByL05TSNm0OtcKh2QJzBtnf8jomf/WdxBbECFRdsRJ9qFV0RKOvDQ+4ojbmBQZ7UoIKERj9ZgvmDu1c5BB2W4ZxxuhZYStiNOtKsu+oi7nDhiBnH1DBYPbhzxmxhKk3aNU3y+HH7PGLFpxc56O+KwXadSCuJlYCoCZhpiesZK5Hf8nkOI6cr1dsRxP3d4pSBeQq6euMNpxA+21J/s11u0hhg/x7cjzrXrYEpBPIdcONTSohBzZpcnJPPzZPOdmENcQ0x7k22Ic+06mNIQm5CrI2s/FOLOSUcEBDb+wNG9+T2HEC+g5s87BHSIIM6162BKQ2xCLnoVWcIndvhjamI2mha5RK7mT2w1a62Aucy+0Wq3gQqweX1e59m1s767oU5MVehYhmrmSChk0tnlstWGwzOOSq2Ws3A2RqN9DrOQsu3xiQ20f+mcdvH59Tj5Hrdso72LjXC7XbvrWxvq/GTlHYkvOeHSjIyjrsAivanuSWw8MFeilwa0xX3gG26f7uFWqudASTB7F5d+95ysGGBJxP51qL8tdiEJIrTfqlI21NGhltbyLDYLjWtuTuyWdzZwc+MIX1j1AJ58tmy76h2yrlI21OFdX8snl8guaTW7IC5jQ13YS1wasdzh0n+3oU7AyqzR2s16YcQ6dfj/S//dhrr6cx6+2ru8Ro2I0j539+821OlbVKc+Aq0Q22c1Ef5rF491KIkp7F/WMfAs4JHoM6TUYsX/iwei1kU6Upiv8FKIzf/VPSGfnVdQ8Dx4kBXSuP4O8a2I1h01Z3h9NE034mIUexbnPqtvxMXoW8nEjbgY3YhPrxvx6XUjPr1uxKeXi3i/GvKNuBjdiE+vOOK8qvKNuBi11nYbQazF3AXMw4tbWzjxOlBuATN9Q92tP1ClcDynTXRYKf+4ZWvrhrpbf6TqfP8GdRX9A/7mb/PbrF2zAAAAAElFTkSuQmCC" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p>to represent the rule that associates the term <img width="8" alt="\text{t}" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAWCAQAAACMYb/JAAAAb0lEQVR4nGNgQAX2DGUMBEAZw3FCSvoIKzlOSIkiwz9CSo4z/MenxB6s4D/DNaCTIVARVcFihrdA+Auo5BeYBYIxZFg0EpS8pZ2SxUAlMAl7YGxhAaDE8B8oCTERRxKNAUbjL3DCwuuzGKB+ewQXAOfvQdmwc8HrAAAAAElFTkSuQmCC" class="inline-math" style="margin:0; vertical-align:-1px;" /> with the type <img width="14" alt="\text{T}" height="11" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAXCAQAAABdAYziAAAAfklEQVR4nGNggAF7huNEwcUMGKCM4T8Q/mK4Blf0DyzyGM5/C+a/xdR6HCi8DUUEohQZ2AONxqr1GpoIplYGhj6Gr9i09hGhlQHoDQzwmCGGKK1YHIwphF3rYwZFcrUeB8YFQYBdK1FgVOuo1qGtFVSY/McodAiA/1jhcXRlAH+4eVGOwHqAAAAAAElFTkSuQmCC" class="inline-math" style="margin:0; vertical-align:-0px;" />.</p>
<p>If these rules can be used to associated a type with a term, the term is said to be well-typed. If there is no rule that applies to a term, it is ill-typed.</p>
<p>In the material that I’ve seen, the typing rules are usually presented but there is little formalisation about what to do with ill-typed terms.</p>
<p>We’re going to do the same here, at least for now, although it’s something we’ll need to consider when we’re implementing the type system.</p>
<p>The two main operations that we will be performing with these rules are type checking - where we are checking an assertion that a particular term has a particular type - and type inference - where we are given a term and try to work out what type it has.</p>
<p>If we can do type inference, then type checking is trivial: we just need to check the inferred type for the term against the claimed typed of the term.</p>
<p>Type inference isn’t possibly in all languages, so we’ll end up with a number of trade-offs involving how much information we have to provide to help the inference process along.</p>
<p>There is also another approach worth knowing about - where the rules are split into checking rules and inference rules - known as bidirectional typing. I hope to return to this later on.</p>
<h1 id="typing-for-nb">Typing for NB</h1>
<p>In order to talk about the types of <em>NB</em>, we should define them.</p>
<p>There’s only two of them, and they’re both very simple.</p>
<p>This will be our notation:</p>
<p><img width="73" alt=" \begin{aligned} T =&amp; \ \text{Nat} \\   |&amp; \ \text{Bool} \end{aligned} " height="40" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJIAAABQCAQAAABYUuS6AAAENklEQVR4nO2cwbmsIAxGaYVKaMQ6LOM1YQ+2QAc24NrlbFx4nwQdgYQBZ1Bn/HLc3KsZxV8SiRKFiNEKnbG00d+XQYthWTpRBdtU0JbTUeJvXh5OEx6wpnv+34sJLI6lEvV8IQY49iikt02KZm7HBFu0+HdwSwjMwWtvTQ+NcZHz//1JrelAJqq31HNLJbH+FSo4tzcZ0W4m6Ec+Z3VyPbemB5mokxt2768u0e4KHbiCJjbB2rM6uRFJLY6Fe81+kf6VEEmjK9aCSArZhcH0GGx72ojL7RepiAfgw+KIRNsdw3rRbAAPL8zeVsi5T34skiJ2QUUkcdptdxVJkXfUvSLpyC3gQ+iIdB6b+1Muh0VSMGwwY6uwzQokMhe8Xpa9d8YodEQ6DzdGYpcLRWrm4GC313Ovezi2DUg3QuhYB6nFoiodkc7DFQm7nC+S8sZuxjocRx3kbnREilPBL/KWnEGEf7cNXW4IbP88WcwwtEUWxUV6JyLV2UtOTAiHJL7LYZHc0GD+xxbFRbo6ImGRqiWztPgSyGCIe5JIV0ckanCrHZejhwASUmMNve4EkfZGpPJgkcTyVML0byxSDc8ourlHVef0pKvHSAZKJNsuc/qhu/Uggnz+9gSR3olI6jkKSS/7727b2j+4c/kSDEG/T4lUJLV6JyLJzOea2rnir6BFsi43eadZg3DuPjeRtLOmsEjXR6S4SJvLbZZUv7FrBmdNUZG+ISIJIgdbCUXRqN8PSKTG+Y36vAOo5XngtSI14FSx2DV6ItmkZWuveX0wggPKZ7oiwcZG2VgfzUBGUogiT4Z3MXjHp59x+w5TwYU1t/8Wcn2bJE1eKmuEG696x/ItyCXl2cC5fgWPhBmGYRiGYRiGYRiGYRiGYRiGYZgvZ+CXOmmueN35c6RFaiITdvRBdS1271OZuSZlSIukoKJorbXbpqO2MKt2Kl6UaPb8QDNTLiXX3ex0rZDqoGlBePrOpXwmUrxu6TNuJpKdYjaVbJK4oUh0cddnsEiZR7uRSHayWemJ+DcTya7H46VK6KXeLTaWemVxK5Eacj6nmRv5eFZa9l69W57FTURS8/XvYIwU5n4SygDdedzdfPerdln8tEj+JHnjLC0SqUfVC2aurVson7b4aZFCFCQQ7lDS1APgD4O4ZYFpi5uJZD8E4iYmHZmmuBPg0xa3E2kN3msvGMkkxa03SVvcUCR/pERncrUzUT9tcUORxFIrIJ9/s0jkPrZtYSC3NLssbiiS8tyNPj13bdrihiL5H59SXgBeeTipS9ridiJZNwnr3Xx3qgUuN01b/KBIturOz7CqZy/CH9loHCvzUH+fRSfoj1ldRFokLeIf8BiJLwYazGdc7PuUbrahChrjFlfX9xEc1wwF71RePYxLW3wJX3KtvhsWKQMWKQMWKQMWKQMWKQMWKYMfGKUY/gNfxZs+wBK58wAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-17px;" /></p>
<p>and the translation to Haskell is easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Type</span> <span class="fu">=</span>
    <span class="dt">TyNat</span>
  <span class="fu">|</span> <span class="dt">TyBool</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>The rules start out very simple.</p>
<p>The values which don’t involve other terms have typing rules with no assumptions.</p>
<p>The term <code>O</code> has type <code>Nat</code>:</p>
<p><img width="116" alt=" \prftree[r]{T-Zero} {\text{O} \colon \text{Nat}} " height="22" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOgAAAAtCAQAAAAOhe/0AAAFIUlEQVR4nO1cy5XrIAylFSqhEepwGWnCPaQFOnADXrP0xovkgTA2H/GxnZk580bXmwQbZpILQroSYYzgIZjqusbqKCPTlWv6ps9CMBjY21yr+dI9dS9omff3Gt7r6igKnnmzxbx6mjH99ezoS/goLBXPqMURGEIYwtuEvgyBKRZoF/f/TUIvVGYQc0IZexhq6qO8mcxa3fpU9/5BwjkoQ1YMjFBm1ll9lHyfFGC86xOB8HHM2crCCa2b3DmbFn6c3AwTvhQ5UTihM+PVUdK7DzK3P4NeQlV1raXEcTC3r+okIHwTcELPwYUxuRl2GM2Oa+NTFfi/g2lVW4tAI18JIZSNakvjElDcJ3SoRJ/SuEnzRqSl3dOmIcSxe66EfT0Op7hpWzYbIeB17lMTCrhPaDn6lKY9JFpF61jDuxlev0DccOBmxCUy35O5T5R24i6hquIOLYnfK0ClCntO2/2Heecpm017PD3sHr3SDt2He4SKTQLEMEb0OSyBJKGQ+86A5+NNmcJFKOAeoa43bg7nwIyGbZ4Yhdx31OWyBUp+LUPwv169lFzDiJrbcTOYr82khtcUPK9QU72irc7x4mnj37vaKBOqt5zKccVw0We+t/lp9EYItZffH3FC8R15IB2qF2VCVWO9T4XoMyS0ph0RoV+CqyZ32PKoObywv6C74QGc0AVtHT8gf/wRXCOUw16HRZ9yH02h/ipvmFyFihR4KwHBNUJd9IkFEvP+xbuEWkr5c1eLcEIF5v7Aur0sAfJk8/6/cYVQWYw+n9FKGjOjywMNCCcUax8axruCEWQnV10zG7OiPqBPHM7FlEVsadHWd0OA6TwbtGPR5wClY6mqm2q0OuilYQ/Gvt9Q9fUC4gUepPlwK4ulKm0Gu6v2S2bLp9yHTZ18DlkH5/7n1QRfiTQkeTe9Ug9Z6OuveK8bmN6WyBSk12s9XK+F6a3X2qhBLGAEI5LPg6nzY7agNjcfG2u4lEsUv8aNF5e2MNfroij/YOUE7XLaJGGwKeO5GE1d8eAGqhAowWkepYUtPhLUKpijuLZyjdAHEVrCxDDd/8DcuN8DV9RRKnW8QuhPOFG/AqLpDrgSqEtb8w5fpYPnJ84Taq0KEYpCNU0qL8pcZ/6KL6nA6lfPE1qK4ghbdUvdy1wL4bcVIfr806OODjO7OaECQh0bu+aWQWyT8MhlUDY/AJYaSlEqI14KikmOsDAyN7spoeMesw0gdcjoniV6hX3dSxZUcbNDniA0Dfx5V1+HkNDc7MaEisi826fzkIpMbgHDCULx3EDf1xqXLqdmVyfPxlExVlFDhBZwhtA78kJaix6b3ZzQME+BJY+I0AL6zOb9ozgpoXHGIqaLJ7ouEXoKr2Q9XH2mjvy0SFjRioctHGR9d6qaCO3GjDo8IdwqvqcVYcd/ln2aYPmG2Uwje7JD0go9B7wY8dwTbWCEyj15lJrcGf5emAomQk9g7dBy7xnc0gE9X8oR06VZnKFvE0r1NhHqWm1b6+1B6cSlO+oTEpIXFR+EqqiNCC1iKqS1LHRVDer1fEuEHmb3eDJdj0eLjtqI0ArwMxVOAsAqGRz6pT9Mk3VICczPcWiE0DHoJejHnjC4wzM8aysXKPVLfyMY1pInHf8ukEjS7RNUO1kjzANJkAdFkvUD9H8YAxSFuZOKwnyla7NAqafiKD4jgtcUxSZTghtmQ5bndoJSgp4bi/CuqO1nqgV/ESR8iRp+LO0n572vDj6AZVTkn6kfDvAPPmZYMyckmpMAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p>and the terms <code>true</code> and <code>false</code> have type <code>Bool</code>:</p>
<p><img width="139" alt=" \prftree[r]{T-True} {\text{true} \colon \text{Bool}} " height="22" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARcAAAAtCAQAAAAuTOcgAAAEVUlEQVR4nO1cybWrMAx1K1TiRqiDMtIEPaQFd0ADrFmyYZF8D5B4kMwQOYT3db15MYrsE914kO6LEIzykEJtam1hH4xLoBFP3SbRvYL6sD396/VgXw+FfTAuAaXDeA96XGh9SE2FXKgpfDAuAaXXhBBpqIW4ibGwD8YloHQYQ0ChFnp7KeuDcQn0oo564FDnNhIKH4xLIA0hHOpeVEV9MC6BraFW+v5T0gfjooBDTeOjEa29WEuxZGvauf8WZWbSngWtPlgPujkvjJNRki6Dvh2ZJ40+7ZgTz3IFH5LMzGIZrly17u1nmpj3cuLvdJSky/LspoNu8LDJPAeVkCPuqbX9ED2P72SML6M0XUyQu/kUYzac2uvP02W069Ib0uaSGafiG3SBgrxGlxZ4nyFQfIlnfBXfoEuP9Ofo0gPv65Pygz0GcaNp6sNQb8UaXaB5rNHlMW9ifutSXw03srZl4cZD7Z74bb+P43R5AnQxja/TpwIPtUpWq/0+PqPLltWR8VX86mY02tWF8WP4VbqYV6kEouLN6FycRZd7Qpc+6JH2sBuT486Z3XNxFl2aiC5Gfxf2tMl2VOn15s9UuVv0OpsKiijgvD/EJ7oSF6Qkm0HoY7D5EyjIo7d6VNrupl8/gvUklHkamz+UpJP6G6PmUpl/BbzbfMHjo5BAMJ7HZEnfiviS/DxwF1nzEfbH85S6Z7IyB2ULkM3L8p36b4QpPior+ExlWSuQ4vcVFApcmOs57VRitCur1qSXH6qQvIo8mm9pLnATh+nijnb0mYSr06Uobhemi0trU8udmS4ZqEvTxd0faA9rTBcUlf5uMl3S0ZguILAb/G8Bo0sl3L+K0o/GdEkg5zC8L6jLTR6TD9MKiCtvxDwwurj+NP9Sz6W8Ds3N5CyYLgBcAmyy384l+bUs6ph8mFZAPIIVDAgwXVrbG3uu9LjjnByQ9u94q1qzYLqgwDcjTD5MJSCuRF7vEfv3LaX21tl1MV63TEo7TGp3ei71LgumCwqcLph8mE5AvP3cpOb8it/MOndP6NInJTRzmJ88eqxbMF1Q5OkCHyK/LyCGNyNpvfqzb8DtrfOqJOsWTJcM8nSB5MNkAuKds4RvRlNQBujAooBP/HULpksGebrgTwgExDtnCZ9y3HF3IeIEjuLKbNVGC6ZLBiXoQi8gxukSZl7gClIj3hXZdQumSwal6EKb+sPpshT0q8zITBcyhKSIL7/H6EIvIF6ny3vkdM7tLgumSwYl6EIvIMbpIoPNCA6037tuwXTJ4Ahd6ATEW4VZOF26YHuRwZF1gVlRbpstmC4ZtN5HI4MtBKcLlYD40yLAsonkSd5Ec9lmwXQBUXkrQfhDVrh8mEZAvKcI0ItUplC/VpZwjmGFypUj9ll0dnv7M+p4WtT6o5nmxPqCvHyYSkC8JRejorn4zfzGNeS30eMO88gTWNzELcIRfl/FfArqA1mRogLij+HP7qjFf4d/5UqNCHyVmFMAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p><img width="144" alt=" \prftree[r]{T-False} {\text{false} \colon \text{Bool}} " height="22" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASEAAAAtCAQAAABLoRVfAAAFPklEQVR4nO2cy7WrOgyGaYVK3Ah1UEaaoAdacAc0wJghEwbh+gXYssBiB4hzj36vc1ZCjCH4iyVLWrsoWM9JFJLUmsNRGsIIaQ2mvdU/1g+pLmbVpqJbp/ptjvTr+8G8P57WBj3Ttt4cnUn30hZj8lqszCTVlLXBkSGacKEQo0yrNGfW0fHSgFGR74cR+ilJtf6EihEqipeCgDIWjpCG6I0ex8dghH5KUuERCkOoUAhQxtpDqEh6U/4YjNBPqY8MDI7QJ4ZM60VyqBmhH1Q8XThCvTJGKR0hJCKDuT8GI/RToiIkCb5MjFDjrXG8Cv0zwhGiKEYoBk+o/Z+O/nQ7vlGMUG1cfh0ceKmVMASxUZ/o0aQal5WNrkSoAwg1q+9Vqz3eiGz0IUK9GmMxoW0QdqzU+b1DR59Fc9dZD+g6hGqwlRdqyv13b9WghxUiJEEwQa6fVSCKrc+De0vWl/QpQqNLVEyIWZsDaLoorAkRGoHhKtfPRjC2MDF2Vhb6FKFWTa1uL5PagAjNnteCuc7hsbfCIlyn7DrWIMDQI+Csm3WlLzQG70oQyEwj1BlUGg8jC2BvcnGh+nhNG7jd0NJO5707Mq3SJFRtAvcYIeFStxqk3kNJH+3carc0jRsIHNTcbmjpze8RQoOb0K2dRahWKLzVdL+U0UmvQjYkuV1tcqZqRhCifTvWAzpCSEarWvjpfnRaqzTGRq5rCQUhq3otGrHu+ByvOKx8dKUhi0fuQP9jhEJMhHGZtb8zgpFYWekuhGxxWwn6D+5VfExrBvsx4dxoaYIHUCUbsjx0F0LxmrMdGXZ6xTFnGymybjYEpj0foa7U7XIk4GrdiVAYyxkICEFD93aYNJEp07WR6WoCT7XZ5ulqOopNtK7f84Xdzc7WWiKlXlfo8+8pXFQZRo3TKp3Du+fm2pVjWyc69fOfjKkqvRiPjQQtKMxm97ap9cxXWLKr49anlpPaMVglHLit/3cKu4XZS4zRJrQ1j+r9h4k61iffE27X5xP7nnizj81KZSDTG/rWJWArkycbvK16eL7+X6dmW/PNBi/lar/tYAybzuTHpXMJTc7REkUYMj/S9ypRJGoaKhcgu+Nq+VbclO5HtOlo6pfP7DmYmRJ/iwfV3kMS5NNzQ0gvy3fEN/JGKBM1f3pI+SFkA/WUwvazV2OEEvrbQ8oRIetDXLurZIQIYoRSV2OEEvq/IFQWcxQrueZqjNCBtP/dmfA2zM0+W9hd7uwQ9q6MIWSPx/GhyqUzu93Y0VEPRigh/eAm44SG9S9PF3aPaJYGF45QY47CsXWYbSnUEuY1/CapHowQQfFDerqwuyyof61iGcHvK9R4nYkJwRWuNPj7d96pu6lO9WCECMITds8WdssTER3p4j9+0ytoGyHUR4HSEtQPp3swQgThCOVb2I0bMlv94mNYo8bR/zmkezBCJMUP6fHC7tP3i+/IpiDF0aEJDz/Dne7BCJG0/5AeK+w+fb+432Rd6gXPCb2OX6qV7sEIkbRXX5trYfc+QmFkCM+YWUBqYg9GiCTMkOVc2L2P0FLgUK6vGaFHFD+kvAu70whZQffaqjnVgxEiCT6k3Au79xESgSHDJ98/mu7BCJEEH9J3Crtpf35yuTKOUBeYJhH9FOx9baHNdA9GiCQMoacLuz9PcCwGCH6T0FDVRWyi0z0YoYTCEu1vFHafS3BYdz0co1pXoBDOMCdnky3nesCnwwIKS7S3vNbThd20WJEEV/bbZFCPVZu/0GOvPaEp3v0eqQJ41qEyKey+RPbaR/ef7vEP6z+rB0Us6KXmAgAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p>The successor and predecessor terms are a little more complicated. They each have type <code>Nat</code> if their arguments have type <code>Nat</code>:</p>
<p><img width="124" alt=" \prftree[r]{T-Succ} {\text{t} \colon \text{Nat}} {\text{S t} \colon \text{Nat}} " height="33" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<p><img width="148" alt=" \prftree[r]{T-Pred} {\text{t} \colon \text{Nat}} {\text{pred t} \colon \text{Nat}} " height="36" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p>The <code>if</code> terms are a bit more frisky.</p>
<p>If the first argument has type <code>Bool</code>, and the second and third arguments have the same type <code>T</code>, then the whole <code>if</code> term is of type <code>T</code>:</p>
<p><img width="199" alt=" \prftree[r]{T-If} {t_1 \colon \text{Bool}} {t_2 \colon \text{T}} {t_3 \colon \text{T}} {\text{if $t_1$ then $t_2$ else $t_3$} \colon \text{T}} " height="36" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAY8AAABICAQAAACkCbHUAAAKlklEQVR4nO1dybWrMAylFVfiRqiDMtJEeqAFOqCBrFmyySLveYDEgzwiEwi+nH/OfwkxkqwLsi3kpjkK7s0EHgM7bgWuJ1t/sX9HAxU6h4/7twU1cFa5TwHadMx0c/PHjpH9fz169tcfc+Me+Xq8ZX6149GjEzZ4Mr1Xh3qJTx7vvyfx99EkP6vcqLgxdUmx1gdhQBOtMPRY5GpbOquMLbhU+s1gsqxCmRvmSl6qB0vLfQpwR22LtQ7To2Fm558PBa62pbPK2GKwbgS2m3EnnzPbL9WDpeU+AVoR6JSDix6yU7GvvI0epWxhj7UgN2syr12uB8vKfQr0IpYsBzc9pKlx73rb6FHKFg9LS9jN8iQv14Nl5T4FHlZ8iYsz0aOULWyJYDfLG0GU68Gycp8Cz6IjDzc9yDIrgn+1fHqUskWsmw1Nl9F6uR4sK/eBQZZJ1ptQV/4/xcT893F3DBc95Of2+kcrpgsnNih0rY34zsihxzZbxFtCBexmKdivB1Vsl/sUoMsi2lPcwdflunjw9YW4+QqYHnfxqbmcRNhjel7uRFT83+zw0Bk59Nhmi3hLqNjuZvv1oIqL0GNFXtwqA6M4M5n0oOx+N4o1D2q1OrNDvaONzUtz//AZW4KrHFukWEIFnpuV70EVF6NH7oz5EL1mMSzrG+rB73S9RQ/e0fpnhMn3VOgQPmMLPfJsEW8JFXhuVr4HVVyKHqXXPDjg4IqKh7vaPR34sB+Ve2P4jC302MMWH2C52b5SX4wevhlzipTy4Z65ejZqWsnYQEkmgzK7FT5jCz1gW3TiWTeiJ91huZmrB+X0xYN9jzvleil6wHFrx5xhFA9tDLjXPeTwfL3+E3zYy6Q4EnnGFnpAtuCBIA9cbuzaT9TJUyw3g3uQy80tQqyx2VZcih5w3MoTlKkwBAbc9NBXPuAMrG6Ztow7Yws9bFvclKtRISnenRjLzaAebJVsaNrgri1diB7+uLU8PZpl9oS8//89ekC20KeNuT3wQiwcN4N7UB+j4brzhejhz9XZjx4S5lBd4p50Rj49IFtM2vXyZnpcwHEzVw/2b1q39emRCz1uhZwDA256UC24gh1b/TR8Rj49IFu0SwQPnbEVOG7m70EObg/MNzMvRA81V6ez7owhesRm2bjpMWrhEtWG2CtmpXvDZ+TTw28Lub5irrmsyMk3wnEzv9SEUeflCQi/J/cpoCo6WW7np8fWpJI1KJqMM/Uu5lH0mHxGDj38toDem1vxzeQMn9SDeJH54STBVZJK2sRctDfmt6JQcp+PHikpCY/GTltv308Os0vV4W8ryiqknTE2eTNMflu0jevF37zkDCru+9uDNb/UHHfHVb4rt2xre5mHu3W2fjPomLwP8TZjxhoed65B1BOBTOt/eowRA9Vh6QLo4K/3Q5zumCqylsnIzoFM4z5Dv0Ja6OCzResNUWIs4ZJxPXKH/P4elJgdtvim3BwYZR5aEVKuv+vZX2r4u0YWbYY/CMikaBhYQ/N00GBydviMdLhswe+Yx32bAZKaWkmaJd8GzQVemYfB4f7PZaQqx6zwuDEb36PHkUCYHXxD9iPipTnL1uIUpYBX5gGmR6foTbHJUenBQbQQsD/wU0SF7iwT0lgBG3hlHmB63MveFubL00O+XfKp7oj+gC6EwUiGmZHTEnGAV+YBpkexpyYfFM3LwGk65IN5HzysoehZMIiZLJ5aynvwmKTGK/OwMz0qzg8iEip75OkLTOCVeaj0qLgAcpccbXrw2bxRhJWyRMUxn58VFQnAo8daouK1jBprBfmK0wOPHuunNbiq+BlUelRUOFHpUVHhxK70gDcuq0c9vnOEE3J2pUdXj3oc6AivwLjpMXkXaGtwVXEBuOkxWM8i/dtKj4qfRx2aV1Q4UelRUeFEpUdFhRMHp0d2TYeKis3ILfNAlhcPzN/lFuUAsammAwrkjMTrZx+IZ9cPo7IIjPwyD/aE7wC0mGBxztGX9Rrj5poOCFhrTpzVfULo2P1tPrF+GJVFDo8BVCGtpsMNYaNeCpLw+8MpDN3c2EO/UhrgVRY5MKjgvP4ATK3pkLtdl35N6OH5fXpg6ObGHvqV0gCvssihQSwCpNV0wNmu63ZIepTeiqy8fuU0wKsscjKkdZp/24P4ax6RHji6uVFev3Ia4FUWORnSOg2jkD8RxS+3SoIP3E0KbJTXr5wGeJVFToa0TnsixLaurWS+TQ8M3Xwor185DfAqixwWsmSvOjfNU41jajqQ5fvbMvUbl6IMgS6zZ+M71RnalbxbJgvha/CtQeU7BHrJ4VvzqdLtb6GMbn75IHp0Ysg7iDUnYt0yXO1ga0C0XojF+TYzCMCem+bGj6npQJfvn81aHC7mBRcbd6uVSelI6T68dGfPrkjE3+Z8SSt2raDv8z8Sr8XrhkALpXQLyWfT48FkW92yN5YMfe1ga3CVvT4iYN/BUh75OLGtP7hS69rOhmO0hhOZm4PJln0tuIGhm18+c6M33SUH5buQnjDyNMjb66PSAwDOrLqPHi/rfqve/c3dKmijby0pdfG14AaGbn75dEvPhg2I9p1fTxi5GuRtK1rpYQBrVt1HD/tFyY9sd8BJZs0lQi24gaFbSD5dlpeVMrdOyYb1hFB61cZEpYcB36w6TUhmjJ+50j95ANfXA4p87Vy6dSLoGaMCtJB8uiwyp/SuUIQqv/HrmaJBKzTguyfhTrlWehiAu6gTMyyvBFPl0uOlzXh173m3IboFN2Dd1rmvG3PkZzBwCcmny0KXpL4/kS2t0iSsZ5oGvGUi+ghz0rfSwwAc2/KJYtqkbJeTS48/wG306eh87SDd1NQXGf37778h+UxZ6LIF6UqSNrKdeA34EH+lTNz4JR6VHhr8se1e9PDfQXO1g3V7sIj/43BcQ3+IFZIPlqUT6x5/QgIS1Q4EWAOebvqZH8N150oPDf58nnx6TNrnPtnmJjQLlasdrNtkBW5+pw3JZ07sqqDi131UOxBcvfPZ46OtT48wsKJzsyv2oMfQQMtXBCG4gnVrG3Xn9fDgOCSf+SzUQzX6dvCwnrEamNKF107iUemhQc3nsd/X2IMecjBrOkmvhDy52vl14yDgtXWE5DPpYYZq60pIWM9UDYhYlXf/PidPqtJDg2qMyRqkptBDfcNEnRAOy3a3wg6ibS2Zq51ft7Wd8Iq0Xz6THqZcHwcO6WnDp8EgVugfThLUpJI3ZAIiMT6Jqenw2at2BB7SKfRQ78Rqhqctif2J7qbqvuOxLUDw6ybj9rjRgE8+XRY+lFbb7DUX9euZroGkHETwvKSS3MoiB4ZdxjelpkMr3tLgSYWQ+dP2QW/FOoLMqYVk68BPJDqRfMh/OWov6cS3kKpb6w1MTMDyQdLxFaOH2C+9F0uPJKKdPA0kzFSVFeE1FRX5lUV+HDJxGkYaPTja4Ey+GzRiHSANbt34fTI1No+R7zNS0NP6U9tZAWlANVrxJ1LJtyErnEinxzmghjXwoP3IeGnPi2+/bnZh/CY9iJYc35/uTTg9qJx+a6xwJsw/SA8+WzQ3n10lwjXAjga15AW1JmUqdsDQrO/pyTfVfgcPawB6PgxiJotPAvDeORu9KyoKg4jUyj4493UJ/AOKoxSTkykJAwAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-3px;" /></p>
<p>This gives rise to two interesting situations.</p>
<p>We can use a term from <em>B</em> to create a term from <em>N</em>:</p>
<pre><code>if true then O else S O</code></pre>
<p>and we can create a term that is ill-typed but will still evaluate under the combination of small-step evaluation rules:</p>
<pre><code>if true then O else false</code></pre>
<p>We’ll have a closer look at that when we cover the properties that we want to hold for our type systems.</p>
<h1 id="typing-in-haskell">Typing in Haskell</h1>
<p>The general approach that we’re going to take to set up this rule system in Haskell is similar to what we have done so far.</p>
<p>We’re going to create a set of rules that will be combined to create a type inference function. Since some of those rules are inductively defined, they will be given the type inference function as an input. This is fine, because of Haskell’s laziness.</p>
<p>While we ignored the ill-typed terms when specifying the typing rules, they’re the first thing we need to deal with when writing code for our type system.</p>
<h2 id="type-errors">Type errors</h2>
<p>We’ll be doing our error handling with <code>MonadError</code> from <a href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html">Control.Monad.Except</a> from the <code>mtl</code> package.</p>
<p>The <code>MonadError</code> class takes two type parameters - the error type and the monad type.</p>
<p>If we have some error type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MyErrorType</span> <span class="fu">=</span> 
    <span class="dt">UnsupportedUniverse</span>
  <span class="fu">|</span> <span class="dt">UnknownPotato</span></code></pre></div>
<p>and we’re operation in some monad stack <code>m</code> with <code>MonadError MyErrorType m</code> in the context, we can raise errors in that context with <code>throwError</code>.</p>
<p>This is what it tends to look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myErrorFunction ::</span> <span class="dt">MonadError</span> <span class="dt">MyErrorType</span> m 
                <span class="ot">=&gt;</span> m <span class="dt">Int</span>
myErrorFunction <span class="fu">=</span>
  <span class="kw">if</span> (<span class="dv">1</span> <span class="fu">==</span> <span class="dv">2</span>)
  <span class="kw">then</span> throwError <span class="dt">UnsupportedUniverse</span>
  <span class="kw">else</span> return <span class="dv">3</span></code></pre></div>
<p>We’ll often write little helper functions to check our error conditions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">checkUniverse ::</span> <span class="dt">MonadError</span> <span class="dt">MyErrorType</span> m
              <span class="ot">=&gt;</span> m ()
checkUniverse <span class="fu">=</span>
  when (<span class="dv">1</span> <span class="fu">==</span> <span class="dv">2</span>) <span class="fu">$</span>
    throwError <span class="dt">UnsupportedUniverse</span></code></pre></div>
<p>in which case our old function would turn into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myErrorFunction ::</span> <span class="dt">MonadError</span> <span class="dt">MyErrorType</span> m 
                <span class="ot">=&gt;</span> m <span class="dt">Int</span>
myErrorFunction <span class="fu">=</span> <span class="kw">do</span>
  checkUniverse
  return <span class="dv">3</span></code></pre></div>
<p>Our <em>actual</em> error type will look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TypeError</span> <span class="fu">=</span>
    <span class="dt">Unexpected</span> <span class="dt">Type</span> <span class="dt">Type</span>
  <span class="fu">|</span> <span class="dt">ExpectedEq</span> <span class="dt">Type</span> <span class="dt">Type</span>
  <span class="fu">|</span> <span class="dt">NoMatchingTypeRule</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We’re including <code>NoMatchingTypeRule</code> here so that we have a value we can return if no rule applies to a term. We <em>could</em> have left that out and used <code>Maybe TypeErrro</code> in its place but we didn’t. This is mostly to avoid a form of Boolean blindness - we don’t want people (i.e. me, later on) - thinking that we are missing a <code>TypeError</code>, so we encode the reason or reasons that lead to us not having more information available.</p>
<p>Later on we’ll test that type inference never results in <code>NoMatchingTypeRule</code>, after which we’ll breathe a sigh of relief.</p>
<p>We’ll also introduce two helper functions to check for our error conditions.</p>
<p>The first is used to check that we’re dealing with the type that we expect:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">expect ::</span> <span class="dt">MonadError</span> <span class="dt">TypeError</span> m
       <span class="ot">=&gt;</span> <span class="dt">Type</span>
       <span class="ot">-&gt;</span> <span class="dt">Type</span>
       <span class="ot">-&gt;</span> m ()
expect actual expected <span class="fu">=</span>
  unless (actual <span class="fu">==</span> expected) <span class="fu">$</span>
    throwError <span class="fu">$</span> <span class="dt">Unexpected</span> actual expected</code></pre></div>
<p>and the other is used to check that two types are equal:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">expectEq ::</span> <span class="dt">MonadError</span> <span class="dt">TypeError</span> m
         <span class="ot">=&gt;</span> <span class="dt">Type</span>
         <span class="ot">-&gt;</span> <span class="dt">Type</span>
         <span class="ot">-&gt;</span> m ()
expectEq ty1 ty2 <span class="fu">=</span>
  unless (ty1 <span class="fu">==</span> ty2) <span class="fu">$</span>
    throwError <span class="fu">$</span> <span class="dt">ExpectedEq</span> ty1 ty2</code></pre></div>
<h2 id="typing-rules-1">Typing rules</h2>
<p>We’re going to bring the type checking rules across to Haskell, using <code>Maybe</code> to determine which rules apply and using <code>MonadError TypeError m</code> to do our error handling. We could be doing all sorts of things with <code>m</code> later on, so we leave it generic for now.</p>
<p>The first few rules don’t have any need for any error handling, so we relax the constraint to <code>Monad m</code>:</p>
<p><img width="116" alt=" \prftree[r]{T-Zero} {\text{O} \colon \text{Nat}} " height="22" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOgAAAAtCAQAAAAOhe/0AAAFIUlEQVR4nO1cy5XrIAylFSqhEepwGWnCPaQFOnADXrP0xovkgTA2H/GxnZk580bXmwQbZpILQroSYYzgIZjqusbqKCPTlWv6ps9CMBjY21yr+dI9dS9omff3Gt7r6igKnnmzxbx6mjH99ezoS/goLBXPqMURGEIYwtuEvgyBKRZoF/f/TUIvVGYQc0IZexhq6qO8mcxa3fpU9/5BwjkoQ1YMjFBm1ll9lHyfFGC86xOB8HHM2crCCa2b3DmbFn6c3AwTvhQ5UTihM+PVUdK7DzK3P4NeQlV1raXEcTC3r+okIHwTcELPwYUxuRl2GM2Oa+NTFfi/g2lVW4tAI18JIZSNakvjElDcJ3SoRJ/SuEnzRqSl3dOmIcSxe66EfT0Op7hpWzYbIeB17lMTCrhPaDn6lKY9JFpF61jDuxlev0DccOBmxCUy35O5T5R24i6hquIOLYnfK0ClCntO2/2Heecpm017PD3sHr3SDt2He4SKTQLEMEb0OSyBJKGQ+86A5+NNmcJFKOAeoa43bg7nwIyGbZ4Yhdx31OWyBUp+LUPwv169lFzDiJrbcTOYr82khtcUPK9QU72irc7x4mnj37vaKBOqt5zKccVw0We+t/lp9EYItZffH3FC8R15IB2qF2VCVWO9T4XoMyS0ph0RoV+CqyZ32PKoObywv6C74QGc0AVtHT8gf/wRXCOUw16HRZ9yH02h/ipvmFyFihR4KwHBNUJd9IkFEvP+xbuEWkr5c1eLcEIF5v7Aur0sAfJk8/6/cYVQWYw+n9FKGjOjywMNCCcUax8axruCEWQnV10zG7OiPqBPHM7FlEVsadHWd0OA6TwbtGPR5wClY6mqm2q0OuilYQ/Gvt9Q9fUC4gUepPlwK4ulKm0Gu6v2S2bLp9yHTZ18DlkH5/7n1QRfiTQkeTe9Ug9Z6OuveK8bmN6WyBSk12s9XK+F6a3X2qhBLGAEI5LPg6nzY7agNjcfG2u4lEsUv8aNF5e2MNfroij/YOUE7XLaJGGwKeO5GE1d8eAGqhAowWkepYUtPhLUKpijuLZyjdAHEVrCxDDd/8DcuN8DV9RRKnW8QuhPOFG/AqLpDrgSqEtb8w5fpYPnJ84Taq0KEYpCNU0qL8pcZ/6KL6nA6lfPE1qK4ghbdUvdy1wL4bcVIfr806OODjO7OaECQh0bu+aWQWyT8MhlUDY/AJYaSlEqI14KikmOsDAyN7spoeMesw0gdcjoniV6hX3dSxZUcbNDniA0Dfx5V1+HkNDc7MaEisi826fzkIpMbgHDCULx3EDf1xqXLqdmVyfPxlExVlFDhBZwhtA78kJaix6b3ZzQME+BJY+I0AL6zOb9ozgpoXHGIqaLJ7ouEXoKr2Q9XH2mjvy0SFjRioctHGR9d6qaCO3GjDo8IdwqvqcVYcd/ln2aYPmG2Uwje7JD0go9B7wY8dwTbWCEyj15lJrcGf5emAomQk9g7dBy7xnc0gE9X8oR06VZnKFvE0r1NhHqWm1b6+1B6cSlO+oTEpIXFR+EqqiNCC1iKqS1LHRVDer1fEuEHmb3eDJdj0eLjtqI0ArwMxVOAsAqGRz6pT9Mk3VICczPcWiE0DHoJejHnjC4wzM8aysXKPVLfyMY1pInHf8ukEjS7RNUO1kjzANJkAdFkvUD9H8YAxSFuZOKwnyla7NAqafiKD4jgtcUxSZTghtmQ5bndoJSgp4bi/CuqO1nqgV/ESR8iRp+LO0n572vDj6AZVTkn6kfDvAPPmZYMyckmpMAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTmZero ::</span> <span class="dt">Monad</span> m
            <span class="ot">=&gt;</span> <span class="dt">Term</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m <span class="dt">Type</span>)
inferTmZero <span class="dt">TmZero</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span>
  return <span class="dt">TyNat</span>
inferTmZero _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p><img width="144" alt=" \prftree[r]{T-False} {\text{false} \colon \text{Bool}} " height="22" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASEAAAAtCAQAAABLoRVfAAAFPklEQVR4nO2cy7WrOgyGaYVK3Ah1UEaaoAdacAc0wJghEwbh+gXYssBiB4hzj36vc1ZCjCH4iyVLWrsoWM9JFJLUmsNRGsIIaQ2mvdU/1g+pLmbVpqJbp/ptjvTr+8G8P57WBj3Ttt4cnUn30hZj8lqszCTVlLXBkSGacKEQo0yrNGfW0fHSgFGR74cR+ilJtf6EihEqipeCgDIWjpCG6I0ex8dghH5KUuERCkOoUAhQxtpDqEh6U/4YjNBPqY8MDI7QJ4ZM60VyqBmhH1Q8XThCvTJGKR0hJCKDuT8GI/RToiIkCb5MjFDjrXG8Cv0zwhGiKEYoBk+o/Z+O/nQ7vlGMUG1cfh0ceKmVMASxUZ/o0aQal5WNrkSoAwg1q+9Vqz3eiGz0IUK9GmMxoW0QdqzU+b1DR59Fc9dZD+g6hGqwlRdqyv13b9WghxUiJEEwQa6fVSCKrc+De0vWl/QpQqNLVEyIWZsDaLoorAkRGoHhKtfPRjC2MDF2Vhb6FKFWTa1uL5PagAjNnteCuc7hsbfCIlyn7DrWIMDQI+Csm3WlLzQG70oQyEwj1BlUGg8jC2BvcnGh+nhNG7jd0NJO5707Mq3SJFRtAvcYIeFStxqk3kNJH+3carc0jRsIHNTcbmjpze8RQoOb0K2dRahWKLzVdL+U0UmvQjYkuV1tcqZqRhCifTvWAzpCSEarWvjpfnRaqzTGRq5rCQUhq3otGrHu+ByvOKx8dKUhi0fuQP9jhEJMhHGZtb8zgpFYWekuhGxxWwn6D+5VfExrBvsx4dxoaYIHUCUbsjx0F0LxmrMdGXZ6xTFnGymybjYEpj0foa7U7XIk4GrdiVAYyxkICEFD93aYNJEp07WR6WoCT7XZ5ulqOopNtK7f84Xdzc7WWiKlXlfo8+8pXFQZRo3TKp3Du+fm2pVjWyc69fOfjKkqvRiPjQQtKMxm97ap9cxXWLKr49anlpPaMVglHLit/3cKu4XZS4zRJrQ1j+r9h4k61iffE27X5xP7nnizj81KZSDTG/rWJWArkycbvK16eL7+X6dmW/PNBi/lar/tYAybzuTHpXMJTc7REkUYMj/S9ypRJGoaKhcgu+Nq+VbclO5HtOlo6pfP7DmYmRJ/iwfV3kMS5NNzQ0gvy3fEN/JGKBM1f3pI+SFkA/WUwvazV2OEEvrbQ8oRIetDXLurZIQIYoRSV2OEEvq/IFQWcxQrueZqjNCBtP/dmfA2zM0+W9hd7uwQ9q6MIWSPx/GhyqUzu93Y0VEPRigh/eAm44SG9S9PF3aPaJYGF45QY47CsXWYbSnUEuY1/CapHowQQfFDerqwuyyof61iGcHvK9R4nYkJwRWuNPj7d96pu6lO9WCECMITds8WdssTER3p4j9+0ytoGyHUR4HSEtQPp3swQgThCOVb2I0bMlv94mNYo8bR/zmkezBCJMUP6fHC7tP3i+/IpiDF0aEJDz/Dne7BCJG0/5AeK+w+fb+432Rd6gXPCb2OX6qV7sEIkbRXX5trYfc+QmFkCM+YWUBqYg9GiCTMkOVc2L2P0FLgUK6vGaFHFD+kvAu70whZQffaqjnVgxEiCT6k3Au79xESgSHDJ98/mu7BCJEEH9J3Crtpf35yuTKOUBeYJhH9FOx9baHNdA9GiCQMoacLuz9PcCwGCH6T0FDVRWyi0z0YoYTCEu1vFHafS3BYdz0co1pXoBDOMCdnky3nesCnwwIKS7S3vNbThd20WJEEV/bbZFCPVZu/0GOvPaEp3v0eqQJ41qEyKey+RPbaR/ef7vEP6z+rB0Us6KXmAgAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTmFalse ::</span> <span class="dt">Monad</span> m
             <span class="ot">=&gt;</span> <span class="dt">Term</span>
             <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m <span class="dt">Type</span>)
inferTmFalse <span class="dt">TmFalse</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span>
  return <span class="dt">TyBool</span>
inferTmFalse _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p><img width="139" alt=" \prftree[r]{T-True} {\text{true} \colon \text{Bool}} " height="22" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARcAAAAtCAQAAAAuTOcgAAAEVUlEQVR4nO1cybWrMAx1K1TiRqiDMtIEPaQFd0ADrFmyYZF8D5B4kMwQOYT3db15MYrsE914kO6LEIzykEJtam1hH4xLoBFP3SbRvYL6sD396/VgXw+FfTAuAaXDeA96XGh9SE2FXKgpfDAuAaXXhBBpqIW4ibGwD8YloHQYQ0ChFnp7KeuDcQn0oo564FDnNhIKH4xLIA0hHOpeVEV9MC6BraFW+v5T0gfjooBDTeOjEa29WEuxZGvauf8WZWbSngWtPlgPujkvjJNRki6Dvh2ZJ40+7ZgTz3IFH5LMzGIZrly17u1nmpj3cuLvdJSky/LspoNu8LDJPAeVkCPuqbX9ED2P72SML6M0XUyQu/kUYzac2uvP02W069Ib0uaSGafiG3SBgrxGlxZ4nyFQfIlnfBXfoEuP9Ofo0gPv65Pygz0GcaNp6sNQb8UaXaB5rNHlMW9ifutSXw03srZl4cZD7Z74bb+P43R5AnQxja/TpwIPtUpWq/0+PqPLltWR8VX86mY02tWF8WP4VbqYV6kEouLN6FycRZd7Qpc+6JH2sBuT486Z3XNxFl2aiC5Gfxf2tMl2VOn15s9UuVv0OpsKiijgvD/EJ7oSF6Qkm0HoY7D5EyjIo7d6VNrupl8/gvUklHkamz+UpJP6G6PmUpl/BbzbfMHjo5BAMJ7HZEnfiviS/DxwF1nzEfbH85S6Z7IyB2ULkM3L8p36b4QpPior+ExlWSuQ4vcVFApcmOs57VRitCur1qSXH6qQvIo8mm9pLnATh+nijnb0mYSr06Uobhemi0trU8udmS4ZqEvTxd0faA9rTBcUlf5uMl3S0ZguILAb/G8Bo0sl3L+K0o/GdEkg5zC8L6jLTR6TD9MKiCtvxDwwurj+NP9Sz6W8Ds3N5CyYLgBcAmyy384l+bUs6ph8mFZAPIIVDAgwXVrbG3uu9LjjnByQ9u94q1qzYLqgwDcjTD5MJSCuRF7vEfv3LaX21tl1MV63TEo7TGp3ei71LgumCwqcLph8mE5AvP3cpOb8it/MOndP6NInJTRzmJ88eqxbMF1Q5OkCHyK/LyCGNyNpvfqzb8DtrfOqJOsWTJcM8nSB5MNkAuKds4RvRlNQBujAooBP/HULpksGebrgTwgExDtnCZ9y3HF3IeIEjuLKbNVGC6ZLBiXoQi8gxukSZl7gClIj3hXZdQumSwal6EKb+sPpshT0q8zITBcyhKSIL7/H6EIvIF6ny3vkdM7tLgumSwYl6EIvIMbpIoPNCA6037tuwXTJ4Ahd6ATEW4VZOF26YHuRwZF1gVlRbpstmC4ZtN5HI4MtBKcLlYD40yLAsonkSd5Ec9lmwXQBUXkrQfhDVrh8mEZAvKcI0ItUplC/VpZwjmGFypUj9ll0dnv7M+p4WtT6o5nmxPqCvHyYSkC8JRejorn4zfzGNeS30eMO88gTWNzELcIRfl/FfArqA1mRogLij+HP7qjFf4d/5UqNCHyVmFMAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTmTrue ::</span> <span class="dt">Monad</span> m
            <span class="ot">=&gt;</span> <span class="dt">Term</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m <span class="dt">Type</span>)
inferTmTrue <span class="dt">TmTrue</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span>
  return <span class="dt">TyBool</span>
inferTmTrue _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>Once we start working with terms that contain other terms, we need to pass in the combined inference rule and use that to check the sub-terms have the expected type:</p>
<p><img width="124" alt=" \prftree[r]{T-Succ} {\text{t} \colon \text{Nat}} {\text{S t} \colon \text{Nat}} " height="33" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPkAAABDCAQAAAD0F2sIAAAF1ElEQVR4nO2cy8GrIBCFbYVKbMQ6LONvwh5swQ7SQNYus3GRXBjU8BgGFMjrzufqD17C9cjwmpymeT9TM6/XpemcslaWmhfzE3RN34xS8Ie8lkZYZaIZpNB3KJmavze1kDFopVxlmGQfV6JjPbmXogvkc4pyLWMs+mLBdpJ1XUF0TKr5cH3lWsZY/BWVvF1DuN+jj0termWMRbkp1QS9ewwE9+OS82SvCkL2yrKSN+s0zp25H5W8ZMsYgykw3TpXl5ZcB/ebU3pU8pItY1ZaeKwPOc/u1wubU4vA5z7TPm3DgrsveQsLO7WWH061jDnIAI97gcnWtpHiBmPFDemxOJMxU/eDuyv5IGf3uryX9d+Me1NbxpwiFj4FSPdIrOspuR/cbclbKXhj3e2u2zmwVyL+YNMf/WStx93gPjv3PiyR1SbOePJ7mUPUmL5t2MHdl/whe7f5t38HS16BmpJ3IOsW3G1BhbPfzpK/jJqSb31Z148v0gQcyEwQEVjyl1BXcj3f1wHcl1ztyN/lKP4n4wH38pdRW3Id3JWYbmC/wjeL/d+y5C9iImbVx+vCTtB0cB+dumfYaLHvoiTPaxljUF9yHdzvVt09vAbmOvwp+WR8wpJXIOXBpiYqhCR/BnfzW/0+PVttYMkrMRgPv7VC7Ub6hqu/V77hSjzBZqrJ7Ekeb9m7aWH3vzP+/oqTAAEbo3pLBOul6RuuA4TvUG7bYkmut2OfL4hKklwg1It9IzbWsjO4qZehK/TqPungFOACy8tlX4Z+SeKWetgLkX16SZg5z+uL8SBy3+zQ3MGMXS3QRjgvU5/cYcTvjHvolh2nXxMyL7u4d/jkuv89e4MQxmBtD6ttpZv8n+AJYB9KBylMr0asB6NmO1zKtmzydvJnL4a1TkTy6ZDXeoCX54sk/1+YvDmBL7nKuaPnLlc0W/fKkn8ifh49JnkjJaXAA3/Hkn8iVyQjD5OcCux9cKxfWPLPw5cKl/xKLLd656T/yYUl/zxSJacXhaFVycjpWt8ALjlN+GdYGz387MJc3/ufbHTNtCZ9+nsaVBlzkjOSt+tq/i4HgAFdQs7e+n5ej5H988T7+hqobSJzQKHKmAzOSK63Yp7Xgo7i1DmCRsjX4G4NBsO+iKTKmCzOSa43XB/W5fbCuORuRsBktIUqY7I4K7mihZ63GKKbxCRv93whs/wRLWMyyZF8Q/3qRo/u5uQsJrl/mihkPX20zGo8X+4VPxErIbmi836qEZPcT/BsksoMer68K34gE5bcHau3u0LeFoNT0wskZ84QlnzyYoYm7G1hn6Wx5B/K8cDunvzbdaVLfiVkpcqYTM5IHjI6mg8Fdncg0AgYjKgyJpMzkoc2W+1l2uhJbvddnejlbqQOMOWkyphMzkl+Rw5QxsY+L3cPWVtYwZuf/DVuIqnYy6myZL40H7Mq7bqRMsZv3VFSqg0Y+990iLPNzdhOUYL9wctiBucB6hL7PRfjpaHKEnhnPuZnmn26C7BwoqaLHssFyK5OxtQZGZ4S2q5Pu4dDka7p9+/pjdrmPaXT9cqgyiK8Nx/z18w+u31EbSE7d5ZyjsGJlRlbRWCvwI2/qWVEE3PyMUuZapY2+2S7T4K8fMxSppqlzT7Z7pMgLx+zlKlmabNPtvsMkpuPWWpSVdrsk+0+g+TlY5Yz1Sxr9sl2nyQ5+ZjlnBzKmn2yxwRJPB8TJ8VUs57ZJ9t9ZhDPx8RIM9WsZfbJdp+ZpORj4tDhs5bZJ9t9FiCej4kTe7B1zD7Z7rMQdD4mTvnp2wZl9sl2n4XB8zFx6klOmX2y3WcF/HxMnHqSp5h9st3nKVLzMXFqSk6bfbLd52lS8zFx6koeMvtku88sUvMxccrZ7R0x+2S7zyxS8zFxakuOmX2y3WcmqfmYOPEHW97sk+0+M0nNx8SJmWrWMPv8FbvPt5Gej4lBm2rWMft8n93nj5Cej4lDm2rWMft8l93nj3AsHzNUx/9h9/k1/AMHxRVUeMAGzQAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTmSucc ::</span> <span class="dt">MonadError</span> <span class="dt">TypeError</span> m
            <span class="ot">=&gt;</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> m <span class="dt">Type</span>)
            <span class="ot">-&gt;</span> <span class="dt">Term</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m <span class="dt">Type</span>)
inferTmSucc infer (<span class="dt">TmSucc</span> tm) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="kw">do</span>
  ty <span class="ot">&lt;-</span> infer tm
  expect ty <span class="dt">TyNat</span>
  return <span class="dt">TyNat</span>
inferTmSucc _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p><img width="148" alt=" \prftree[r]{T-Pred} {\text{t} \colon \text{Nat}} {\text{pred t} \colon \text{Nat}} " height="36" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTmPred ::</span> <span class="dt">MonadError</span> <span class="dt">TypeError</span> m
            <span class="ot">=&gt;</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> m <span class="dt">Type</span>)
            <span class="ot">-&gt;</span> <span class="dt">Term</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m <span class="dt">Type</span>)
inferTmPred infer (<span class="dt">TmPred</span> tm) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="kw">do</span>
  ty <span class="ot">&lt;-</span> infer tm
  expect ty <span class="dt">TyNat</span>
  return <span class="dt">TyNat</span>
inferTmPred _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>Finally, when inferring the type of an <code>if</code> expressions, we need to check that the test sub-term has type <code>Bool</code> and that the two branches have the same type:</p>
<p><img width="199" alt=" \prftree[r]{T-If} {t_1 \colon \text{Bool}} {t_2 \colon \text{T}} {t_3 \colon \text{T}} {\text{if $t_1$ then $t_2$ else $t_3$} \colon \text{T}} " height="36" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-3px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTmIf ::</span> <span class="dt">MonadError</span> <span class="dt">TypeError</span> m
          <span class="ot">=&gt;</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> m <span class="dt">Type</span>)
          <span class="ot">-&gt;</span> <span class="dt">Term</span>
          <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m <span class="dt">Type</span>)
inferTmIf infer (<span class="dt">TmIf</span> tm1 tm2 tm3) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="kw">do</span>
  ty1 <span class="ot">&lt;-</span> infer tm1
  expect ty1 <span class="dt">TyBool</span>
  ty2 <span class="ot">&lt;-</span> infer tm2
  ty3 <span class="ot">&lt;-</span> infer tm3
  expectEq ty2 ty3
  return ty3
inferTmIf _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>Now we pull our usual stunt.</p>
<p>We build the list of rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTermRules ::</span> <span class="dt">MonadError</span> <span class="dt">TypeError</span> m
               <span class="ot">=&gt;</span> [<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m <span class="dt">Type</span>)]
inferTermRules <span class="fu">=</span>
  [ inferTmZero
  , inferTmSucc inferTerm
  , inferTmPred inferTerm
  , inferTmFalse
  , inferTmTrue
  , inferTmIf inferTerm
  ]</code></pre></div>
<p>and use <code>Alternative</code> to combine those rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTerm ::</span> <span class="dt">MonadError</span> <span class="dt">TypeError</span> m
          <span class="ot">=&gt;</span> <span class="dt">Term</span>
          <span class="ot">-&gt;</span> m <span class="dt">Type</span>
inferTerm tm <span class="fu">=</span>
  fromMaybe (throwError <span class="dt">NoMatchingTypeRule</span>) <span class="fu">.</span>
  asum <span class="fu">.</span>
  fmap (<span class="fu">$</span> tm) <span class="fu">$</span>
  inferTermRules</code></pre></div>
<p>We’re still not running with a concrete <code>Monad</code>, but we can deal with that using <code>runExcept</code>.</p>
<p>We’ll give a different name here, because <code>runInfer</code> is likely to change as we push on with this series:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runInfer ::</span> <span class="dt">Except</span> e a
         <span class="ot">-&gt;</span> <span class="dt">Either</span> e a
runInfer <span class="fu">=</span> runExcept</code></pre></div>
<p>We can now test our new function out:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> runInfer <span class="fu">.</span> inferTerm <span class="fu">$</span> <span class="dt">TmSucc</span> (<span class="dt">TmSucc</span> (<span class="dt">TmPred</span> <span class="dt">TmZero</span>))
<span class="dt">Right</span> <span class="dt">TyNat</span>

<span class="fu">&gt;</span> runInfer <span class="fu">.</span> inferTerm <span class="fu">$</span> <span class="dt">TmIf</span> <span class="dt">TmZero</span> <span class="dt">TmFalse</span> <span class="dt">TmTrue</span>
<span class="dt">Left</span> (<span class="dt">Unexpected</span> <span class="dt">TyNat</span> <span class="dt">TyBool</span>)</code></pre></div>
<h1 id="adding-iszero">Adding <code>isZero</code></h1>
<p>At the moment we can come up with terms that will turn a <code>Bool</code> into <code>Nat</code>, like we do with <code>TmIf TmTrue TmZero (TmSucc TmZero)</code>.</p>
<p>It would be nice to be able to turn a <code>Nat</code> into a <code>Bool</code>. We’re about to take a look at the properties of type systems, so anything we can add that will exercise the type system a little more will help us iron out any kinks.</p>
<p>With that in mind, we add another term to our language:</p>
<p><img width="88" alt=" \begin{aligned} t =&amp; \ \ldots \\   |&amp; \ \text{isZero t} \\    &amp; \ \ldots \end{aligned} " height="58" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALAAAAB1CAQAAABEm6PSAAAEXklEQVR4nO2cy6GrIBCGbYVKbMQ6LCNN2IMt0IENuHbJxoW5vDSgI5DkKNH7f2zOER/jLw4DcSiKMI+iL1hkH/AFU/EsqtxG3JdKyjvlNuLOtFLgPrcRd6aXAre5jbgzIzzwEbCi1uUh5X3avyHzH1IWgy6q/Y72b57bqDsCD3wwKTFwpfdKK49TrL4MqTFwnVwwIvRADHww8MAHg1mIQ8EsxMGkeuA5Zk4piCIcfA+8LzWTe/HEgijCwZ2FqLOM4+oP62K1P4IaGMwMGdqekNcXH9TFan8GsQjcZfCdzI793q2L1f4QagjMiyZb19RJkfYcU6guVvtDmElLAAAAAAAAAAAAAAAAAAAAAAAAAFycoShzm3BvnvjC4lj+WuAm+Jls96fXugQpApfFWEyJH2px+wWakH+1TppNq7cO35p7PVIE5m+Iw/X399tzCr09n78vc7nCtBasskKapPNxMn/EtN+cH/7l+ZK6SPXBLLntccLPmgeU98vgx28LnE5P+OrBpq7nhN9F4O0394/s7kG9gdNdBF7fBtPuYcqcZsPzPeK4wJXuIPiqk6u1t+XaJbCA8TyYbN7Ic5glGV4+vpZbud1SEldWFnEbVaeEjqW1ocuTmR0XmFsf6oZpvTR3NrOV7XMvhKsDAV4lu73eCsudKGXQId1TLzXSazHdtDUmtwlrc6n/Due8Npv1NYZzs2TTXAT3ZOKriIDvCrwf/Varx8K9dj7o/0wO4OQkXjJ5RuG1wE7WxwX7aReh8AUWK2PZjsA80L2J1ZVL3cbcIztbrwKsWUKVhOk/LuXjx+hLfzGBt7dE5ZuWdshM0XhyGoQzROFEvXE42/N1CWsPXEzgTt9+44hMOQHjuenXtyfyrd0UYU7mY3e6XVO2bR/Gdp8LCVwui9WMUoaGfEEb0j009lFMXq9uiptFRwsykltNRxp2EhcTWEncOSv+jJt2aqLfrW+cz/EkBFZlfhNoQWiPXieMEy8nsKHWcfCTGEh0O9GvK3Dohv9zgX1TS909ud2MuWWq45sXEhGkN/WvtxVEkFuNMwrjn+/UWelPBF57vNKTk2lfSUW/1SIEJ+MBFnER9HtEb93ucymB14NXNzI20S8VOPXLOUw3uX4E7XJeWuCS7M5EYCju2nQpgdcmTos01W7023rHNRsnwZwx2p7P3G6vI87mdbXXwz31l8E0gTst2nz7ygG4RraOoFT0W+sZgfWsxHqOwZ0jGLTToUIv7r0/ZsAdn7xhzhvDz52ZjgvsL8I4H9NIAVr9Y+bgTPxUq73XxW/5tZ7Y4Xperl/kDR1hjhJ6/k0dNSb+kKUsG2Xh50+8fzIf/Fox6PvJv9KLf9876t1ZseqDK31N7p9ybg8EPhgIfDAQ+GAg8MFA4IOBwAeDdYgBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADyEEqbCafUIOEmAbGzHkSsLlYLNMxZ1uCdulgtWHDXN3unLlZ7Ov8ARIQGC4BgdgYAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-24px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term</span> <span class="fu">=</span>
  <span class="fu">...</span>
  <span class="fu">|</span> <span class="dt">TmIsZero</span> <span class="dt">Term</span>
  <span class="fu">...</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>This also brings us up to parity with one of the example languages in TAPL.</p>
<p>The semantics of <code>isZero</code> are described by three rules.</p>
<p>There are two reduction rules - one for the case where the argument is zero:</p>
<p><img width="233" alt=" \prftree[r]{E-IsZeroZero} {\text{isZero O} \longrightarrow \text{true}} " height="22" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eIsZeroZero ::</span> <span class="dt">Term</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>
eIsZeroZero (<span class="dt">TmIsZero</span> <span class="dt">TmZero</span>) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="dt">TmTrue</span>
eIsZeroZero _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>and one for the case where the argument is the successor of something:</p>
<p><img width="263" alt=" \prftree[r]{E-IsZeroSucc} {\text{isZero (S $t_1$)} \longrightarrow \text{false}} " height="27" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-5px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eIsZeroSucc ::</span> <span class="dt">Term</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>
eIsZeroSucc (<span class="dt">TmIsZero</span> (<span class="dt">TmSucc</span> tm)) <span class="fu">=</span>
  <span class="dt">TmFalse</span> <span class="fu">&lt;$</span> value tm
eIsZeroSucc _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>There is one congruence rule, which at this point should be fairly predictable:</p>
<p><img width="265" alt=" \prftree[r]{E-IsZeroSucc} {t_1 \longrightarrow t_2} {\text{isZero $t_1$} \longrightarrow \text{isZero $t_2$}} " height="34" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-3px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eIsZero ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>)
        <span class="ot">-&gt;</span> <span class="dt">Term</span>
        <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>
eIsZero step (<span class="dt">TmIsZero</span> tm) <span class="fu">=</span> <span class="kw">do</span>
  tm' <span class="ot">&lt;-</span> step tm
  return <span class="fu">$</span> <span class="dt">TmIsZero</span> tm'
eIsZero _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>The typing rule ensures that is all we have to worry about:</p>
<p><img width="176" alt=" \prftree[r]{T-IsZero} {t \colon \text{Nat}} {\text{isZero t} \colon \text{Bool}} " height="33" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-1px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inferTmIsZero ::</span> <span class="dt">MonadError</span> <span class="dt">TypeError</span> m
              <span class="ot">=&gt;</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> m <span class="dt">Type</span>)
              <span class="ot">-&gt;</span> <span class="dt">Term</span>
              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m <span class="dt">Type</span>)
inferTmIsZero infer (<span class="dt">TmIsZero</span> tm) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="kw">do</span>
  ty <span class="ot">&lt;-</span> infer tm
  expect ty <span class="dt">TyNat</span>
  return <span class="dt">TyBool</span>
inferTmIsZero _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>There’s nothing new to the parsing and pretty printing for <code>isZero</code>, although it could be a nice typing exercise if you wanted to try adding it yourself.</p>
<h1 id="updating-the-repl">Updating the REPL</h1>
<p>Now that we have the ability to type-check expressions, we’re going to update the REPL.</p>
<p>It used to be that when you entered an expression into the REPL, it showed the term before and after the evaluation step in the result:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">if</span> isZero <span class="dt">O</span> <span class="kw">then</span> <span class="dt">O</span> <span class="kw">else</span> <span class="dt">S</span> <span class="dt">O</span>
<span class="kw">if</span> isZero <span class="dt">O</span> <span class="kw">then</span> <span class="dt">O</span> <span class="kw">else</span> <span class="dt">S</span> <span class="dt">O</span> <span class="fu">==&gt;</span> <span class="dt">O</span></code></pre></div>
<p>We’re going to change that so that it shows the result of evaluation the term along with the type of the term:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">if</span> isZero <span class="dt">O</span> <span class="kw">then</span> <span class="dt">O</span> <span class="kw">else</span> <span class="dt">S</span> <span class="dt">O</span>
<span class="dt">O</span> <span class="fu">:</span> <span class="dt">Nat</span></code></pre></div>
<p>or an error message if the type-checking failed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">if</span> <span class="dt">O</span> <span class="kw">then</span> <span class="dt">O</span> <span class="kw">else</span> <span class="dt">S</span> <span class="dt">O</span>
<span class="dt">Unexpected</span> <span class="kw">type</span><span class="fu">:</span>
  actual<span class="fu">:</span>   <span class="dt">Nat</span>
  expected<span class="fu">:</span> <span class="dt">Bool</span></code></pre></div>
<h2 id="pretty-printing-types">Pretty printing types</h2>
<p>The first thing we’ll need to do is write a pretty printer for types.</p>
<p>We’ve got really simple types at the moment, but we package them pretty printing into rules nonetheless:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTyNat ::</span> <span class="dt">Type</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTyNat <span class="dt">TyNat</span> <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> reservedConstructor <span class="st">&quot;Nat&quot;</span>
prettyTyNat _ <span class="fu">=</span>
  <span class="dt">Nothing</span>

<span class="ot">prettyTyBool ::</span> <span class="dt">Type</span>
             <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTyBool <span class="dt">TyBool</span> <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> reservedConstructor <span class="st">&quot;Bool&quot;</span>
prettyTyBool _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>and combine them as usual:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTypeRules ::</span> [<span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>]
prettyTypeRules <span class="fu">=</span>
  [ prettyTyNat
  , prettyTyBool
  ]

<span class="ot">prettyType ::</span> <span class="dt">Type</span>
           <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyType tm <span class="fu">=</span>
  fromMaybe (text <span class="st">&quot;???&quot;</span>) <span class="fu">.</span>
  asum <span class="fu">.</span>
  fmap (<span class="fu">$</span> tm) <span class="fu">$</span>
  prettyTypeRules</code></pre></div>
<h2 id="pretty-printing-errors">Pretty printing errors</h2>
<p>With pretty printers for the types, we can go on to write pretty printers for the type errors.</p>
<p>We can do something relatively simple here:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTeUnexpected ::</span> <span class="dt">TypeError</span>
                   <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTeUnexpected (<span class="dt">Unexpected</span> ac ex) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">.</span> hang <span class="dv">2</span> <span class="fu">$</span>
    text <span class="st">&quot;Unexpected type:&quot;</span> <span class="fu">PP.&lt;$&gt;</span>
    text <span class="st">&quot;actual:&quot;</span> <span class="fu">&lt;+&gt;</span> prettyType ac <span class="fu">PP.&lt;$&gt;</span>
    text <span class="st">&quot;expected:&quot;</span> <span class="fu">&lt;+&gt;</span> prettyType ex
prettyTeUnexpected _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>which will give us output that looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Unexpected</span> <span class="kw">type</span><span class="fu">:</span>
  actual<span class="fu">:</span> <span class="dt">Nat</span>
  expected<span class="fu">:</span> <span class="dt">Bool</span></code></pre></div>
<p>We’re really after something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Unexpected</span> <span class="kw">type</span><span class="fu">:</span>
  actual<span class="fu">:</span>   <span class="dt">Nat</span>
  expected<span class="fu">:</span> <span class="dt">Bool</span></code></pre></div>
<p>Why? Because if I’m going to use a pretty printing library, I want to spend a little time to try to make things pretty!</p>
<p>We’ll put together a little helper function to take care of this.</p>
<p>The idea is that we have a list of pairs, where the first element of the pair is a label and the second element of the pair is the <code>Doc</code> we want to label. This will use <code>fill</code>, which adds whitespace on the right-hand side of some text until it has a certain length, and <code>vcat</code>, which vertically concatenates a list of documents.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tabulate ::</span> [(<span class="dt">String</span>, <span class="dt">Doc</span>)] <span class="ot">-&gt;</span> <span class="dt">Doc</span>
tabulate xs <span class="fu">=</span>
    vcat <span class="fu">.</span>
    fmap pad <span class="fu">$</span>
    xs
  <span class="kw">where</span>
    maxLength <span class="fu">=</span>
      maximum <span class="fu">.</span>
      fmap (length <span class="fu">.</span> fst) <span class="fu">$</span>
      xs
    pad (label, doc) <span class="fu">=</span>
      fill maxLength (text label) <span class="fu">&lt;+&gt;</span> doc</code></pre></div>
<p>We find the maximum length of all of the labels, and then use fill to pad out the label before appending the corresponding <code>Doc</code>. After that we use <code>vcat</code> to turn the whole thing into a single <code>Doc</code>.</p>
<p>Now we can have another go at our rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTeUnexpected ::</span> <span class="dt">TypeError</span>
                   <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTeUnexpected (<span class="dt">Unexpected</span> ac ex) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">.</span> hang <span class="dv">2</span> <span class="fu">$</span>
    text <span class="st">&quot;Unexpected type:&quot;</span> <span class="fu">PP.&lt;$&gt;</span>
    tabulate [
        (<span class="st">&quot;actual:&quot;</span>,   prettyType ac)
      , (<span class="st">&quot;expected:&quot;</span>, prettyType ex)
      ]
prettyTeUnexpected _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTeExpectedEq ::</span> <span class="dt">TypeError</span>
                   <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTeExpectedEq (<span class="dt">ExpectedEq</span> t1 t2) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">.</span> hang <span class="dv">2</span> <span class="fu">$</span>
    text <span class="st">&quot;Expected these types to be equal:&quot;</span> <span class="fu">PP.&lt;$&gt;</span>
    tabulate [
        (<span class="st">&quot;type 1:&quot;</span>, prettyType t1)
      , (<span class="st">&quot;type 2:&quot;</span>, prettyType t2)
      ]
prettyTeExpectedEq _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTeNoMatchingTypeRule ::</span> <span class="dt">TypeError</span>
                    <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTeNoMatchingTypeRule <span class="dt">NoMatchingTypeRule</span> <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> text <span class="st">&quot;No matching type rule&quot;</span>
prettyTeNoMatchingTypeRule _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>Which get the usual treatment to create our pretty printing function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTypeErrorRules ::</span> [<span class="dt">TypeError</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>]
prettyTypeErrorRules <span class="fu">=</span> [
    prettyTeUnexpected
  , prettyTeExpectedEq
  , prettyTeNoMatchingTypeRule
  ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTypeError ::</span> <span class="dt">TypeError</span>
                <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyTypeError te <span class="fu">=</span>
  fromMaybe (text <span class="st">&quot;???&quot;</span>) <span class="fu">.</span>
  asum <span class="fu">.</span>
  fmap (<span class="fu">$</span> te) <span class="fu">$</span>
  prettyTypeErrorRules</code></pre></div>
<h2 id="the-change-to-the-repl">The change to the REPL</h2>
<p>The main loop of the REPL will remain unchanged, but the function at the heart of it will.</p>
<p>Previously we had this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseAndEval ::</span> <span class="dt">String</span>
             <span class="ot">-&gt;</span> <span class="dt">Doc</span>
parseAndEval s <span class="fu">=</span>
  <span class="kw">case</span> parseFromString parseTerm s <span class="kw">of</span>
    <span class="dt">Left</span> d <span class="ot">-&gt;</span> 
      d
    <span class="dt">Right</span> tm <span class="ot">-&gt;</span> 
      prettyTerm tm <span class="fu">&lt;+&gt;</span> text <span class="st">&quot;==&gt;&quot;</span> <span class="fu">&lt;+&gt;</span> prettyTerm (eval tm)</code></pre></div>
<p>and now we want to type-check the term after we have parsed it but before we evaluate it.</p>
<p>Between <code>inferTerm</code>, <code>prettyTypeError</code> and <code>prettyType</code>, we have the pieces we need to make this happen:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseAndEval ::</span> <span class="dt">String</span>
             <span class="ot">-&gt;</span> <span class="dt">Doc</span>
parseAndEval s <span class="fu">=</span>
  <span class="kw">case</span> parseFromString parseTerm s <span class="kw">of</span>
    <span class="dt">Left</span> d <span class="ot">-&gt;</span> 
      d
    <span class="dt">Right</span> tm <span class="ot">-&gt;</span> 
      <span class="kw">case</span> runInfer <span class="fu">.</span> inferTerm <span class="fu">$</span> tm <span class="kw">of</span>
        <span class="dt">Left</span> e <span class="ot">-&gt;</span> 
          prettyTypeError e
        <span class="dt">Right</span> ty <span class="ot">-&gt;</span>
          prettyTerm (eval tm) <span class="fu">&lt;+&gt;</span> text <span class="st">&quot;:&quot;</span> <span class="fu">&lt;+&gt;</span> prettyType ty</code></pre></div>
<h1 id="properties-of-type-systems">Properties of type systems</h1>
<p>The main property we are after here is type safety.</p>
<p>A lot of thought went into the definition that we use for type safety, which is:</p>
<blockquote>
<p>Well typed terms do not get stuck</p>
</blockquote>
<p>This is usually demonstrated by showing that two other properties hold: progress and preservation.</p>
<ul>
<li><p>Progress</p>
<p>Every well-typed term is either a value, or can take a small step.</p></li>
<li><p>Preservation</p>
<p>For every well-typed term that can take a small step, the type of the term is the same before and after the step.</p></li>
</ul>
<p>This is enough to show that well-typed terms do not get stuck.</p>
<p>Imagine we have an arbitrary well-typed term.</p>
<p>If the term is a value, then it doesn’t get stuck.</p>
<p>If it isn’t in a value, then by the progress property we know it can take a step.</p>
<p>The result of taking a step will be another well-typed term, thanks to the preservation property, and so we’re back where we started except that we’re one step further along in the evaluation process.</p>
<h1 id="test-the-type-system">Test the type system</h1>
<p>This means we’re going to need to be able to generate well-typed terms.</p>
<p>If we think back to the start of this post, we also seem to need well-typed terms to make some of our existing tests pass.</p>
<p>We don’t have small step rules for the ill-typed terms, and so we need to update the properties that state:</p>
<ul>
<li>all terms which are normal forms are also values</li>
<li>all terms have exactly one small-step rule that applies to them</li>
</ul>
<p>to apply only to well-typed terms.</p>
<p>There’s a few things we’ll need to do in order to make this happen, starting with some new generators.</p>
<p><a href="nb/testing.html">Read on!</a></p>
<h1 id="exercises-for-the-adventurous">Exercises for the adventurous</h1>
<ul>
<li>Devise the semantics and write the implementation for an operation in <em>NB</em> that determines whether two natural numbers are equal.</li>
<li>Devise the semantics and write the implementation for operations that bridge <em>I</em> and <em>B</em>.</li>
<li>Include at least <code>==</code>, <code>/=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code>.
<ul>
<li>Use the precedence and associativity as reported by GHCi, via <code>:i (==)</code> etc…</li>
</ul></li>
<li>Write the <code>QuickCheck</code> to test progress and preservation hold for <em>NB</em>.</li>
</ul>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on July  1, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
