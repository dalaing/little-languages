<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Printing and Parsing *I*</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../../css/custom.css">
        <link rel="stylesheet" href="../../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Little Languages" href="../../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Little Languages" href="../../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../../">Little Languages</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../../drafts/i/text.html">Printing and Parsing *I*</a></h3>
    </div>
    <div class="panel-body">
        <h1 id="parsing-i">Parsing <em>I</em></h1>
<p>We haven’t had to parse any operators in our other languages, and I really don’t want to go through the ins and outs of coming up with a grammar and factoring it appropriately (because there are other sources that do it better), so it’s time to introduce some new tricks.</p>
<h2 id="expression-parsing-with-parsers">Expression parsing with <code>parsers</code></h2>
<p>As usual, <code>parsers</code> has something useful for this. In this case it’s contained in <code>Text.Parser.Expression</code>, and we’re going to do a bit of a lightning tour of what that offers.</p>
<p>This provides the data type <code>Assoc</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Assoc</span> <span class="fu">=</span>
    <span class="dt">AssocNone</span>
  <span class="fu">|</span> <span class="dt">AssocLeft</span>
  <span class="fu">|</span> <span class="dt">AssocRight</span></code></pre></div>
<p>the data type <code>Operator</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Operator</span> m a <span class="fu">=</span>
    <span class="dt">Infix</span> (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="dt">Assoc</span>
  <span class="fu">|</span> <span class="dt">Prefix</span> (m (a <span class="ot">-&gt;</span> a))
  <span class="fu">|</span> <span class="dt">Postfix</span> (m (a <span class="ot">-&gt;</span> a))</code></pre></div>
<p>the type synonym <code>OperatorTable</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">OperatorTable</span> m a <span class="fu">=</span> [[<span class="dt">Operator</span> m a]]</code></pre></div>
<p>and a function to convert an <code>OperatorTable</code> into a parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">buildExpressionParser ::</span> forall m a<span class="fu">.</span> (<span class="dt">Parsing</span> m, <span class="dt">Applicative</span> m) 
                      <span class="ot">=&gt;</span> <span class="dt">OperatorTable</span> m a 
                      <span class="ot">-&gt;</span> m a 
                      <span class="ot">-&gt;</span> m a </code></pre></div>
<p>The second argument to <code>buildExpressionParser</code> is a parser for everything-but-the-operators.</p>
<p>If we were using this directly, we could make an <code>Operator</code> for each of our operators, like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addOp ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
      <span class="ot">=&gt;</span> <span class="dt">Operator</span> m <span class="dt">Term</span>
addOp <span class="fu">=</span> <span class="dt">Infix</span> parseAdd <span class="dt">AssocLeft</span>
  <span class="kw">where</span>
    parseAdd <span class="fu">=</span> <span class="dt">TmAdd</span> <span class="fu">&lt;$</span> symbol <span class="st">&quot;+&quot;</span></code></pre></div>
<p>Once we had all of these defined, we’d put them into a list of lists, where the inner lists contained operators with the same precedence and the outer list is sorted in order of descending precedence:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">opTable ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
        <span class="ot">=&gt;</span> <span class="dt">OperatorTable</span> m <span class="dt">Term</span>
opTable <span class="fu">=</span> [
    [expOp]
  , [mulOp]
  , [addOp, subOp]
  ]</code></pre></div>
<p>Then all we’d need to do is to stitch everything together with <code>buildExpressionParser</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">parseTerm <span class="fu">=</span> 
    buildExpressionParser table parseNotAnOperator <span class="fu">&lt;?&gt;</span> <span class="st">&quot;term&quot;</span>
  <span class="kw">where</span>
    parseNotAnOperator <span class="fu">=</span> parseTmInt <span class="fu">&lt;|&gt;</span> parens parseTerm</code></pre></div>
<p>The expression parser doesn’t deal with parentheses, so we handle those in the other case. This will handle things like “(2 + 3) * 5” along with “(((5)))”. The latter has no operators in it, so the expression parser keeps falling through to <code>parseNotAnOperator</code> until the parentheses are dealt with.</p>
<h2 id="some-helpers-for-expression-parsers">Some helpers for expression parsers</h2>
<p>We’re going to shuffle some things around a little. Most of the payoff will be in being able to continue to work with a list of parsing rules that we can combine, but it’ll also keep the door open for adding user-defined operators with precedence annotations later on.</p>
<p>We start with a datatype capture associativity and precedence:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OperatorInfo</span> <span class="fu">=</span>
  <span class="dt">OperatorInfo</span> {
<span class="ot">    assoc      ::</span> <span class="dt">Assoc</span>
  ,<span class="ot"> precedence ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We then create a datatype for our parsing rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ParseRule</span> m t <span class="fu">=</span>
    <span class="dt">ParseRegular</span> (m t)
  <span class="fu">|</span> <span class="dt">ParseOp</span> <span class="dt">OperatorInfo</span> (m (t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t))</code></pre></div>
<p>The <code>ParseRegular</code> rules are for the all of the parsers that we’ve seen so far. The <code>ParseOp</code> rule combines the operator information with the parser for the operator, in the style needed by <code>Text.Parser.Expression</code>.</p>
<p>At some point we’re going to need to partition these two types of rules.</p>
<p>For regular parsers, we just gather the parsers into a <code>Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherRegular ::</span> <span class="dt">ParseRule</span> m t
              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m t)
gatherRegular (<span class="dt">ParseRegular</span> p) <span class="fu">=</span>
  <span class="dt">Just</span> p
gatherRegular _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>so that we can use <code>mapMaybe</code> over the rules to get hold of the regular rules on their own.</p>
<p>For the operator parsers, we build a singleton <code>OperatorTable</code>, and pad it out using the precedence information:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherOp ::</span> <span class="dt">ParseRule</span> m t
         <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">OperatorTable</span> m t)
gatherOp (<span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> assoc prec) p) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> [<span class="dt">Infix</span> p assoc] <span class="fu">:</span> replicate prec []
gatherOp _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>If we are using <code>gatherOp</code> to partition parsing rules, we’ll end up with a list of <code>OperatorTable</code>s, so we need a way to combine them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">combineTables ::</span> [<span class="dt">OperatorTable</span> m a]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
combineTables os <span class="fu">=</span>
    foldr (zipWith (<span class="fu">++</span>) <span class="fu">.</span> pad) (pad []) os
  <span class="kw">where</span>
    <span class="co">-- find the operator with the highest precedence</span>
    l <span class="fu">=</span> maximum <span class="fu">.</span> map length <span class="fu">$</span> os
    <span class="co">-- pad everything out to that precedence</span>
    pad ls <span class="fu">=</span> replicate (l <span class="fu">-</span> length ls) [] <span class="fu">++</span> ls</code></pre></div>
<p>We should stop and look a bit more closely at the above functions. The look like they’re doing what they’re meant to, but there are a few uses of <code>replicate</code>, <code>length</code> and <code>++</code> as well as the use of <code>maximum</code>.</p>
<p>The odds are good that we’re doing more work than we need to. I’m fine with that for a blog post that isn’t about performance, as long as the meaning and correctness of the function is clear - however that isn’t necessarily a zero-sum game.</p>
<p>Let’s have another go.</p>
<p>For a particular rule, the information in the <code>OperatorTable</code> is made up of the precedence, the associativity and the parser. The associativity and the parser get combined into an <code>Operator</code>, so we’ll do that in <code>gatherOp</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherOp ::</span> <span class="dt">ParseRule</span> m t
         <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Int</span>, <span class="dt">Operator</span> m t)
gatherOp (<span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> assoc prec) p) <span class="fu">=</span>
  <span class="dt">Just</span> (prec, <span class="dt">Infix</span> p assoc)
gatherOp _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>The <code>OperatorTable</code> is a list of list of <code>Operators</code>, where the <code>Operator</code>s in the inner lists all have the same precedence, and the outer list is sorted by descending order of the precedence.</p>
<p>Our function signature is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createTable ::</span> [(<span class="dt">Int</span>, <span class="dt">Operator</span> m a)]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
createTable os <span class="fu">=</span> 
  <span class="fu">...</span></code></pre></div>
<p>We can sort the our list by descending precendence by using <code>sortOn</code> from <code>Data.List</code>. We’ll also use <code>Down</code> from <code>Data.Ord</code> to get a descending sort.</p>
<p>So far we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (sortOn)
<span class="kw">import </span><span class="dt">Data.Ord</span>  (<span class="dt">Down</span>(..))

<span class="ot">createTable ::</span> [(<span class="dt">Int</span>, <span class="dt">Operator</span> m a)]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
createTable os <span class="fu">=</span> 
    <span class="fu">...</span> <span class="fu">.</span>
    sortOn (<span class="dt">Down</span> <span class="fu">.</span> fst) <span class="fu">$</span>
    os</code></pre></div>
<p>Before <code>sortOn</code> was added we would have had to have used <code>sortBy (comparing (Down . fst))</code>. The behaviour is the same, but <code>sortOn</code> is faster.</p>
<p>Now we need to group the entries with the same precedence.</p>
<p>We can use <code>groupBy</code> for this. It groups adjacent elements using a custom equality test. The adjacency is handled already because we just sorted the list, so we need to check for equal precedences. We can use <code>on</code> from <code>Data.Function</code> to help with this.</p>
<p>We’re almost there:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>     (sortBy, groupBy)
<span class="kw">import </span><span class="dt">Data.Ord</span>      (comparing, <span class="dt">Down</span>(..))
<span class="kw">import </span><span class="dt">Data.Function</span> (on)


<span class="ot">createTable ::</span> [(<span class="dt">Int</span>, <span class="dt">Operator</span> m a)]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
createTable os <span class="fu">=</span> 
    <span class="fu">...</span> <span class="fu">.</span>
    <span class="co">-- we now have [[(Int, Operator m a)]]</span>
    groupBy ((<span class="fu">==</span>) <span class="ot">`on`</span> fst) <span class="fu">.</span>
    sortBy (comparing (<span class="dt">Down</span> <span class="fu">.</span> fst)) <span class="fu">$</span>
    os</code></pre></div>
<p>We can now get rid of the precedence information and eta-reduce the function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createTable ::</span> [(<span class="dt">Int</span>, <span class="dt">Operator</span> m a)]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
createTable <span class="fu">=</span>
    fmap (fmap snd) <span class="fu">.</span>
    groupBy ((<span class="fu">==</span>) <span class="ot">`on`</span> fst) <span class="fu">.</span>
    sortBy (comparing (<span class="dt">Down</span> <span class="fu">.</span> fst))</code></pre></div>
<p>and we have a snazy little pipeline that doesn’t look to be doing too much in the way of redundant work.</p>
<p>If you haven’t had a browse through the <code>base</code> package in a while, it’s worth doing every now and then - there’s lots of neat stuff in there, and if it’s been a while you might spot some new functions (or new uses for old and familiar functions).</p>
<p>Now we can use all of the above to build a parser from the rules.</p>
<p>We gather the regular parsers together into a parser for non-operators, we gather the operator parsers into an <code>OperatorTable</code>, and we use <code>buildExpressionParser</code> to combine them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkParser ::</span> <span class="dt">TokenParsing</span> m
         <span class="ot">=&gt;</span> [<span class="dt">ParseRule</span> m t]
         <span class="ot">-&gt;</span> m t
mkParser rules <span class="fu">=</span>
  <span class="kw">let</span>
    parseRegular <span class="fu">=</span>
      (<span class="fu">&lt;|&gt;</span> parens parseTerm) <span class="fu">.</span>
      asum <span class="fu">.</span>
      mapMaybe gatherRegular <span class="fu">$</span>
      rules
    tables <span class="fu">=</span>
      createTable <span class="fu">.</span>
      mapMaybe gatherOp <span class="fu">$</span>
      rules
    parseTerm <span class="fu">=</span>
      buildExpressionParser tables parseRegular
  <span class="kw">in</span>
    parseTerm</code></pre></div>
<h2 id="putting-this-to-use-with-i">Putting this to use with <em>I</em></h2>
<p>We’re still working with a token parser, so we’ll define a style for operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">operatorStyle ::</span> <span class="dt">TokenParsing</span> m
              <span class="ot">=&gt;</span> <span class="dt">IdentifierStyle</span> m
operatorStyle <span class="fu">=</span>
    <span class="dt">IdentifierStyle</span> {
      _styleName              <span class="fu">=</span> <span class="st">&quot;operator&quot;</span>
    , _styleStart             <span class="fu">=</span> _styleLetter operatorStyle
    , _styleLetter            <span class="fu">=</span> oneOf <span class="st">&quot;:!#$%&amp;*+./&lt;=&gt;?@\\^|-~&quot;</span>
    , _styleReserved          <span class="fu">=</span> HS.fromList reservedOperators
    , _styleHighlight         <span class="fu">=</span> <span class="dt">Operator</span>
    , _styleReservedHighlight <span class="fu">=</span> <span class="dt">ReservedOperator</span>
    }
  <span class="kw">where</span>
    reservedOperators <span class="fu">=</span>
      [<span class="st">&quot;+&quot;</span>, <span class="st">&quot;-&quot;</span>, <span class="st">&quot;*&quot;</span>, <span class="st">&quot;^&quot;</span>]</code></pre></div>
<p>and our usual helper function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reservedOperator ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
                 <span class="ot">=&gt;</span> <span class="dt">String</span>
                 <span class="ot">-&gt;</span> m ()
reservedOperator <span class="fu">=</span>
  reserve operatorStyle</code></pre></div>
<p>From there, we define a parse for integer literals:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmInt ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmInt <span class="fu">=</span>
  (<span class="dt">TmInt</span> <span class="fu">.</span> fromInteger) <span class="fu">&lt;$&gt;</span> integer <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Int&quot;</span></code></pre></div>
<p>and parsers for all of operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmAdd ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>)
parseTmAdd <span class="fu">=</span>
  <span class="dt">TmAdd</span> <span class="fu">&lt;$</span> reservedOperator <span class="st">&quot;+&quot;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;+&quot;</span>

<span class="ot">parseTmSub ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>)
parseTmSub <span class="fu">=</span>
  <span class="dt">TmSub</span> <span class="fu">&lt;$</span> reservedOperator <span class="st">&quot;-&quot;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;-&quot;</span>

<span class="ot">parseTmMul ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>)
parseTmMul <span class="fu">=</span>
  <span class="dt">TmMul</span> <span class="fu">&lt;$</span> reservedOperator <span class="st">&quot;*&quot;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;*&quot;</span>

<span class="ot">parseTmExp ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>)
parseTmExp <span class="fu">=</span>
  <span class="dt">TmExp</span> <span class="fu">&lt;$</span> reservedOperator <span class="st">&quot;^&quot;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;^&quot;</span></code></pre></div>
<p>We package these up into our new <code>ParseRule</code> data structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTermRules ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
               <span class="ot">=&gt;</span> [<span class="dt">ParseRule</span> m <span class="dt">Term</span>]
parseTermRules <span class="fu">=</span>
  [ <span class="dt">ParseRegular</span> parseTmInt
  , <span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">6</span>) parseTmAdd
  , <span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">6</span>) parseTmSub
  , <span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">7</span>) parseTmMul
  , <span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocRight</span> <span class="dv">8</span>) parseTmExp
  ]</code></pre></div>
<p>with precedence and associativity information stolen from Haskell, and then we build our parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTerm ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
          <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTerm <span class="fu">=</span>
  mkParser parseTermRules <span class="fu">&lt;?&gt;</span> <span class="st">&quot;term&quot;</span></code></pre></div>
<p>We than have the option of smothering this in doctests.</p>
<p>I’d be a little more cautious with that recommendation if I thought there was going to be a high rate of churn for these examples. We won’t be expecting anything that parses now to stop parsing when we add orthogonal features to our language, so we won’t have to update these examples unless we’ve broken something.</p>
<p>With that in mind, lets go nuts:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | The parser for terms of the I language.</span>
<span class="fu">--</span>
<span class="co">-- This function is built from the contents of 'parseTermRules',</span>
<span class="co">-- with added support for parentheses.</span>
<span class="fu">--</span>
<span class="co">-- We can parse all of the simple forms of the terms:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3&quot;</span>
<span class="co">-- Success (TmInt 3)</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;2 + 5&quot;</span>
<span class="co">-- Success (TmAdd (TmInt 2) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;2 - 5&quot;</span>
<span class="co">-- Success (TmSub (TmInt 2) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;2 * 5&quot;</span>
<span class="co">-- Success (TmMul (TmInt 2) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;2 ^ 5&quot;</span>
<span class="co">-- Success (TmExp (TmInt 2) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- The left associative operators group to the left:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 - 2 + 5&quot;</span>
<span class="co">-- Success (TmAdd (TmSub (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- So brackets grouping things on the left are redundant:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;(3 - 2) + 5&quot;</span>
<span class="co">-- Success (TmAdd (TmSub (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- We need brackets if we want to group things on the right:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 - (2 + 5)&quot;</span>
<span class="co">-- Success (TmSub (TmInt 3) (TmAdd (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- The right associative operator groups to the right:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 ^ 2 ^ 5&quot;</span>
<span class="co">-- Success (TmExp (TmInt 3) (TmExp (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- So brackets grouping things on the right are redundant:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 ^ (2 ^ 5)&quot;</span>
<span class="co">-- Success (TmExp (TmInt 3) (TmExp (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- We need brackets if we want to group things on the left:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;(3 ^ 2) ^ 5&quot;</span>
<span class="co">-- Success (TmExp (TmExp (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- Multiplication binds more tightly than addition:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 * 2 + 5&quot;</span>
<span class="co">-- Success (TmAdd (TmMul (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 + 2 * 5&quot;</span>
<span class="co">-- Success (TmAdd (TmInt 3) (TmMul (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- So we need to use brackets multiply by the sum of two terms:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 * (2 + 5)&quot;</span>
<span class="co">-- Success (TmMul (TmInt 3) (TmAdd (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;(3 + 2) * 5&quot;</span>
<span class="co">-- Success (TmMul (TmAdd (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- Exponentiation binds more tightly than multiplication:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 ^ 2 * 5&quot;</span>
<span class="co">-- Success (TmMul (TmExp (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 * 2 ^ 5&quot;</span>
<span class="co">-- Success (TmMul (TmInt 3) (TmExp (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- So we need to use brackets if the exponent or the power is a product (or sum) of two terms:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 ^ (2 * 5)&quot;</span>
<span class="co">-- Success (TmExp (TmInt 3) (TmMul (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;(3 * 2) ^ 5&quot;</span>
<span class="co">-- Success (TmExp (TmMul (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- Nonsense is still rejected:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;potato&quot;</span>
<span class="co">-- Failure (interactive):1:1: error: expected: term</span>
<span class="co">-- potato&lt;EOF&gt;</span>
<span class="co">-- ^</span>
<span class="fu">--</span>
<span class="co">-- Even if you try to hide it in brackets:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;((potato))&quot;</span>
<span class="co">-- Failure (interactive):1:3: error: expected: operator</span>
<span class="co">-- ((potato))&lt;EOF&gt;</span>
<span class="co">--   ^</span>
<span class="ot">parseTerm ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
          <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTerm <span class="fu">=</span>
  mkParser parseTermRules <span class="fu">&lt;?&gt;</span> <span class="st">&quot;term&quot;</span></code></pre></div>
<h1 id="pretty-printing-i">Pretty Printing <em>I</em></h1>
<p>When it comes to pretty printing, we’d really like to be able to print out our terms - so that we can parse them back in again and get the original term - with the minimal number of brackets required</p>
<p>In fact, we should be able to flip our doc tests from the parse around and get the same results, except not including the results with redundant brackets or potatoes.</p>
<p>That’s what we’ll work towards.</p>
<h2 id="the-obligatory-helper-functions">The obligatory helper functions</h2>
<p>We’re going to create a data type for pretty printing rules, and it’s going to be similar to <code>ParseRule</code> from earlier:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PrettyRule</span> a <span class="fu">=</span>
    <span class="dt">PrettyRegular</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>)
  <span class="fu">|</span> <span class="dt">PrettyOp</span> <span class="dt">OperatorInfo</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, a)) (<span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>)</code></pre></div>
<p>The <code>PrettyRegular</code> variant is for everything other than operators, and it pretty prints <code>a</code> if the rule matches. The <code>PrettyOp</code> variant is for the operators, and includes the precedence and associativity information for the operator, a matching function tat returns the arguments to the operator, and a pretty printing function for the operator that requires that both arguments are pretty printed before it is used.</p>
<p>We’ll be dealing with the regular and operator pretty printers separately, so again we’ll need functions to partition the two types of rules.</p>
<p>For the regular pretty printing rules, we gather the pretty printers into a <code>Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherRegular ::</span> a
              <span class="ot">-&gt;</span> <span class="dt">PrettyRule</span> a
              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
gatherRegular t (<span class="dt">PrettyRegular</span> f) <span class="fu">=</span>
  f t
gatherRegular _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>so that we can use <code>mapMaybe</code> over the rules to get hold of the regular rules on their own.</p>
<p>The pretty printing rules for operators require a couple of helper functions.</p>
<p>We need a function that will search through the rules to find the <code>OperatorInfo</code> for a term, if it exists:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findOperatorInfo ::</span> [<span class="dt">PrettyRule</span> a]
                 <span class="ot">-&gt;</span> a
                 <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>
findOperatorInfo rules tm <span class="fu">=</span>
    asum <span class="fu">.</span>
    fmap (checkOperatorInfo tm) <span class="fu">$</span>
    rules
  <span class="kw">where</span>
    checkOperatorInfo t (<span class="dt">PrettyOp</span> info match _) <span class="fu">=</span>
      info <span class="fu">&lt;$</span> match t
    checkOperatorInfo _ _ <span class="fu">=</span>
      <span class="dt">Nothing</span></code></pre></div>
<p>We also need a function to determine if the argument to an operator needs parentheses.</p>
<p>First we add a data type to describe the arguments to an operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Argument</span> <span class="fu">=</span>
    <span class="dt">ArgumentLeft</span>
  <span class="fu">|</span> <span class="dt">ArgumentRight</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>and a function that works out if an argument is in the right position for it to associate:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argumentAssociates ::</span> <span class="dt">Argument</span>
                   <span class="ot">-&gt;</span> <span class="dt">Assoc</span>
                   <span class="ot">-&gt;</span> <span class="dt">Bool</span>
argumentAssociates <span class="dt">ArgumentLeft</span> <span class="dt">AssocLeft</span> <span class="fu">=</span>
  <span class="dt">True</span>
argumentAssociates <span class="dt">ArgumentRight</span> <span class="dt">AssocRight</span> <span class="fu">=</span>
  <span class="dt">True</span>
argumentAssociates _ _ <span class="fu">=</span>
  <span class="dt">False</span></code></pre></div>
<p>We could have used <code>Assoc</code> here and not written <code>Argument</code>, but new data types and functions are cheap and I didn’t want to leave the door open to passing in <code>AssocNone</code> by accident in the future and getting unexpected results.</p>
<p>Now we’re ready for the <code>needsParens</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">needsParens ::</span> <span class="dt">Argument</span>
            <span class="ot">-&gt;</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p>which takes the position of the argument to an operator, the operator information for the current operator and for the argument to the operator - the result of <code>findOperatorInfo</code> - and returns a Boolean indicating whether we should add parentheses or not.</p>
<p>If the argument wasn’t an operator, then we don’t need parentheses:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">needsParens _ _ <span class="dt">Nothing</span> <span class="fu">=</span>
  <span class="dt">False</span></code></pre></div>
<p>Otherwise, based on some playing around with doctests, we need parentheses if:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">needsParens arg info (<span class="dt">Just</span> argInfo) <span class="fu">=</span></code></pre></div>
<p>the operator has no associativity,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  assoc info <span class="fu">==</span> <span class="dt">AssocNone</span> <span class="fu">||</span></code></pre></div>
<p>the argument has a lower precedence than the current operator,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  precedence argInfo <span class="fu">&lt;</span> precedence info <span class="fu">||</span></code></pre></div>
<p>or if the argument has the same precedence as the current operator but the argument is not in the right position for it to associate</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  (precedence argInfo <span class="fu">==</span> precedence info <span class="fu">&amp;&amp;</span> not (argumentAssociates arg (assoc info)))</code></pre></div>
<p>Now we can prepare a pretty printer for operators.</p>
<p>Thanks to the laziness of Haskell, we can pass in the pretty printer for terms that we’re trying to build. We also pass in the result of <code>findOperatorInfo</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherOp ::</span> a
         <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Doc</span>)
         <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>)
         <span class="ot">-&gt;</span> <span class="dt">PrettyRule</span> a
         <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span></code></pre></div>
<p>If we’re given an operator, we check to see if it matches the rule we’re currently processing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gatherOp t pretty findInfo (<span class="dt">PrettyOp</span> i match printer) <span class="fu">=</span> <span class="kw">do</span>
  (t1, t2) <span class="ot">&lt;-</span> match t</code></pre></div>
<p>We then build little functions that will add parentheses if they are needed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">let</span> addParens b <span class="fu">=</span>
    <span class="kw">if</span> b <span class="kw">then</span> parens <span class="kw">else</span> id
  <span class="kw">let</span> p1 <span class="fu">=</span>
    addParens <span class="fu">.</span>
    needsParens <span class="dt">ArgumentLeft</span> i <span class="fu">.</span>
    findInfo <span class="fu">$</span>
    t1
  <span class="kw">let</span> p2 <span class="fu">=</span>
    addParens <span class="fu">.</span>
    needsParens <span class="dt">ArgumentRight</span> i <span class="fu">.</span>
    findInfo <span class="fu">$</span>
    t2</code></pre></div>
<p>and use them in conjunction with our overall pretty printer and the function that does the printing for the current operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  return <span class="fu">$</span> printer (p1 <span class="fu">.</span> pretty <span class="fu">$</span> t1) (p2 <span class="fu">.</span> pretty <span class="fu">$</span> t2)</code></pre></div>
<p>In the case whre we’re not given an operator, this function isn’t for us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gatherOp _ _ _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>We can use the above functions to build a pretty printing function from the pretty printing rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkPretty ::</span> [<span class="dt">PrettyRule</span> a]
         <span class="ot">-&gt;</span> a
         <span class="ot">-&gt;</span> <span class="dt">Doc</span>
mkPretty rules <span class="fu">=</span>
  <span class="kw">let</span>
    prettyRegular tm <span class="fu">=</span>
      asum <span class="fu">.</span>
      fmap (gatherRegular tm) <span class="fu">$</span>
      rules
    findInfo <span class="fu">=</span>
      findOperatorInfo rules
    prettyOp tm <span class="fu">=</span>
      asum <span class="fu">.</span>
      fmap (gatherOp tm prettyTerm findInfo) <span class="fu">$</span>
      rules
    prettyTerm tm <span class="fu">=</span>
      fromMaybe (text <span class="st">&quot;???&quot;</span>) <span class="fu">.</span>
      asum <span class="fu">.</span> 
      fmap (<span class="fu">$</span> tm) <span class="fu">$</span>
      [ prettyRegular , prettyOp ]
  <span class="kw">in</span>
    prettyTerm</code></pre></div>
<p>We’re building the pretty printer out of the pretty printers for regular terms and the pretty printer for operators. The pretty printer for regular terms shouldn’t be too surprising at this point.</p>
<p>The only trick with the pretty printer for the operators is that we assemble some functions and pass them in to <code>gatherOp</code>, so that we don’t need to pass in all the rules.</p>
<p>That should be all we need, so it’s time to press on.</p>
<h2 id="putting-this-to-use-with-i-1">Putting this to use with <em>I</em></h2>
<p>The heavy lifting has already been done, so we just need to put together the pieces for <em>I</em>.</p>
<p>We have one fairly usually looking pretty printer for <code>TmInt</code>, making use of the <code>int</code> helper from <code>ansi-wl-pprint</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Text.Parser.Token.Highlight</span>  (<span class="dt">Highlight</span> (..))
<span class="kw">import           </span><span class="dt">Text.Trifecta.Highlight</span>      (withHighlight)

<span class="ot">prettyTmInt ::</span> <span class="dt">Term</span>
             <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmInt (<span class="dt">TmInt</span> i) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> withHighlight <span class="dt">Number</span> (int i)
prettyTmInt _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>We’re stealing the highlighting from <code>trifecta</code> again, since the parser we use for <code>TmInt</code> adds the <code>Number</code> highlight under the hood.</p>
<p>We also have a pair of functions for each of our operators. They’re all pretty similar in this instance, so we’ll only look at the code associated with <code>TmAdd</code>.</p>
<p>One of the functions checks that we’re dealing with the operator we’re interested in, and returns the arguments to the operator if that’s the case:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- |</span>
<span class="ot">matchTmAdd ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Term</span>, <span class="dt">Term</span>)
matchTmAdd (<span class="dt">TmAdd</span> tm1 tm2) <span class="fu">=</span>
  <span class="dt">Just</span> (tm1, tm2)
matchTmAdd _ <span class="fu">=</span>
  <span class="dt">Nothing</span>

<span class="dt">The</span> other functions pretty prints the operator, given that the arguments to the operator have already been pretty pritned<span class="fu">:</span>
<span class="co">-- |</span>
<span class="ot">prettyTmAdd ::</span> <span class="dt">Doc</span>
            <span class="ot">-&gt;</span> <span class="dt">Doc</span>
            <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyTmAdd d1 d2 <span class="fu">=</span>
  d1 <span class="fu">&lt;+&gt;</span> reservedOperator <span class="st">&quot;+&quot;</span> <span class="fu">&lt;+&gt;</span> d2</code></pre></div>
<p>Once we have these functions, we can build a list of the pretty printing rules with the same operator information that we used for the parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTermRules ::</span> [<span class="dt">PrettyRule</span> <span class="dt">Term</span>]
prettyTermRules <span class="fu">=</span>
  [ <span class="dt">PrettyRegular</span> prettyTmInt
  , <span class="dt">PrettyOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">6</span>) matchTmAdd prettyTmAdd
  , <span class="dt">PrettyOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">6</span>) matchTmSub prettyTmSub
  , <span class="dt">PrettyOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">7</span>) matchTmMul prettyTmMul
  , <span class="dt">PrettyOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocRight</span> <span class="dv">8</span>) matchTmExp prettyTmExp
  ]</code></pre></div>
<p>Then we combine them all into a pretty printing function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTerm ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyTerm <span class="fu">=</span>
  mkPretty prettyTermRules</code></pre></div>
<p>As usual, we then spray doctests all over the place:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | The pretty printer for terms of the I language.</span>
<span class="fu">--</span>
<span class="co">-- This function is built from the contents of 'prettyTermRules'.</span>
<span class="co">-- It will print &quot;???&quot; if none of the rules apply - which should never happen.</span>
<span class="fu">--</span>
<span class="co">-- We can print all of the simple forms of the terms:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmInt 3)</span>
<span class="co">-- 3</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmInt 2) (TmInt 5))</span>
<span class="co">-- 2 + 5</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmSub (TmInt 2) (TmInt 5))</span>
<span class="co">-- 2 - 5</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmMul (TmInt 2) (TmInt 5))</span>
<span class="co">-- 2 * 5</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmExp (TmInt 2) (TmInt 5))</span>
<span class="co">-- 2 ^ 5</span>
<span class="fu">--</span>
<span class="co">-- The left associative operators don't need extra brackets when things are grouped to the left:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmAdd (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- 3 + 2 + 5</span>
<span class="fu">--</span>
<span class="co">-- But they do need brackets when the grouping branches to the right:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmInt 3) (TmAdd (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 + (2 + 5)</span>
<span class="fu">--</span>
<span class="co">-- The right associative operators don't need extra brackets when things are grouped to the right:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmExp (TmInt 3) (TmExp (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 ^ 2 ^ 5</span>
<span class="fu">--</span>
<span class="co">-- But they do need brackets when the grouping branches to the left:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmExp (TmExp (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- (3 ^ 2) ^ 5</span>
<span class="fu">--</span>
<span class="co">-- Multiplication binds more tightly than addition, so we don't want any brackets if we multiply and then add:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmMul (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- 3 * 2 + 5</span>
<span class="fu">--</span>
<span class="co">-- If we are adding and then multiplying, we'll want brackets:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmMul (TmInt 3) (TmAdd (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 * (2 + 5)</span>
<span class="fu">--</span>
<span class="co">-- This is true regardless of whether the addition is on the left or the right:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmInt 3) (TmMul (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 + 2 * 5</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmMul (TmAdd (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- (3 + 2) * 5</span>
<span class="fu">--</span>
<span class="co">-- Exponentiation binds more tightly than multiplication, so we don't want any brackets if exponentiate and then multiply:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmMul (TmExp (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- 3 ^ 2 * 5</span>
<span class="fu">--</span>
<span class="co">-- If we're multiplying and then exponentiating, we'll want brackets:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmExp (TmInt 3) (TmMul (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 ^ (2 * 5)</span>
<span class="ot">prettyTerm ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyTerm <span class="fu">=</span>
  mkPretty prettyTermRules</code></pre></div>
<p>As was the case with <a href="n.html"><em>N</em></a>, we don’t need to change the tests or the REPL, and they both continue to work.</p>
<p>It’s always worth having a play around in the REPL at this point, as something somewhere between a double-check and a victory lap:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">*</span> <span class="dv">5</span>
<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">==&gt;</span> <span class="dv">17</span>
<span class="fu">&gt;</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="dv">5</span>
(<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="dv">5</span> <span class="fu">==&gt;</span> <span class="dv">25</span>
<span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>
<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">==&gt;</span> <span class="dv">6</span>
<span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)
<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">==&gt;</span> <span class="dv">6</span></code></pre></div>
<h1 id="clutching-defeat-from-the-jaws-of-victory">Clutching defeat from the jaws of victory</h1>
<p>There’s a problem though - <code>needsParens</code> is incorrect.</p>
<p>A <a href="https://www.reddit.com/r/haskell/comments/4pdfkx/symbolic_computer_algebra_print_tree/">post on reddit</a> covered some similar ground, but with different code for the equivalent of <code>needsParens</code>.</p>
<p>Clearly it’s time for more <code>QuickCheck</code> in order to sort out what is going on. <a href="testing.html">Read on!</a></p>
<h1 id="exercises-for-the-adventurous">Exercises for the adventurous</h1>
<ul>
<li>Add the logic operators for conjunction and disjunction to <em>B</em> , using <code>&amp;&amp;</code> and <code>||</code> as infix operators with the same precedence and associativity as reported by GHCi with <code>:i (&amp;&amp;)</code> etc…
<ul>
<li>Make sure that the semantics cause them to short-circuit appropriately.</li>
</ul></li>
<li>Add the logic operator for negation to <em>B</em> using <code>~</code> as a prefix operator.</li>
</ul>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on May 27, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
