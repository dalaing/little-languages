<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Testing *I*</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../../css/custom.css">
        <link rel="stylesheet" href="../../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Little Languages" href="../../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Little Languages" href="../../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../../">Little Languages</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../../drafts/i/testing.html">Testing *I*</a></h3>
    </div>
    <div class="panel-body">
        <h1 id="cranking-up-the-testing">Cranking up the testing</h1>
<p>We’re going to build generators for a set of operators, and use that to generate arbitrary expressions. Once we have that, we’ll check that pretty printing the expression and parsing it back in returns the original expression.</p>
<p>We’ll also check that we either a parsing failure or a different expression if we delete any matched pair of parentheses from the pretty printed string in the middle of that round trip test.</p>
<p>That seems like it should make sure that we’re putting parentheses in the right places, and that we’re not adding any redundant parentheses.</p>
<h1 id="arbitrary-operators">Arbitrary operators</h1>
<p>To start with, we’ll need an <code>Arbitrary</code> instance for <code>OperatorInfo</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">OperatorInfo</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span>
    <span class="kw">let</span>
      genAssoc <span class="fu">=</span>
        elements [<span class="dt">AssocNone</span>, <span class="dt">AssocLeft</span>, <span class="dt">AssocRight</span>]
      genPrecedence <span class="fu">=</span>
        choose (<span class="dv">0</span>, <span class="dv">9</span>)
    <span class="kw">in</span>
      <span class="dt">OperatorInfo</span> <span class="fu">&lt;$&gt;</span> genAssoc <span class="fu">&lt;*&gt;</span> genPrecedence
  shrink (<span class="dt">OperatorInfo</span> a p) <span class="fu">=</span>
    fmap (<span class="dt">OperatorInfo</span> a) (shrink p)</code></pre></div>
<p>We’re going to create some code to generate a table of operators.</p>
<p>We’ll use a map from <code>String</code>s to <code>OperatorInfo</code>, wrapped in a <code>newtype</code> so that we can write an <code>Arbitrary</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>

<span class="kw">newtype</span> <span class="dt">OperatorMap</span> <span class="fu">=</span> <span class="dt">OperatorMap</span> {
<span class="ot">    getOperatorMap ::</span> <span class="dt">M.Map</span> <span class="dt">String</span> <span class="dt">OperatorInfo</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>The entries in the map are created from one of a number of single character names and a arbitrary <code>OperatorInfo</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genOperatorEntry ::</span> <span class="dt">Gen</span> (<span class="dt">String</span>, <span class="dt">OperatorInfo</span>)
genOperatorEntry <span class="fu">=</span>
  (,) <span class="fu">&lt;$&gt;</span> elements (map pure <span class="st">&quot;+=*&amp;^%$#@!&quot;</span>) <span class="fu">&lt;*&gt;</span> arbitrary</code></pre></div>
<p>The <code>OperatorMap</code> is built from a non-empty list of these operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genOperatorMap ::</span> <span class="dt">Gen</span> <span class="dt">OperatorMap</span>
genOperatorMap <span class="fu">=</span>
  fmap (<span class="dt">OperatorMap</span> <span class="fu">.</span> M.fromList) (listOf1 genOperatorEntry)</code></pre></div>
<p>For the shrinking, we don’t want to shrink the operator names in the entries:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkOperatorEntry ::</span> (<span class="dt">String</span>, <span class="dt">OperatorInfo</span>)
                    <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">OperatorInfo</span>)]
shrinkOperatorEntry (s, oi) <span class="fu">=</span>
  fmap (\oi' <span class="ot">-&gt;</span> (s, oi')) (shrink oi)</code></pre></div>
<p>and we can use the <code>shrinkList</code> helper to build the shrinking function for the whole map:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkOperatorMap ::</span> <span class="dt">OperatorMap</span>
                  <span class="ot">-&gt;</span> [<span class="dt">OperatorMap</span>]
shrinkOperatorMap (<span class="dt">OperatorMap</span> m) <span class="fu">=</span>
  fmap (<span class="dt">OperatorMap</span> <span class="fu">.</span> M.fromList) <span class="fu">.</span>
  filter (not <span class="fu">.</span> null) <span class="fu">.</span>
  shrinkList shrinkOperatorEntry <span class="fu">.</span>
  M.toList <span class="fu">$</span>
  m</code></pre></div>
<p>Now we have what we need for an <code>Arbitrary</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">OperatorMap</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span>
    genOperatorMap
  shrink <span class="fu">=</span>
    shrinkOperatorMap</code></pre></div>
<h1 id="arbitrary-expressions">Arbitrary expressions</h1>
<p>Thus armed, we create a generic expression type. We use the lowest-effort form of generics here: <code>String</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span>
    <span class="dt">Const</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Op</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We are going to need support for generation, pretty printing and parsing of <code>Expr</code>.</p>
<p>We can use the <code>OperatorMap</code> to generate these expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genExpr ::</span> <span class="dt">OperatorMap</span>
        <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Expr</span>
genExpr <span class="fu">=</span>
  sized <span class="fu">.</span>
  genExpr'

<span class="ot">genExpr' ::</span> <span class="dt">OperatorMap</span>
         <span class="ot">-&gt;</span> <span class="dt">Int</span>
         <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Expr</span>
genExpr' _ <span class="dv">0</span> <span class="fu">=</span>
    <span class="dt">Const</span> <span class="fu">&lt;$&gt;</span> arbitrary
genExpr' om<span class="fu">@</span>(<span class="dt">OperatorMap</span> m) s <span class="fu">=</span>
    oneof [
      <span class="dt">Const</span> <span class="fu">&lt;$&gt;</span> arbitrary
    , <span class="dt">Op</span> <span class="fu">&lt;$&gt;</span> elements (M.keys m) <span class="fu">&lt;*&gt;</span> child2 <span class="fu">&lt;*&gt;</span> child2
    ]
  <span class="kw">where</span>
    s2 <span class="fu">=</span> s <span class="ot">`div`</span> <span class="dv">2</span>
    child2 <span class="fu">=</span> genExpr' om s2</code></pre></div>
<p>and the shrinking function is straight-forward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkExpr ::</span> <span class="dt">Expr</span>
           <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]
shrinkExpr (<span class="dt">Const</span> _) <span class="fu">=</span>
  []
shrinkExpr (<span class="dt">Op</span> s e1 e2) <span class="fu">=</span>
  e1 <span class="fu">:</span>
  e2 <span class="fu">:</span>
  fmap (\e1' <span class="ot">-&gt;</span> <span class="dt">Op</span> s e1' e2) (shrinkExpr e1) <span class="fu">++</span>
  fmap (\e2' <span class="ot">-&gt;</span> <span class="dt">Op</span> s e1 e2') (shrinkExpr e2)</code></pre></div>
<h2 id="parsing-and-printing-expressions">Parsing and printing expressions</h2>
<p>The <code>OperatorMap</code> can be turned into a pretty printer fairly mechanically:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toPrettyRules ::</span> <span class="dt">OperatorMap</span>
              <span class="ot">-&gt;</span> [<span class="dt">PrettyRule</span> <span class="dt">Expr</span>]
toPrettyRules (<span class="dt">OperatorMap</span> m) <span class="fu">=</span>
    intRule <span class="fu">:</span> map convertEntry (M.toList m)
  <span class="kw">where</span>
    intRule <span class="fu">=</span>
      <span class="dt">PrettyRegular</span> prettyInt
    prettyInt (<span class="dt">Const</span> i) <span class="fu">=</span>
      <span class="dt">Just</span> <span class="fu">$</span> int i
    prettyInt _ <span class="fu">=</span>
      <span class="dt">Nothing</span>
    convertEntry (s, oi) <span class="fu">=</span>
      <span class="dt">PrettyOp</span> oi (matchOp s) (prettyOp s)
    matchOp s (<span class="dt">Op</span> t e1 e2)
      <span class="fu">|</span> s <span class="fu">==</span> t <span class="fu">=</span> <span class="dt">Just</span> (e1, e2)
      <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>
    matchOp _ _ <span class="fu">=</span>
      <span class="dt">Nothing</span>
    prettyOp s d1 d2 <span class="fu">=</span>
      d1 <span class="fu">&lt;+&gt;</span> text s <span class="fu">&lt;+&gt;</span> d2

<span class="ot">mkExprPretty ::</span> <span class="dt">OperatorMap</span>
             <span class="ot">-&gt;</span> <span class="dt">Expr</span>
             <span class="ot">-&gt;</span> <span class="dt">Doc</span>
mkExprPretty m <span class="fu">=</span>
  mkPretty (toPrettyRules m)</code></pre></div>
<p>and the same is true with the parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toParserRules ::</span> <span class="dt">TokenParsing</span> m
              <span class="ot">=&gt;</span> <span class="dt">OperatorMap</span>
              <span class="ot">-&gt;</span> [<span class="dt">ParseRule</span> m <span class="dt">Expr</span>]
toParserRules (<span class="dt">OperatorMap</span> m) <span class="fu">=</span>
    intRule <span class="fu">:</span> map convertEntry (M.toList m)
  <span class="kw">where</span>
    intRule <span class="fu">=</span>
      <span class="dt">ParseRegular</span> parseInt
    parseInt <span class="fu">=</span>
      (<span class="dt">Const</span> <span class="fu">.</span> fromInteger) <span class="fu">&lt;$&gt;</span> integer
    convertEntry (s, oi) <span class="fu">=</span>
      <span class="dt">ParseOp</span> oi ((\s' <span class="ot">-&gt;</span> <span class="dt">Op</span> s') <span class="fu">&lt;$&gt;</span> symbol s)

<span class="ot">mkExprParser ::</span> (<span class="dt">TokenParsing</span> m)
             <span class="ot">=&gt;</span> <span class="dt">OperatorMap</span>
             <span class="ot">-&gt;</span> m <span class="dt">Expr</span>
mkExprParser m <span class="fu">=</span>
    mkParser (toParserRules m)
  <span class="kw">where</span></code></pre></div>
<h1 id="the-properties-we-need">The properties we need</h1>
<p>At this point, we have the tools to write the property that checks that we can make a round trip through the pretty printer and then the parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propPrettyParse ::</span> <span class="dt">OperatorMap</span>
                <span class="ot">-&gt;</span> <span class="dt">Property</span>
propPrettyParse om <span class="fu">=</span>
  <span class="kw">let</span>
    parseExpr <span class="fu">=</span> mkExprParser om
    prettyExpr <span class="fu">=</span> mkExprPretty om
    roundTrip <span class="fu">=</span>
      parseFromString parseExpr <span class="fu">.</span>
      prettyToString <span class="fu">.</span>
      prettyExpr
  <span class="kw">in</span>
    forAllShrink (genExpr om) shrinkExpr <span class="fu">$</span> \expr <span class="ot">-&gt;</span>
      <span class="kw">case</span> roundTrip expr <span class="kw">of</span>
        <span class="dt">Left</span> _ <span class="ot">-&gt;</span> property <span class="dt">False</span>
        <span class="dt">Right</span> expr' <span class="ot">-&gt;</span> expr <span class="fu">===</span> expr'</code></pre></div>
<p>So far, so good.</p>
<p>In order to test that remove parentheses in the middle of a round-trip alters the results, we’ll need some quick and dirty utility functions.</p>
<p>The first one will find the positions of match pairs of parentheses in a string:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findParens ::</span> <span class="dt">String</span>
           <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]
findParens <span class="fu">=</span>
    (\(x,_,_) <span class="ot">-&gt;</span> x) <span class="fu">.</span> foldr f ([], [], <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="fu">.</span> reverse
  <span class="kw">where</span>
    f <span class="ch">'('</span> (done, opens, ix) <span class="fu">=</span>
      (done, ix <span class="fu">:</span> opens, ix <span class="fu">+</span> <span class="dv">1</span>)
    f <span class="ch">')'</span> (done, o <span class="fu">:</span> opens, ix) <span class="fu">=</span>
      ((o, ix) <span class="fu">:</span> done, opens, ix <span class="fu">+</span> <span class="dv">1</span>)
    f _ (done, opens, ix) <span class="fu">=</span>
      (done, opens, ix <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>and the second one will remove those parentheses from a string:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">removeParens ::</span> <span class="dt">String</span>
             <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
             <span class="ot">-&gt;</span> <span class="dt">String</span>
removeParens str (s, e) <span class="fu">=</span>
  map fst <span class="fu">.</span>
  filter ((\i <span class="ot">-&gt;</span> i <span class="fu">/=</span> s <span class="fu">&amp;&amp;</span> i <span class="fu">/=</span> e) <span class="fu">.</span> snd) <span class="fu">.</span>
  zip str <span class="fu">$</span>
  [<span class="dv">0</span><span class="fu">..</span>]</code></pre></div>
<p>We can combine these to make something which produces a list of strings where each of the matched pairs of parentheses have been removed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parenRemovals ::</span> <span class="dt">String</span>
                <span class="ot">-&gt;</span> [<span class="dt">String</span>]
parenRemovals s <span class="fu">=</span>
  map (removeParens s) <span class="fu">.</span>
  findParens <span class="fu">$</span>
  s</code></pre></div>
<p>This will return an empty list if there are no parentheses, and that’s fine for what we’re using it for.</p>
<p>Now we can test that we’re using the minimal number of parentheses. If that is the case, then removing a pair of parentheses will either cause the parsing to fail or will cause a change in what gets parsed back in:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propPrettyParseParens ::</span> <span class="dt">OperatorMap</span>
                      <span class="ot">-&gt;</span> <span class="dt">Property</span>
propPrettyParseParens om <span class="fu">=</span>
  <span class="kw">let</span>
    parseExpr <span class="fu">=</span> 
      mkExprParser om
    prettyExpr <span class="fu">=</span> 
      mkExprPretty om
    roundTripsWithParensRemoved <span class="fu">=</span>
      fmap (parseFromString parseExpr) <span class="fu">.</span>
      parenRemovals <span class="fu">.</span>
      prettyToString <span class="fu">.</span>
      prettyExpr
  <span class="kw">in</span>
    forAllShrink (genExpr om) shrinkExpr <span class="fu">$</span> \expr <span class="ot">-&gt;</span>
      <span class="co">-- check all of the round-trips with a single pair</span>
      <span class="co">-- of parens removed</span>
      flip all (roundTripsWithParensRemoved expr) <span class="fu">$</span> \rt <span class="ot">-&gt;</span>
        <span class="kw">case</span> rt <span class="kw">of</span>
          <span class="dt">Left</span> _ <span class="ot">-&gt;</span>
            <span class="dt">True</span>
          <span class="dt">Right</span> expr' <span class="ot">-&gt;</span>
            expr <span class="fu">/=</span> expr'</code></pre></div>
<h1 id="trying-them-out">Trying them out</h1>
<p>Let’s see how we go with these properties:</p>
<pre><code>common
  text
    pretty-parse round trip:         FAIL (0.03s)
      *** Failed! Falsifiable (after 15 tests and 4 shrinks):
      OperatorMap {getOperatorMap = fromList [(&quot;#&quot;,OperatorInfo {assoc = AssocLeft, precedence = 0}),(&quot;%&quot;,OperatorInfo {assoc = AssocLeft, precedence = 0}),(&quot;&amp;&quot;,OperatorInfo {assoc = AssocNone, precedence = 0})]}
      Op &quot;#&quot; (Op &quot;&amp;&quot; (Const (-4)) (Const 4)) (Const 10)
      Op &quot;#&quot; (Op &quot;&amp;&quot; (Const (-4)) (Const 4)) (Const 10) /= Op &quot;&amp;&quot; (Const (-4)) (Const 4)
    pretty-parse correct parens:   FAIL
      *** Failed! Falsifiable (after 20 tests and 9 shrinks):
      OperatorMap {getOperatorMap = fromList [(&quot;$&quot;,OperatorInfo {assoc = AssocNone, precedence = 0}),(&quot;=&quot;,OperatorInfo {assoc = AssocNone, precedence = 1})]}
      Op &quot;$&quot; (Op &quot;=&quot; (Const 3) (Const (-13))) (Const 1)</code></pre>
<p>Hmm, not well.</p>
<p>We can try shifting our code across to the code in the Reddit post, but since it didn’t mention the <code>AssocNone</code> case we’ll leave our handling of that alone:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">needsParens ::</span> <span class="dt">Argument</span>
            <span class="ot">-&gt;</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Bool</span>
needsParens _ _ <span class="dt">Nothing</span> <span class="fu">=</span>
  <span class="dt">False</span>
needsParens arg info (<span class="dt">Just</span> argInfo) <span class="fu">=</span>
  assoc argInfo <span class="fu">==</span> <span class="dt">AssocNone</span> <span class="fu">||</span> 
  ( precedence argInfo <span class="fu">&lt;=</span> precedence info <span class="fu">&amp;&amp;</span>
    ( precedence argInfo <span class="fu">/=</span> precedence info <span class="fu">||</span> 
      assoc info <span class="fu">/=</span> assoc argInfo <span class="fu">||</span> 
      not (argumentAssociates arg (assoc info))
    )
  )</code></pre></div>
<p>This improves things quite a bit:</p>
<pre><code>common
  text
    pretty-parse round trip:         OK (0.05s)
      +++ OK, passed 100 tests.
    pretty-parse correct parens:   FAIL (0.01s)
      *** Failed! Falsifiable (after 9 tests and 8 shrinks):
      OperatorMap {getOperatorMap = fromList [(&quot;$&quot;,OperatorInfo {assoc = AssocNone, precedence = 0}),(&quot;%&quot;,OperatorInfo {assoc = AssocNone, precedence = 1})]}
      Op &quot;$&quot; (Const (-8)) (Op &quot;%&quot; (Const 8) (Const 0))</code></pre>
<p>except we’re putting too many parentheses in for the <code>AssocNone</code> case when other operators of the same precedence are in play.</p>
<p>It turns out that the code from the Reddit post handles the <code>AssocNone</code> case as it stands:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">needsParens ::</span> <span class="dt">Argument</span>
            <span class="ot">-&gt;</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Bool</span>
needsParens _ _ <span class="dt">Nothing</span> <span class="fu">=</span>
  <span class="dt">False</span>
needsParens arg info (<span class="dt">Just</span> argInfo) <span class="fu">=</span>
  precedence argInfo <span class="fu">&lt;=</span> precedence info <span class="fu">&amp;&amp;</span>
  ( precedence argInfo <span class="fu">/=</span> precedence info <span class="fu">||</span> 
    assoc info <span class="fu">/=</span> assoc argInfo <span class="fu">||</span> 
    not (argumentAssociates arg (assoc info))
  )</code></pre></div>
<p>Now the tests pass, and there is much rejoicing:</p>
<pre><code>common
  text
    pretty-parse round trip:         OK
      +++ OK, passed 100 tests.
    pretty-parse correct parens:   OK
      +++ OK, passed 100 tests.</code></pre>
<p>There was also a link in that Reddit thread to <a href="http://www.cs.tufts.edu/~nr/pubs/unparse-abstract.html">a paper on unparsing</a> that is also worth a read.</p>
<p>On one hand, it would have been nice to have had the right search terms to find that earlier. On the other hand, we now have some nice tests around our unparsing utilities, and I’m much more confident in this part of the code.</p>
<h1 id="leveling-up">Leveling up</h1>
<p>We’ve now looked at a number of uni-typed languages. The obvious next step is to combine a few of them and see what happens.</p>
<p>This is pretty exciting - we’ll get to look at type systems, and the links between semantics and types, and there’ll be a few other little tips and tricks in between. <!--[Read on!](../nb.html)--></p>
<h1 id="exercises-for-the-adventurous">Exercises for the adventurous</h1>
<ul>
<li>Write a language for working with strings.</li>
</ul>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on May 27, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
