<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - Testing NB</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../../css/custom.css">
        <link rel="stylesheet" href="../../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Little Languages" href="../../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Little Languages" href="../../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../../">Little Languages</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../../drafts/nb/testing.html">Testing NB</a></h3>
    </div>
    <div class="panel-body">
        <h1 id="a-new-suite-of-generators">A new suite of generators</h1>
<p><a href="../nb.html">Previously</a> we introduced our first type system, in the language <em>NB</em>.</p>
<p>This means we now have type-checking in our arsenal, and we can talk about whether a term is well-typed or ill-typed.</p>
<p>Along with that, we have some new properties that we’d like to test, in order to make sure that we’ve implemented these new concepts correctly.</p>
<p>For that we’re going to need some new generators.</p>
<h2 id="generating-types">Generating types</h2>
<h3 id="lets-generate-a-type">Let’s generate a type</h3>
<p>We need to be able to generate arbitrary types.</p>
<p>We have a simple type system so far, so we end up with simple rules for generating types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTyNat ::</span> <span class="dt">Gen</span> <span class="dt">Type</span>
genTyNat <span class="fu">=</span>
  pure <span class="dt">TyNat</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTyBool ::</span> <span class="dt">Gen</span> <span class="dt">Type</span>
genTyBool <span class="fu">=</span>
  pure <span class="dt">TyBool</span></code></pre></div>
<p>and we can combine them using <code>oneof</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genType ::</span> <span class="dt">Gen</span> <span class="dt">Type</span>
genType <span class="fu">=</span>
  oneof
    [ genTyNat
    , genTyBool
    ]</code></pre></div>
<p>We don’t have any obvious ways of shrinking these types, but we have the usual default rules - that return an empty-list and stop the shrinking process - for our types in the code repository.</p>
<h3 id="no-not-that-one">No, not that one</h3>
<p>We also need to be able to generate types that is different from some given type.</p>
<p>The types we are dealing with will eventually be coming from different packages that describe the rules for the particular language fragments. With that in mind, it would seem like a win if we could create the rule for generating types other than <code>TyNat</code></p>
<ul>
<li>by only referring to <code>TyNat</code></li>
<li>in a manner that could be sensibly packaged with the other rules for the <em>N</em> language</li>
</ul>
<p>After a bit of poking around we come up with this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genNotTypeTyNat ::</span> <span class="dt">Type</span>
                <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Gen</span> <span class="dt">Type</span>)
genNotTypeTyNat <span class="dt">TyNat</span> <span class="fu">=</span>
  <span class="dt">Nothing</span>
genNotTypeTyNat _ <span class="fu">=</span>
  <span class="dt">Just</span> genTyNat</code></pre></div>
<p>which we repeat for <code>TyBool</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genNotTypeTyBool ::</span> <span class="dt">Type</span>
                 <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Gen</span> <span class="dt">Type</span>)
genNotTypeTyBool <span class="dt">TyBool</span> <span class="fu">=</span>
  <span class="dt">Nothing</span>
genNotTypeTyBool _ <span class="fu">=</span>
  <span class="dt">Just</span> genTyBool</code></pre></div>
<p>These combine nicely:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genNotType ::</span> <span class="dt">Type</span>
           <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Type</span>
genNotType ty <span class="fu">=</span>
  oneof <span class="fu">.</span>
  mapMaybe (<span class="fu">$</span> ty) <span class="fu">$</span> [
    genNotTypeTyNat
  , genNotTypeTyBool
  ]</code></pre></div>
<p>and appear to do what we want:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> sample (genNotType <span class="dt">TyNat</span>)
<span class="dt">TyBool</span>
<span class="dt">TyBool</span>
<span class="dt">TyBool</span>
<span class="dt">TyBool</span>
<span class="dt">TyBool</span>
<span class="fu">...</span></code></pre></div>
<p>We couldn’t shrink the outputs of <code>genType</code> because there were no smaller types.</p>
<p>That is true again here, but it’s also the case that we don’t have the information that we would need to do the shrinking anyhow.</p>
<p>Once we have composite types, we could end where a shrink brings us back to the type we were trying to avoid.</p>
<p>Imagine this interaction:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> sample (genNotType <span class="dt">TyNat</span>)
<span class="dt">TyPair</span> <span class="dt">TyNat</span> <span class="dt">TyBool</span>

<span class="fu">&gt;</span> shrink (<span class="dt">TyPair</span> <span class="dt">TyNat</span> <span class="dt">TyBool</span>)
[<span class="dt">TyNat</span>, <span class="dt">TyBool</span>]</code></pre></div>
<p>We need more information to be able to avoid this, and so we’ll leave the shrinking of these things alone for a post or two.</p>
<h2 id="generating-type-errors">Generating type errors</h2>
<p>We’re also going to need to be able to generate arbitrary type errors.</p>
<p>The two interesting type errors we have both require two types that are different - otherwise there wouldn’t have been an error in the first place - and this is something we can handle now that we have <code>genNotType</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genTypeErrorUnexpected ::</span> <span class="dt">Gen</span> <span class="dt">TypeError</span>
genTypeErrorUnexpected <span class="fu">=</span> <span class="kw">do</span>
  ty1 <span class="ot">&lt;-</span> genType
  ty2 <span class="ot">&lt;-</span> genNotType ty1
  return <span class="fu">$</span> <span class="dt">Unexpected</span> ty1 ty2</code></pre></div>
<p>We also have to take care that we don’t accidentally end up with an invalid type error during shrinking, and so we filter the results to make sure of that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkTypeErrorUnexpected ::</span> <span class="dt">TypeError</span>
                          <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">TypeError</span>]
shrinkTypeErrorUnexpected (<span class="dt">Unexpected</span> ty1 ty2) <span class="fu">=</span>
  <span class="kw">let</span>
    valid (<span class="dt">Unexpected</span> u1 u2) <span class="fu">=</span>
      u1 <span class="fu">/=</span> u2
    valid _ <span class="fu">=</span>
      <span class="dt">False</span>
  <span class="kw">in</span>
    <span class="dt">Just</span> <span class="fu">.</span> filter valid <span class="fu">$</span>
      fmap (\s1 <span class="ot">-&gt;</span> <span class="dt">Unexpected</span> s1 ty2) (shrinkType ty1) <span class="fu">++</span>
      fmap (\s2 <span class="ot">-&gt;</span> <span class="dt">Unexpected</span> ty1 s2) (shrinkType ty2)
shrinkTypeErrorUnexpected _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>We do the same for the <code>ExpectedEq</code> type error, and then combine the generating functions and shrinking functions in the usual manner.</p>
<h1 id="generating-terms">Generating terms</h1>
<p>The terms that we can currently generate are now a little bit too random for some of our needs.</p>
<p>TODO motivate the army of generators, all of the various arguments to the generators</p>
<h2 id="generating-well-typed-terms">Generating well-typed terms</h2>
<h2 id="generating-terms-containing-other-terms">Generating terms containing other terms</h2>
<p>One of the issues with <code>genIllTypedTerm</code> is that the type errors are all occurring at the outermost constructor of the term.</p>
<p>If could generate one term which contains a given term, we could cause the type error to occur further down in the AST.</p>
<p>There are other reasons to want this machinery, which will come up shortly, so we’ll</p>
<h2 id="generating-ill-typed-terms">Generating ill-typed terms</h2>
<p>One option (ish)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  ty <span class="ot">&lt;-</span> genType
  nty <span class="ot">&lt;-</span> genNotType ty
  tm <span class="ot">&lt;-</span> genWellTyped ty
  genContaining nty tm</code></pre></div>
<p>TODO note that by generating based on type errors we can control the distribution of errors</p>
<p>TODO note somewhere in here that having some data structures to group all these things together would be handy…</p>
<h1 id="writing-the-properties">Writing the properties</h1>
<h2 id="progress">Progress</h2>
<h2 id="preservation">Preservation</h2>
<h2 id="double-checking-our-generators">Double-checking our generators</h2>
<p>TODO the gens are pretty crazy, there was some simlarity between the gens, the infer function, and the double checking properties, but that’s so that we can be confident in them - progress and preservation are what is important and neither is closely related to the implementation of infer etc…, so it’s not like we’re a snake eating its own tail.</p>
<h1 id="fixing-the-old-properties">Fixing the old properties</h1>
<p>TODO the things that were broken at the start of the nb post, that rely on well-typed terms</p>
<h1 id="improving-the-shrinking">Improving the shrinking</h1>
<p>TODO results of inferWellTyped / inferIllTyped / inferContaining</p>
<p>We can do better on this front, but doing so will mean we need to be able to annotate the terms in our AST.</p>
<!-- [Read on!](annotations.html) -->
<p>Coming soon…</p>
<h1 id="exercises-for-the-adventurous">Exercises for the adventurous</h1>
<ul>
<li>TODO alternative form of ill-typed, does anything fail? gather stats on the frequencies of the different errors with and without the different form of genIllTyped, maybe crank up the number of tests, compare and contrast</li>
</ul>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on July  1, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
