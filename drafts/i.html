<!DOCTYPE html> 
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Dave Laing - I - the language of integers</title>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="../css/custom.css">
        <link rel="stylesheet" href="../css/syntax.css">
        <link rel="alternate" type="application/atom+xml" title="Atom - Little Languages" href="../atom.xml" />
        <link rel="alternate" type="application/rss+xml" title="RSS - Little Languages" href="../rss.xml" />
    </head>
    <body>
        <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand">
                <a href="../">Little Languages</a>
            </div>
            <ul class="nav navbar-nav">
                <li role="presentation"><a href="http://dlaing.org">Back to my main site</a></li>
            </ul>
        </div>

        </div>
        </nav>

        <div class="container">
            <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title"><a href="../drafts/i.html">I - the language of integers</a></h3>
    </div>
    <div class="panel-body">
        <h1 id="introducing-i">Introducing <em>I</em></h1>
<p>We’re going to have a look at <em>I</em>, a language built around integer expressions.</p>
<p>This is mostly to get some experience with more interesting parsers and pretty printers before we get bring in some more theory.</p>
<p>We will have terms for integer literals, as well as addition, subtraction, multiplication and exponentiation:</p>
<p><img width="66" alt=" \begin{aligned} t =&amp; \ \text{I int} \\   |&amp; \ \text{t} + \text{t} \\   |&amp; \ \text{t - t} \\   |&amp; \ \text{t} \times \text{t} \\   |&amp; \ \text{t}^\text{t} \end{aligned} " height="112" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIUAAADhCAQAAABMtr77AAAFUUlEQVR4nO2d3bWiMBSFaYVKaMQ6KMMm7MEW6IAGfPbRFx+ukwQ8A4pwTv5OxP2x1sxchpuET35jNlRVCZyq7mVqtZukxcGself9VQ8zXaqz+alZXb6p7mbpY6bWOY6mYXW22jqngrM9DEtexTU0/lub/ZwOvr8shq+icS07iWuw254XB1Pdn9+vesFXUZltdX0XWuboq+Ls9tx8SFT41uCp4mIado7bllVSq6jNNu6p4p71SJFehS1fpKI2jbHTcWyYnfII4aoYTr3d5LDZuqPA82qkHa9Npq1uxtL7cY1azpmxMScpO9lt4j7+23OzEsJV0ZkWzU+m1+rm5nRmBXuzUzfm786t+MDpbY2uko8395FCtoN0b9cVw+bfT1bx9nLCFe8gTzjXFIfxCpEzbV8bhqu4vq16//KzhwruNUXLnrb3zXAVj9VlPFXkvqawxNgq1uZ4qsh/pChWRd67j4EiVeS++xgoUgX3SNHQWXp7ynMGWZszV8G8xZ8fKT5Lqc1Sr/1Pn6YcZ5AEKqZ3H973+GKKVDE9Q1+z9WOlVnGa/NzMLr5WuJGKPlsPYu12S+4pvDdL3mYfUu/uMNbm1O68OHT5sDuSD+7O/sQ62MXg+naZvrZTzpd8n9MuzrEcjJr7eOxiM9yq75HDZn86AAAAAAAAAAAAAAAAAAA2uKKz/UnaEbpfBVQQUEFwVQSkNYTkq+kFrop8Izny1fQCV4VvWuNPPIDOOxcSCn/4iF8D5cci71xIKLym+qc1pCoCciGh8KNxeVT41xTMdlO90hqC8mPVFMxWUwPTGgIVoTUFgx2EgAoCKgioIOKpaMa43PZ0XxlxugsVywGth3u2AT+gtRMV/uXHqCkYHxWSBzKEqZA/+iEAqCCgguA11SutISg/Rk3B8G/SxWkNQfkxagqG21SvtIag/PCagpE01Set4dejrpILSd35/0VfLqRu6jlv90sIX/SppQYqCKggoIKACiL3czAAAAAAAAAAAADwAeRBCHTdEFBBQAVRQh5ELQEyp4Q8iFoCZE7qPIh22QJS50G0yxaQOg+iW7aI1IMVdcsWkToPole2mNR5EK2yPcAOQkAFARUEVBBQQcRW8f4A9HhlJya2iu7thRvxyk5M6pH/umWLgAoCKojUeRDdskWkzoPoli0idR5Eu2wBqfMgJZTNBJ3/BFQQUEFABQEVBFQQUEEgDwIAAAAAAAAAAIDSQDSGQC8WARUEVBAlRGM065pQQjRGs64JJURjNOuaUEI0RrOuCfGjMWvfrNSMqxi1qEzscZu1S3d8+r9byeM440djTh9kWBFbL1lSjcqkiMYsyeCIUI7KpBnu/iqDI8K3rmikGvk/lSERsUMV/2XIROxSxVOGTMROVdjnNdvzgezQt0sVdte4r1xnxKwrAulUWBE38+en64yYdUUhVQjiKcIik6EWikijYirCIpGxKxWvIix8GYWrkMRXlkQ8y+DIUIvKxI/GLIuwnFgHRLWoTPxoTL9yN8nrn1KKypQSjdGsawSd/wRUEFBBQAUBFQRUEFBBIBoDAAAAAAAAAF8J7muJi3YD4hGaB/mL1I4CCOu66RiPFv0a/FW0Zud4uK/+Ot1n38XCX4WNKvTu91v9h77FICwP8pM7yHJG4ydVLH8H/pMqlr/g/0EVnzIa/1UoPlM3FmGDFe38YWDJT6hYy2jYIUXHSvnxwrEIzYP0bte5/M51xdoI20JeoBaO/psgigEqCKggoIKACgIqCP2XYhQDVBBQQei/KqUY9F+VUgwlvCqlEErNgyiA0bwEVBBQQUAFARUEVBBQQXxJHuQfAPECL5T2FlkAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-53px;" /></p>
<p>We’ll represent these terms in Haskell with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">IntTerm</span> tm <span class="fu">=</span>
    <span class="dt">TmInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">TmAdd</span> tm tm
  <span class="fu">|</span> <span class="dt">TmSub</span> tm tm
  <span class="fu">|</span> <span class="dt">TmMul</span> tm tm
  <span class="fu">|</span> <span class="dt">TmExp</span> tm tm</code></pre></div>
<h1 id="semantics-for-i">Semantics for <em>I</em></h1>
<p>There is only one kind of values in <em>I</em>, the integer literals:</p>
<p><img width="108" alt=" \prftree[r]{V-Int} {\text{(I i) val}} " height="26" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANgAAAA1CAQAAACJ8+06AAAEbUlEQVR4nO2cy4GrIBSGaYVKaMQ6LCNN2IMt2AENZO3SjQtz4YCRx4GAr9wJfG4mimSGX+C8HEIqPi0ZrKPzWnTRq1grdbRX/trlwkCyhbzEMZGeNF6LlnC4OkdFaIx+nqKfVvRcuYwOBroPXudCTJrQzwD97JlbrM7IHCjMjSl4/UkeSf3sF0zOz0oGatnzF0QJFcthGvsFe1TB8mhhqPFB65MHc79gQxUsl1kM9YJemZINiL2CySW5CpaJGmx/r2oiexveR75gQ3B2V4IwbZK78Ij35eIL1sLutDoEq9dn7pVM38XFVXWk2KMVIm1BOXDucM0ZA+gLNor5qXZHKiTphTwUWnF9vRMtRliOZ/hJHrjpU/HAvLHuPbQp4EuiWvC4IYQUsfNaVLLxvbFn1o4UFmz0BOLO5yrYDlxvjCV7YIqwYC/vzOh8roLtoNHb/0ofCVdhxGZY7ExUsLHwI47tjc2ZIdxLBGsLP+L0MOSdHinfyB/hunlcLlglBjW8McwDG6Iztgr2BZQ3xjJCvhvnCPZp2a5YPLQ31u145r8oWHPSFKXg4/8tFh13yI84fE2wRtx01jB3idna/4dBFwzsvTNfsM74zLJiK0BjmbPHy0t6xNq6CmUILIf2geZDwUAIqvc/904OM5ZGzqiMtxrz7PGVm635lXnlJTI2sHhJivE2G6gVv+HkPdG5TEgQOI5v7qu/2D7XomckcpLMekJkMqB/bGqmR7Vze2AklH6/An8JyuU7Cfvmw2RAYQFZUgVjMBd9/4XfaKweF+wPwQObbXoulaJPSZt49xkUJBgNbrb7y0tW5ttMj4IE69+2istxwYbsjfzINxUi2BQMxxwX7IHubVdQjGCUvIJOW5pgygXAXxqI9b7CrLj6Oh+b9xmmW/XgbYXKY4oRrI3EjNMEG7Q/gg/X/DF6IEtSZuhhMUJD28sKHbR56iutODMh7kIxgg0RSdKXxPBwjU72CEd5/bbpsy2nzDJdpBOxeDtjFYycIxhPdJ8H4tYHNu/FdIDZt0nEEbu2GMHGiB13hmCxB8KE6YyUeWf7/sm+hn1bUYKFuFMw9ZuYu+m298l0jRmprIIFuFewDqLZ2yffmacQ5lVGThUM4V7BVBJxnUlubk4Wxyxi93pAmrUKhnK3YJvhYSf0VM5py2IXLVjMirtbsM3wsPeskfhFzsUKdocflh5NXA0Psy/1nqTZx/ZtA3Lux4lF+84RDH/DEUcZHnYqMVYdMUZa/SjscGhqbYkPV+4wLuAk2/7YywlPjyULRqC4CyNUXoLBIernL32xxwHHj3i4+WwOtRBykaRGS7/o5WfhiJ0YKi/BCFedq1xbXl0HVq7QwKMjTfoeXjKVZxYjVIyXuPwsD4K9ln0Ozx2lz/iAU++1hoJfMp3zyxiTCBcfVA7RZZne6fRIGqRyCtMFNXkyx1Xn10W0jil9BsOuSvVKInjt736aCx6BigU/cQGjYnb9vHn9fXL+YU+c8abituI5x7fBC7crCfwD7BwfHB27fWQAAAAASUVORK5CYII=" class="display-math" style="margin:0; vertical-align:-5px;" /></p>
<p>Most of the steps have one reduction rule which does the required arithmetic:</p>
<p><img width="291" alt=" \prftree[r]{E-AddIntInt} {I (i_1) + I (i_2) \longrightarrow I (i_1 + i_2)} " height="27" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-5px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eAddIntInt ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>
eAddIntInt (<span class="dt">TmAdd</span> (<span class="dt">TmInt</span> i1) (<span class="dt">TmInt</span> i2)) <span class="fu">=</span>
  <span class="dt">Just</span> (<span class="dt">TmInt</span> (i1 <span class="fu">+</span> i2))
eAddIntInt _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>and two congruence rules that control the evaluation order.</p>
<p>The first of the congruence rules causes the left-most argument to take a step:</p>
<p><img width="195" alt=" \prftree[r]{E-Add1} {t_1 \longrightarrow t_1^{\prime}} {t_1 + t_2 \longrightarrow t_1^{\prime} + t_2} " height="39" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eAdd1 ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>)
      <span class="ot">-&gt;</span> <span class="dt">Term</span>
      <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>
eAdd1 step (<span class="dt">TmAdd</span> tm1 tm2) <span class="fu">=</span>
  <span class="dt">TmAdd</span> <span class="fu">&lt;$&gt;</span> step tm1 <span class="fu">&lt;*&gt;</span> pure tm2
eAdd1 _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>and the second rule causes the right-most argument to take a step whenever the left-most argument is a value:</p>
<p><img width="200" alt=" \prftree[r]{E-Add2} {t_2 \longrightarrow t_2^{\prime}} {v_1 + t_2 \longrightarrow v_1 + t_2^{\prime}} " height="39" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p>We’re using the variables names <img width="11" alt="\text{v}" height="8" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAQCAQAAABXJiyTAAAAn0lEQVR4nI2SsRWEIBBEpxUqoRHqsAyasAdboINrwJjQ5AK5XRSEU0c/CTvMYxkA2LAYmmF21VXFomNExBdJxiozt6tBKtUWWT9h8uLUaV6UC2vZLWHuFIfPnVkTaOv2nEHOTYhiD029MLNGThL5qCbizWhcX3sZ6kUb17KYhSNuqF0oJW58Yy5xfXdDlDV/Bvts3Di/LkXj0tf858b8A4giQL3UmJycAAAAAElFTkSuQmCC" class="inline-math" style="margin:0; vertical-align:-1px;" /> to represent values as a convenient shorthand, however we could have written the rule as:</p>
<p><img width="196" alt=" \prftree[r]{E-Add2} {\text{value} \ t_1} {t_2 \longrightarrow t_2^{\prime}} {t_1 + t_2 \longrightarrow t_1 + t_2^{\prime}} " height="39" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p>which better matches the Haskell version we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eAdd2 ::</span> (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>)
      <span class="ot">-&gt;</span> <span class="dt">Term</span>
      <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Term</span>
eAdd2 step (<span class="dt">TmAdd</span> tm1 tm2) <span class="fu">=</span>
  <span class="dt">TmAdd</span> <span class="fu">&lt;$&gt;</span> value tm1 <span class="fu">&lt;*&gt;</span> step tm2
eAdd2 _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>The semantics for subtraction:</p>
<p><img width="288" alt=" \prftree[r]{E-SubIntInt} {I (i_1) - I (i_2) \longrightarrow I (i_1 - i_2)} " height="27" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-5px;" /></p>
<p><img width="193" alt=" \prftree[r]{E-Sub1} {t_1 \longrightarrow t_1^{\prime}} {t_1 - t_2 \longrightarrow t_1^{\prime} - t_2} " height="39" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p><img width="197" alt=" \prftree[r]{E-Sub2} {t_2 \longrightarrow t_2^{\prime}} {v_1 - t_2 \longrightarrow v_1 - t_2^{\prime}} " height="39" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p>and for multiplication:</p>
<p><img width="290" alt=" \prftree[r]{E-MulIntInt} {I (i_1) \times I (i_2) \longrightarrow I (i_1 \times i_2)} " height="26" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAkQAAAA1CAQAAAAKCDycAAAIvElEQVR4nO2duZmsMAyAaYVKaIQ6KIMmJngd0AId0AAx4SQT7D5sw+BLRj4wx+rn22AZEJZlCx+yKQqCILC8in73aHYkTMsxoq+cihqdQnH9z/wHp9n93H3SSyQIwgNRBX+K3/kYtco4FB9+vndKqOZK2xVvfuXbed3v8pTXfEeJTuEqfXNE9XxuS3M3/1ehpdlJL5EgCG96XgVtrYBuPj+gJIxcBtzSYY6NXYF3QWr6Jss5e5rdVOA9oRJdMgmCQOOqgr3hAuxX9bzdAreehuUpoelL5YgaMI3hjgiWSRAEGlcVrJwdrk1CP3e5fufujZ2GdwKv4IjaAxwRLJMgCDTuKoh1RCWX8gJ+Ly/iiPoDHBEskyAINO4qOKIksKo48MFek5KPM13BEZVzmy21I3LJJAgCjVkF5VGPF2KyXTiilssxZ5xeXPYVHFHvGMcKb2PtzSwSBIHArIK+ox5r5+RjrZSj9BSZhj+nl7pz5pn1zj1HtN7ZLP+JEATZhVbLPcP8qzhKp8QUMgmCQGNWwSHQETFJH+23uuikp8iwUMVfxclMS0SS6nYwjmi9s+cdwW52EWJUag0+EOGUH54+e1ilmQvxMgmCQCOqYPd9q/t3NlZHVFm6N/3SWbN3zUwngzlj70iJdA+SM3hrw+f+XbM4mQRBoBFV8L2809dWgJ+E9frJCIEcvtfkcEST4SQG7X9/RxQukyAINHoVrOauRqgjEtFE20hJOx/yU2zPTumIfo0zk/a/vyMKl0kQBBqzCnbBjqjka7a2FsQgXZOnReQ6E9oiCpUprfOlgw461gMKN3RN3xffNg2MHNI3FNvy10o6/ycdUUMHHXQYh31VuVkFa8VlTYUY+1EPVUIv3btFE3XSE/+kIyIIAsteKN/Er9FbV6oEuSpu0USjcg05IoIgQNyOqEYs8lAdUVeI5a+NMdt0LUdkXhvviDB7FRAEYcHtiDAD16ojEstf22JQ4ozJEUVQBze6WAzmVcO9n6lVHOF5cj6xVnE5onLuaPkNVjNGXll77RqbI+qMij6SI9KpZ7HhBn4V70tW2mdqFUdcnpxPnFVcjmhwjh5tElSn0wJuwnREjVatKz7CdJQjekn/V1rgZagjcsncpSrMTcJ16jlL4vau7VBbKKTjmVrFkSdPzifcKuWyzave7qnmKvaxOg+dtviZD/X+H2PN2WB9ilgyseZ+OVfplo8wVdqdH8XRrmnujCeo1+lnRJTTuuREdjp2iXEyEZRFw/uwIrS951Ob+hUfI1HrL/glgXrz9FieqVUcufLkGI62ijkpbx66Q1HplWvlqCE9gkg+ZBtUxcQjuVns0sg3spevMu8z09xbr7M/kb10PtoLyS4xTqYXLeCjReZBvT17E9NOVbg2FD+GZ2oVx/F5cgzPtspGxV8QIvWlI+IpDfUB8qNkwmauCrhn3IJvUBtD9gm9Z2oVR448OYJnW4VYUL+XJDOgdurF0DgK+jE8U6s4cuTJ+dzNKgSn1Hq16i/p3oSfrIO7z9Qqjlx5cj53sgqxYJtiFLDYhnR9SNYt2J9adfXuS4/UXEur1PwEjYLkyhOVVBb14RyrEFHA4wbvnZkCP1g1sK963mBvZigCoeRbVmG5klbp8d0nR5ArT2TSWdSHc6xCRAGNG8BFSMSk+H/CBPPZ3hdwFSu0Pu2Aa2mVmj7IceTKE5U4i97JKkQE8LhBA5xn0bcV/3U/5F3lgxoQtRVcXzd0Pa3SUgWkM2eeqIRb9F5WISKAxw166/lyWQRQgvMvMBMyFkQvuL5u6JpapWXQ4lz3yZknOmEWvZ9ViGDgcQN78eyWvncbUDgGdKiZXHD93dBVtUpJ6T0zlDNPTEIsej+rEMHAkSWTdeZhbfAOARO+9gJvZy24IW7oulqlpJ7zZfRoFeXMExv+Fr2jVYgg4HEDqHHbS/eZU6/uVbd+hUMU3BA3lFKrhi99GBxzMOcVebG2B/fsvJa242vRe1qFCAAeN3D3slmRUjsGbBe6ga+/hfEtHB1PnX8DO51W66d1W17l7SnZ16rm+XLcgVkzn9fSECEWPcoqxIVwLSZ0FU/9K49M0ouvH07niEoe3RIyDZtKK/nL51Whb4MgP21PK9yW7v+Q122H6G5h8jSvpe2EWfQ4qxCXAR43cBVPZv4fz3sYPoWDFVq2yRUUheIilVbjLGl7305GlRScV+RZuwQ7dpLX0jbCLHo/qxDeuMYNXPMOPViUUjmitdAyfF1ROq2mQt1Zxi71rCI/eIye5ba0LQVhFr2bVYgAXOMGLlN+vgW3065wF0/77IyJXGgZfq4onVZs/+YtFWznOlv7A6tVWlqvipbb0jrhFr2XVYgg3NtNQet12mLbrU7f4XjPEdmb+Sp6oWX4vkPTaiVStW2EqYLTKjV+q81yW1ol3KJ3swoRhGvcQPTOoUavOF8bRcldPDFhabZCy8C7ovRarb/bx2NShPv58vJ83+e2tEyMRe9lFSKIxjluwPhYjfla7iot7yhX8YSKu4q90MrPdXOEVuLzwdCy0DO+bzl5jZrltrRKjEXvZRXCE3MTb7vRBqCwvfk3BibLAKereHbgkKj6TPhN3zoL13FasTggKHQOp1VqsItAz7G0LjvUou4UXM8qxEG0YIFnMSy24uUqnuNhe9744atV5YxePkcre+6Hk9bSabmPVYjD+HjG8MDF80qbkfpoVUpv48Z4f19JqzjSWToHf8UqxILvoChcPLu5IX2V6VS8Vux7WlsTX5/CvpZWcaSz9PH8HasQX95eg35voHiWHjHAOcBpJeZ7pu+hTxRfTas40lj6eP6WVYiFRvvsLQRbDf0uxBLMyZiD6S+2Xx5Oq9EY6lW5mlZxpLH08fwtqxBf4C+AYqmRRTwnz9Qqjvg8OZ/nWYX4MkQ1dVlT+oqrfp6pVRxxeXI+z7QK8cW1BdUe02U/7PJMreKIyZPzeapViC+h4WFHfUIvDc/UKo77BgI+2So35T9TJDYSTfd3jQAAAABJRU5ErkJggg==" class="display-math" style="margin:0; vertical-align:-5px;" /></p>
<p><img width="194" alt=" \prftree[r]{E-Mul1} {t_1 \longrightarrow t_1^{\prime}} {t_1 \times t_2 \longrightarrow t_1^{\prime} \times t_2} " height="39" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p><img width="198" alt=" \prftree[r]{E-Mul2} {t_2 \longrightarrow t_2^{\prime}} {v_1 \times t_2 \longrightarrow v_1 \times t_2^{\prime}} " height="39" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-4px;" /></p>
<p>are defined similarly.</p>
<p>Exponentiation is a little different. The congruence rules follow the familiar pattern, but we have two reduction rules.</p>
<p>We can’t work with negative exponents of integers and continue to get integer results, so we define different rules for the cases of negative and non-negative exponents:</p>
<p><img width="240" alt=" \prftree[r]{E-ExpIntInt} {0 &lt;= i_2} {{I (i_1)} ^ {I (i_2)} \longrightarrow I ({i_1}^{i_2})} " height="41" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-5px;" /></p>
<p><img width="233" alt=" \prftree[r]{E-ExpIntNeg} {i_2 &lt; 0} {{I (i_1)}^{I (i_2)} \longrightarrow I(0)} " height="41" src="data:image/png;base64,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" class="display-math" style="margin:0; vertical-align:-5px;" /></p>
<p>To be honest, I wrote the first version of <em>I</em> very late at night, and the semantics and associated code was written mostly by muscle memory. This is just one of the things that <code>QuickCheck</code> caught while I was trading sleep for talk preparation.</p>
<h1 id="parsing-i">Parsing <em>I</em></h1>
<p>We haven’t had to parse any operators in our other languages, and I really don’t want to go through the ins and outs of coming up with a grammar and factoring it appropriately (because there are other sources that do it better), so it’s time to introduce some new tricks.</p>
<h2 id="expression-parsing-with-parsers">Expression parsing with <code>parsers</code></h2>
<p>As usual, <code>parsers</code> has something useful for this. In this case it’s contained in <code>Text.Parser.Expression</code>, and we’re going to do a bit of a lightning tour of what that offers.</p>
<p>This provides the data type <code>Assoc</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Assoc</span> <span class="fu">=</span>
    <span class="dt">AssocNone</span>
  <span class="fu">|</span> <span class="dt">AssocLeft</span>
  <span class="fu">|</span> <span class="dt">AssocRight</span></code></pre></div>
<p>the data type <code>Operator</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Operator</span> m a <span class="fu">=</span>
    <span class="dt">Infix</span> (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="dt">Assoc</span>
  <span class="fu">|</span> <span class="dt">Prefix</span> (m (a <span class="ot">-&gt;</span> a))
  <span class="fu">|</span> <span class="dt">Postfix</span> (m (a <span class="ot">-&gt;</span> a))</code></pre></div>
<p>the type synonym <code>OperatorTable</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">OperatorTable</span> m a <span class="fu">=</span> [[<span class="dt">Operator</span> m a]]</code></pre></div>
<p>and a function to convert an <code>OperatorTable</code> into a parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">buildExpressionParser ::</span> forall m a<span class="fu">.</span> (<span class="dt">Parsing</span> m, <span class="dt">Applicative</span> m) 
                      <span class="ot">=&gt;</span> <span class="dt">OperatorTable</span> m a 
                      <span class="ot">-&gt;</span> m a 
                      <span class="ot">-&gt;</span> m a </code></pre></div>
<p>The second argument to <code>buildExpressionParser</code> is a parser for everything-but-the-operators.</p>
<p>If we were using this directly, we could make an <code>Operator</code> for each of our operators, like so:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addOp ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
      <span class="ot">=&gt;</span> <span class="dt">Operator</span> m <span class="dt">Term</span>
addOp <span class="fu">=</span> <span class="dt">Infix</span> parseAdd <span class="dt">AssocLeft</span>
  <span class="kw">where</span>
    parseAdd <span class="fu">=</span> <span class="dt">TmAdd</span> <span class="fu">&lt;$</span> symbol <span class="st">&quot;+&quot;</span></code></pre></div>
<p>Once we had all of these defined, we’d put them into a list of lists, where the inner lists contained operators with the same precedence and the outer list is sorted in order of descending precedence:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">opTable ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m) 
        <span class="ot">=&gt;</span> <span class="dt">OperatorTable</span> m <span class="dt">Term</span>
opTable <span class="fu">=</span> [
    [expOp]
  , [mulOp]
  , [addOp, subOp]
  ]</code></pre></div>
<p>Then all we’d need to do is to stitch everything together with <code>buildExpressionParser</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">parseTerm <span class="fu">=</span> 
    buildExpressionParser table parseNotAnOperator <span class="fu">&lt;?&gt;</span> <span class="st">&quot;term&quot;</span>
  <span class="kw">where</span>
    parseNotAnOperator <span class="fu">=</span> parseTmInt <span class="fu">&lt;|&gt;</span> parens parseTerm</code></pre></div>
<p>The expression parser doesn’t deal with parentheses, so we handle those in the other case. This will handle things like “(2 + 3) * 5” along with “(((5)))”. The latter has no operators in it, so the expression parser keeps falling through to <code>parseNotAnOperator</code> until the parentheses are dealt with.</p>
<h2 id="some-helpers-for-expression-parsers">Some helpers for expression parsers</h2>
<p>We’re going to shuffle some things around a little. Most of the payoff will be in being able to continue to work with a list of parsing rules that we can combine, but it’ll also keep the door open for adding user-defined operators with precedence annotations later on.</p>
<p>We start with a datatype capture associativity and precedence:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OperatorInfo</span> <span class="fu">=</span>
  <span class="dt">OperatorInfo</span> {
<span class="ot">    assoc      ::</span> <span class="dt">Assoc</span>
  ,<span class="ot"> precedence ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We then create a datatype for our parsing rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ParseRule</span> m t <span class="fu">=</span>
    <span class="dt">ParseRegular</span> (m t)
  <span class="fu">|</span> <span class="dt">ParseOp</span> <span class="dt">OperatorInfo</span> (m (t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t))</code></pre></div>
<p>The <code>ParseRegular</code> rules are for the all of the parsers that we’ve seen so far. The <code>ParseOp</code> rule combines the operator information with the parser for the operator, in the style needed by <code>Text.Parser.Expression</code>.</p>
<p>At some point we’re going to need to partition these two types of rules.</p>
<p>For regular parsers, we just gather the parsers into a <code>Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherRegular ::</span> <span class="dt">ParseRule</span> m t
              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (m t)
gatherRegular (<span class="dt">ParseRegular</span> p) <span class="fu">=</span>
  <span class="dt">Just</span> p
gatherRegular _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>so that we can use <code>mapMaybe</code> over the rules to get hold of the regular rules on their own.</p>
<p>For the operator parsers, we build a singleton <code>OperatorTable</code>, and pad it out using the precedence information:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherOp ::</span> <span class="dt">ParseRule</span> m t
         <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">OperatorTable</span> m t)
gatherOp (<span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> assoc prec) p) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> [<span class="dt">Infix</span> p assoc] <span class="fu">:</span> replicate prec []
gatherOp _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>If we are using <code>gatherOp</code> to partition parsing rules, we’ll end up with a list of <code>OperatorTable</code>s, so we need a way to combine them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">combineTables ::</span> [<span class="dt">OperatorTable</span> m a]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
combineTables os <span class="fu">=</span>
    foldr (zipWith (<span class="fu">++</span>) <span class="fu">.</span> pad) (pad []) os
  <span class="kw">where</span>
    <span class="co">-- find the operator with the highest precedence</span>
    l <span class="fu">=</span> maximum <span class="fu">.</span> map length <span class="fu">$</span> os
    <span class="co">-- pad everything out to that precedence</span>
    pad ls <span class="fu">=</span> replicate (l <span class="fu">-</span> length ls) [] <span class="fu">++</span> ls</code></pre></div>
<p>We should stop and look a bit more closely at the above functions. The look like they’re doing what they’re meant to, but there are a few uses of <code>replicate</code>, <code>length</code> and <code>++</code> as well as the use of <code>maximum</code>.</p>
<p>The odds are good that we’re doing more work than we need to. I’m fine with that for a blog post that isn’t about performance, as long as the meaning and correctness of the function is clear - however that isn’t necessarily a zero-sum game.</p>
<p>Let’s have another go.</p>
<p>For a particular rule, the information in the <code>OperatorTable</code> is made up of the precedence, the associativity and the parser. The associativity and the parser get combined into an <code>Operator</code>, so we’ll do that in <code>gatherOp</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherOp ::</span> <span class="dt">ParseRule</span> m t
         <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Int</span>, <span class="dt">Operator</span> m t)
gatherOp (<span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> assoc prec) p) <span class="fu">=</span>
  <span class="dt">Just</span> (prec, <span class="dt">Infix</span> p assoc)
gatherOp _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>The <code>OperatorTable</code> is a list of list of <code>Operators</code>, where the <code>Operator</code>s in the inner lists all have the same precedence, and the outer list is sorted by descending order of the precedence.</p>
<p>Our function signature is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createTable ::</span> [(<span class="dt">Int</span>, <span class="dt">Operator</span> m a)]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
createTable os <span class="fu">=</span> 
  <span class="fu">...</span></code></pre></div>
<p>We can sort the our list by descending precendence by using <code>sortOn</code> from <code>Data.List</code>. We’ll also use <code>Down</code> from <code>Data.Ord</code> to get a descending sort.</p>
<p>So far we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span> (sortOn)
<span class="kw">import </span><span class="dt">Data.Ord</span>  (<span class="dt">Down</span>(..))

<span class="ot">createTable ::</span> [(<span class="dt">Int</span>, <span class="dt">Operator</span> m a)]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
createTable os <span class="fu">=</span> 
    <span class="fu">...</span> <span class="fu">.</span>
    sortOn (<span class="dt">Down</span> <span class="fu">.</span> fst) <span class="fu">$</span>
    os</code></pre></div>
<p>Before <code>sortOn</code> was added we would have had to have used <code>sortBy (comparing (Down . fst))</code>. The behaviour is the same, but <code>sortOn</code> is faster.</p>
<p>Now we need to group the entries with the same precedence.</p>
<p>We can use <code>groupBy</code> for this. It groups adjacent elements using a custom equality test. The adjacency is handled already because we just sorted the list, so we need to check for equal precedences. We can use <code>on</code> from <code>Data.Function</code> to help with this.</p>
<p>We’re almost there:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>     (sortBy, groupBy)
<span class="kw">import </span><span class="dt">Data.Ord</span>      (comparing, <span class="dt">Down</span>(..))
<span class="kw">import </span><span class="dt">Data.Function</span> (on)


<span class="ot">createTable ::</span> [(<span class="dt">Int</span>, <span class="dt">Operator</span> m a)]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
createTable os <span class="fu">=</span> 
    <span class="fu">...</span> <span class="fu">.</span>
    <span class="co">-- we now have [[(Int, Operator m a)]]</span>
    groupBy ((<span class="fu">==</span>) <span class="ot">`on`</span> fst) <span class="fu">.</span>
    sortBy (comparing (<span class="dt">Down</span> <span class="fu">.</span> fst)) <span class="fu">$</span>
    os</code></pre></div>
<p>We can now get rid of the precedence information and eta-reduce the function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createTable ::</span> [(<span class="dt">Int</span>, <span class="dt">Operator</span> m a)]
              <span class="ot">-&gt;</span> <span class="dt">OperatorTable</span> m a
createTable <span class="fu">=</span>
    fmap (fmap snd) <span class="fu">.</span>
    groupBy ((<span class="fu">==</span>) <span class="ot">`on`</span> fst) <span class="fu">.</span>
    sortBy (comparing (<span class="dt">Down</span> <span class="fu">.</span> fst))</code></pre></div>
<p>and we have a snazy little pipeline that doesn’t look to be doing too much in the way of redundant work.</p>
<p>If you haven’t had a browse through the <code>base</code> package in a while, it’s worth doing every now and then - there’s lots of neat stuff in there, and if it’s been a while you might spot some new functions (or new uses for old and familiar functions).</p>
<p>Now we can use all of the above to build a parser from the rules.</p>
<p>We gather the regular parsers together into a parser for non-operators, we gather the operator parsers into an <code>OperatorTable</code>, and we use <code>buildExpressionParser</code> to combine them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkParser ::</span> <span class="dt">TokenParsing</span> m
         <span class="ot">=&gt;</span> [<span class="dt">ParseRule</span> m t]
         <span class="ot">-&gt;</span> m t
mkParser rules <span class="fu">=</span>
  <span class="kw">let</span>
    parseRegular <span class="fu">=</span>
      (<span class="fu">&lt;|&gt;</span> parens parseTerm) <span class="fu">.</span>
      asum <span class="fu">.</span>
      mapMaybe gatherRegular <span class="fu">$</span>
      rules
    tables <span class="fu">=</span>
      createTable <span class="fu">.</span>
      mapMaybe gatherOp <span class="fu">$</span>
      rules
    parseTerm <span class="fu">=</span>
      buildExpressionParser tables parseRegular
  <span class="kw">in</span>
    parseTerm</code></pre></div>
<h2 id="putting-this-to-use-with-i">Putting this to use with <em>I</em></h2>
<p>We’re still working with a token parser, so we’ll define a style for operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">operatorStyle ::</span> <span class="dt">TokenParsing</span> m
              <span class="ot">=&gt;</span> <span class="dt">IdentifierStyle</span> m
operatorStyle <span class="fu">=</span>
    <span class="dt">IdentifierStyle</span> {
      _styleName              <span class="fu">=</span> <span class="st">&quot;operator&quot;</span>
    , _styleStart             <span class="fu">=</span> _styleLetter operatorStyle
    , _styleLetter            <span class="fu">=</span> oneOf <span class="st">&quot;:!#$%&amp;*+./&lt;=&gt;?@\\^|-~&quot;</span>
    , _styleReserved          <span class="fu">=</span> HS.fromList reservedOperators
    , _styleHighlight         <span class="fu">=</span> <span class="dt">Operator</span>
    , _styleReservedHighlight <span class="fu">=</span> <span class="dt">ReservedOperator</span>
    }
  <span class="kw">where</span>
    reservedOperators <span class="fu">=</span>
      [<span class="st">&quot;+&quot;</span>, <span class="st">&quot;-&quot;</span>, <span class="st">&quot;*&quot;</span>, <span class="st">&quot;^&quot;</span>]</code></pre></div>
<p>and our usual helper function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reservedOperator ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
                 <span class="ot">=&gt;</span> <span class="dt">String</span>
                 <span class="ot">-&gt;</span> m ()
reservedOperator <span class="fu">=</span>
  reserve operatorStyle</code></pre></div>
<p>From there, we define a parse for integer literals:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmInt ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTmInt <span class="fu">=</span>
  (<span class="dt">TmInt</span> <span class="fu">.</span> fromInteger) <span class="fu">&lt;$&gt;</span> integer <span class="fu">&lt;?&gt;</span> <span class="st">&quot;Int&quot;</span></code></pre></div>
<p>and parsers for all of operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTmAdd ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>)
parseTmAdd <span class="fu">=</span>
  <span class="dt">TmAdd</span> <span class="fu">&lt;$</span> reservedOperator <span class="st">&quot;+&quot;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;+&quot;</span>

<span class="ot">parseTmSub ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>)
parseTmSub <span class="fu">=</span>
  <span class="dt">TmSub</span> <span class="fu">&lt;$</span> reservedOperator <span class="st">&quot;-&quot;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;-&quot;</span>

<span class="ot">parseTmMul ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>)
parseTmMul <span class="fu">=</span>
  <span class="dt">TmMul</span> <span class="fu">&lt;$</span> reservedOperator <span class="st">&quot;*&quot;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;*&quot;</span>

<span class="ot">parseTmExp ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
           <span class="ot">=&gt;</span> m (<span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="ot">-&gt;</span> <span class="dt">Term</span>)
parseTmExp <span class="fu">=</span>
  <span class="dt">TmExp</span> <span class="fu">&lt;$</span> reservedOperator <span class="st">&quot;^&quot;</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;^&quot;</span></code></pre></div>
<p>We package these up into our new <code>ParseRule</code> data structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTermRules ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
               <span class="ot">=&gt;</span> [<span class="dt">ParseRule</span> m <span class="dt">Term</span>]
parseTermRules <span class="fu">=</span>
  [ <span class="dt">ParseRegular</span> parseTmInt
  , <span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">6</span>) parseTmAdd
  , <span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">6</span>) parseTmSub
  , <span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">7</span>) parseTmMul
  , <span class="dt">ParseOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocRight</span> <span class="dv">8</span>) parseTmExp
  ]</code></pre></div>
<p>with precedence and associativity information stolen from Haskell, and then we build our parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseTerm ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
          <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTerm <span class="fu">=</span>
  mkParser parseTermRules <span class="fu">&lt;?&gt;</span> <span class="st">&quot;term&quot;</span></code></pre></div>
<p>We than have the option of smothering this in doctests.</p>
<p>I’d be a little more cautious with that recommendation if I thought there was going to be a high rate of churn for these examples. We won’t be expecting anything that parses now to stop parsing when we add orthogonal features to our language, so we won’t have to update these examples unless we’ve broken something.</p>
<p>With that in mind, lets go nuts:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | The parser for terms of the I language.</span>
<span class="fu">--</span>
<span class="co">-- This function is built from the contents of 'parseTermRules',</span>
<span class="co">-- with added support for parentheses.</span>
<span class="fu">--</span>
<span class="co">-- We can parse all of the simple forms of the terms:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3&quot;</span>
<span class="co">-- Success (TmInt 3)</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;2 + 5&quot;</span>
<span class="co">-- Success (TmAdd (TmInt 2) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;2 - 5&quot;</span>
<span class="co">-- Success (TmSub (TmInt 2) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;2 * 5&quot;</span>
<span class="co">-- Success (TmMul (TmInt 2) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;2 ^ 5&quot;</span>
<span class="co">-- Success (TmExp (TmInt 2) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- The left associative operators group to the left:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 - 2 + 5&quot;</span>
<span class="co">-- Success (TmAdd (TmSub (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- So brackets grouping things on the left are redundant:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;(3 - 2) + 5&quot;</span>
<span class="co">-- Success (TmAdd (TmSub (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- We need brackets if we want to group things on the right:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 - (2 + 5)&quot;</span>
<span class="co">-- Success (TmSub (TmInt 3) (TmAdd (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- The right associative operator groups to the right:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 ^ 2 ^ 5&quot;</span>
<span class="co">-- Success (TmExp (TmInt 3) (TmExp (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- So brackets grouping things on the right are redundant:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 ^ (2 ^ 5)&quot;</span>
<span class="co">-- Success (TmExp (TmInt 3) (TmExp (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- We need brackets if we want to group things on the left:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;(3 ^ 2) ^ 5&quot;</span>
<span class="co">-- Success (TmExp (TmExp (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- Multiplication binds more tightly than addition:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 * 2 + 5&quot;</span>
<span class="co">-- Success (TmAdd (TmMul (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 + 2 * 5&quot;</span>
<span class="co">-- Success (TmAdd (TmInt 3) (TmMul (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- So we need to use brackets multiply by the sum of two terms:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 * (2 + 5)&quot;</span>
<span class="co">-- Success (TmMul (TmInt 3) (TmAdd (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;(3 + 2) * 5&quot;</span>
<span class="co">-- Success (TmMul (TmAdd (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- Exponentiation binds more tightly than multiplication:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 ^ 2 * 5&quot;</span>
<span class="co">-- Success (TmMul (TmExp (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 * 2 ^ 5&quot;</span>
<span class="co">-- Success (TmMul (TmInt 3) (TmExp (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- So we need to use brackets if the exponent or the power is a product (or sum) of two terms:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;3 ^ (2 * 5)&quot;</span>
<span class="co">-- Success (TmExp (TmInt 3) (TmMul (TmInt 2) (TmInt 5)))</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;(3 * 2) ^ 5&quot;</span>
<span class="co">-- Success (TmExp (TmMul (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="fu">--</span>
<span class="co">-- Nonsense is still rejected:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;potato&quot;</span>
<span class="co">-- Failure (interactive):1:1: error: expected: term</span>
<span class="co">-- potato&lt;EOF&gt;</span>
<span class="co">-- ^</span>
<span class="fu">--</span>
<span class="co">-- Even if you try to hide it in brackets:</span>
<span class="co">-- &gt;&gt;&gt; parse parseTerm &quot;((potato))&quot;</span>
<span class="co">-- Failure (interactive):1:3: error: expected: operator</span>
<span class="co">-- ((potato))&lt;EOF&gt;</span>
<span class="co">--   ^</span>
<span class="ot">parseTerm ::</span> (<span class="dt">Monad</span> m, <span class="dt">TokenParsing</span> m)
          <span class="ot">=&gt;</span> m <span class="dt">Term</span>
parseTerm <span class="fu">=</span>
  mkParser parseTermRules <span class="fu">&lt;?&gt;</span> <span class="st">&quot;term&quot;</span></code></pre></div>
<h1 id="pretty-printing-i">Pretty Printing <em>I</em></h1>
<p>When it comes to pretty printing, we’d really like to be able to print out our terms - so that we can parse them back in again and get the original term - with the minimal number of brackets required</p>
<p>In fact, we should be able to flip our doc tests from the parse around and get the same results, except not including the results with redundant brackets or potatoes.</p>
<p>That’s what we’ll work towards.</p>
<h2 id="the-obligatory-helper-functions">The obligatory helper functions</h2>
<p>We’re going to create a data type for pretty printing rules, and it’s going to be similar to <code>ParseRule</code> from earlier:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PrettyRule</span> a <span class="fu">=</span>
    <span class="dt">PrettyRegular</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>)
  <span class="fu">|</span> <span class="dt">PrettyOp</span> <span class="dt">OperatorInfo</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, a)) (<span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span>)</code></pre></div>
<p>The <code>PrettyRegular</code> variant is for everything other than operators, and it pretty prints <code>a</code> if the rule matches. The <code>PrettyOp</code> variant is for the operators, and includes the precedence and associativity information for the operator, a matching function tat returns the arguments to the operator, and a pretty printing function for the operator that requires that both arguments are pretty printed before it is used.</p>
<p>We’ll be dealing with the regular and operator pretty printers separately, so again we’ll need functions to partition the two types of rules.</p>
<p>For the regular pretty printing rules, we gather the pretty printers into a <code>Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherRegular ::</span> a
              <span class="ot">-&gt;</span> <span class="dt">PrettyRule</span> a
              <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
gatherRegular t (<span class="dt">PrettyRegular</span> f) <span class="fu">=</span>
  f t
gatherRegular _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>so that we can use <code>mapMaybe</code> over the rules to get hold of the regular rules on their own.</p>
<p>The pretty printing rules for operators require a couple of helper functions.</p>
<p>We need a function that will search through the rules to find the <code>OperatorInfo</code> for a term, if it exists:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findOperatorInfo ::</span> [<span class="dt">PrettyRule</span> a]
                 <span class="ot">-&gt;</span> a
                 <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>
findOperatorInfo rules tm <span class="fu">=</span>
    asum <span class="fu">.</span>
    fmap (checkOperatorInfo tm) <span class="fu">$</span>
    rules
  <span class="kw">where</span>
    checkOperatorInfo t (<span class="dt">PrettyOp</span> info match _) <span class="fu">=</span>
      info <span class="fu">&lt;$</span> match t
    checkOperatorInfo _ _ <span class="fu">=</span>
      <span class="dt">Nothing</span></code></pre></div>
<p>We also need a function to determine if the argument to an operator needs parentheses.</p>
<p>First we add a data type to describe the arguments to an operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Argument</span> <span class="fu">=</span>
    <span class="dt">ArgumentLeft</span>
  <span class="fu">|</span> <span class="dt">ArgumentRight</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<p>and a function that works out if an argument is in the right position for it to associate:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argumentAssociates ::</span> <span class="dt">Argument</span>
                   <span class="ot">-&gt;</span> <span class="dt">Assoc</span>
                   <span class="ot">-&gt;</span> <span class="dt">Bool</span>
argumentAssociates <span class="dt">ArgumentLeft</span> <span class="dt">AssocLeft</span> <span class="fu">=</span>
  <span class="dt">True</span>
argumentAssociates <span class="dt">ArgumentRight</span> <span class="dt">AssocRight</span> <span class="fu">=</span>
  <span class="dt">True</span>
argumentAssociates _ _ <span class="fu">=</span>
  <span class="dt">False</span></code></pre></div>
<p>We could have used <code>Assoc</code> here and not written <code>Argument</code>, but new data types and functions are cheap and I didn’t want to leave the door open to passing in <code>AssocNone</code> by accident in the future and getting unexpected results.</p>
<p>Now we’re ready for the <code>needsParens</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">needsParens ::</span> <span class="dt">Argument</span>
            <span class="ot">-&gt;</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p>which takes the position of the argument to an operator, the operator information for the current operator and for the argument to the operator - the result of <code>findOperatorInfo</code> - and returns a Boolean indicating whether we should add parentheses or not.</p>
<p>If the argument wasn’t an operator, then we don’t need parentheses:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">needsParens _ _ <span class="dt">Nothing</span> <span class="fu">=</span>
  <span class="dt">False</span></code></pre></div>
<p>Otherwise, based on some playing around with doctests, we need parentheses if:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">needsParens arg info (<span class="dt">Just</span> argInfo) <span class="fu">=</span></code></pre></div>
<p>the operator has no associativity,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  assoc info <span class="fu">==</span> <span class="dt">AssocNone</span> <span class="fu">||</span></code></pre></div>
<p>the argument has a lower precedence than the current operator,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  precedence argInfo <span class="fu">&lt;</span> precedence info <span class="fu">||</span></code></pre></div>
<p>or if the argument has the same precedence as the current operator but the argument is not in the right position for it to associate</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  (precedence argInfo <span class="fu">==</span> precedence info <span class="fu">&amp;&amp;</span> not (argumentAssociates arg (assoc info)))</code></pre></div>
<p>Now we can prepare a pretty printer for operators.</p>
<p>Thanks to the laziness of Haskell, we can pass in the pretty printer for terms that we’re trying to build. We also pass in the result of <code>findOperatorInfo</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">gatherOp ::</span> a
         <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Doc</span>)
         <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>)
         <span class="ot">-&gt;</span> <span class="dt">PrettyRule</span> a
         <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span></code></pre></div>
<p>If we’re given an operator, we check to see if it matches the rule we’re currently processing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gatherOp t pretty findInfo (<span class="dt">PrettyOp</span> i match printer) <span class="fu">=</span> <span class="kw">do</span>
  (t1, t2) <span class="ot">&lt;-</span> match t</code></pre></div>
<p>We then build little functions that will add parentheses if they are needed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">let</span> addParens b <span class="fu">=</span>
    <span class="kw">if</span> b <span class="kw">then</span> parens <span class="kw">else</span> id
  <span class="kw">let</span> p1 <span class="fu">=</span>
    addParens <span class="fu">.</span>
    needsParens <span class="dt">ArgumentLeft</span> i <span class="fu">.</span>
    findInfo <span class="fu">$</span>
    t1
  <span class="kw">let</span> p2 <span class="fu">=</span>
    addParens <span class="fu">.</span>
    needsParens <span class="dt">ArgumentRight</span> i <span class="fu">.</span>
    findInfo <span class="fu">$</span>
    t2</code></pre></div>
<p>and use them in conjunction with our overall pretty printer and the function that does the printing for the current operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  return <span class="fu">$</span> printer (p1 <span class="fu">.</span> pretty <span class="fu">$</span> t1) (p2 <span class="fu">.</span> pretty <span class="fu">$</span> t2)</code></pre></div>
<p>In the case whre we’re not given an operator, this function isn’t for us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">gatherOp _ _ _ _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>We can use the above functions to build a pretty printing function from the pretty printing rules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkPretty ::</span> [<span class="dt">PrettyRule</span> a]
         <span class="ot">-&gt;</span> a
         <span class="ot">-&gt;</span> <span class="dt">Doc</span>
mkPretty rules <span class="fu">=</span>
  <span class="kw">let</span>
    prettyRegular tm <span class="fu">=</span>
      asum <span class="fu">.</span>
      fmap (gatherRegular tm) <span class="fu">$</span>
      rules
    findInfo <span class="fu">=</span>
      findOperatorInfo rules
    prettyOp tm <span class="fu">=</span>
      asum <span class="fu">.</span>
      fmap (gatherOp tm prettyTerm findInfo) <span class="fu">$</span>
      rules
    prettyTerm tm <span class="fu">=</span>
      fromMaybe (text <span class="st">&quot;???&quot;</span>) <span class="fu">.</span>
      asum <span class="fu">.</span> 
      fmap (<span class="fu">$</span> tm) <span class="fu">$</span>
      [ prettyRegular , prettyOp ]
  <span class="kw">in</span>
    prettyTerm</code></pre></div>
<p>We’re building the pretty printer out of the pretty printers for regular terms and the pretty printer for operators. The pretty printer for regular terms shouldn’t be too surprising at this point.</p>
<p>The only trick with the pretty printer for the operators is that we assemble some functions and pass them in to <code>gatherOp</code>, so that we don’t need to pass in all the rules.</p>
<p>That should be all we need, so it’s time to press on.</p>
<h2 id="putting-this-to-use-with-i-1">Putting this to use with <em>I</em></h2>
<p>The heavy lifting has already been done, so we just need to put together the pieces for <em>I</em>.</p>
<p>We have one fairly usually looking pretty printer for <code>TmInt</code>, making use of the <code>int</code> helper from <code>ansi-wl-pprint</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Text.Parser.Token.Highlight</span>  (<span class="dt">Highlight</span> (..))
<span class="kw">import           </span><span class="dt">Text.Trifecta.Highlight</span>      (withHighlight)

<span class="ot">prettyTmInt ::</span> <span class="dt">Term</span>
             <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Doc</span>
prettyTmInt (<span class="dt">TmInt</span> i) <span class="fu">=</span>
  <span class="dt">Just</span> <span class="fu">$</span> withHighlight <span class="dt">Number</span> (int i)
prettyTmInt _ <span class="fu">=</span>
  <span class="dt">Nothing</span></code></pre></div>
<p>We’re stealing the highlighting from <code>trifecta</code> again, since the parser we use for <code>TmInt</code> adds the <code>Number</code> highlight under the hood.</p>
<p>We also have a pair of functions for each of our operators. They’re all pretty similar in this instance, so we’ll only look at the code associated with <code>TmAdd</code>.</p>
<p>One of the functions checks that we’re dealing with the operator we’re interested in, and returns the arguments to the operator if that’s the case:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- |</span>
<span class="ot">matchTmAdd ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Term</span>, <span class="dt">Term</span>)
matchTmAdd (<span class="dt">TmAdd</span> tm1 tm2) <span class="fu">=</span>
  <span class="dt">Just</span> (tm1, tm2)
matchTmAdd _ <span class="fu">=</span>
  <span class="dt">Nothing</span>

<span class="dt">The</span> other functions pretty prints the operator, given that the arguments to the operator have already been pretty pritned<span class="fu">:</span>
<span class="co">-- |</span>
<span class="ot">prettyTmAdd ::</span> <span class="dt">Doc</span>
            <span class="ot">-&gt;</span> <span class="dt">Doc</span>
            <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyTmAdd d1 d2 <span class="fu">=</span>
  d1 <span class="fu">&lt;+&gt;</span> reservedOperator <span class="st">&quot;+&quot;</span> <span class="fu">&lt;+&gt;</span> d2</code></pre></div>
<p>Once we have these functions, we can build a list of the pretty printing rules with the same operator information that we used for the parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTermRules ::</span> [<span class="dt">PrettyRule</span> <span class="dt">Term</span>]
prettyTermRules <span class="fu">=</span>
  [ <span class="dt">PrettyRegular</span> prettyTmInt
  , <span class="dt">PrettyOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">6</span>) matchTmAdd prettyTmAdd
  , <span class="dt">PrettyOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">6</span>) matchTmSub prettyTmSub
  , <span class="dt">PrettyOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocLeft</span> <span class="dv">7</span>) matchTmMul prettyTmMul
  , <span class="dt">PrettyOp</span> (<span class="dt">OperatorInfo</span> <span class="dt">AssocRight</span> <span class="dv">8</span>) matchTmExp prettyTmExp
  ]</code></pre></div>
<p>Then we combine them all into a pretty printing function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prettyTerm ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyTerm <span class="fu">=</span>
  mkPretty prettyTermRules</code></pre></div>
<p>As usual, we then spray doctests all over the place:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | The pretty printer for terms of the I language.</span>
<span class="fu">--</span>
<span class="co">-- This function is built from the contents of 'prettyTermRules'.</span>
<span class="co">-- It will print &quot;???&quot; if none of the rules apply - which should never happen.</span>
<span class="fu">--</span>
<span class="co">-- We can print all of the simple forms of the terms:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmInt 3)</span>
<span class="co">-- 3</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmInt 2) (TmInt 5))</span>
<span class="co">-- 2 + 5</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmSub (TmInt 2) (TmInt 5))</span>
<span class="co">-- 2 - 5</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmMul (TmInt 2) (TmInt 5))</span>
<span class="co">-- 2 * 5</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmExp (TmInt 2) (TmInt 5))</span>
<span class="co">-- 2 ^ 5</span>
<span class="fu">--</span>
<span class="co">-- The left associative operators don't need extra brackets when things are grouped to the left:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmAdd (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- 3 + 2 + 5</span>
<span class="fu">--</span>
<span class="co">-- But they do need brackets when the grouping branches to the right:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmInt 3) (TmAdd (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 + (2 + 5)</span>
<span class="fu">--</span>
<span class="co">-- The right associative operators don't need extra brackets when things are grouped to the right:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmExp (TmInt 3) (TmExp (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 ^ 2 ^ 5</span>
<span class="fu">--</span>
<span class="co">-- But they do need brackets when the grouping branches to the left:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmExp (TmExp (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- (3 ^ 2) ^ 5</span>
<span class="fu">--</span>
<span class="co">-- Multiplication binds more tightly than addition, so we don't want any brackets if we multiply and then add:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmMul (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- 3 * 2 + 5</span>
<span class="fu">--</span>
<span class="co">-- If we are adding and then multiplying, we'll want brackets:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmMul (TmInt 3) (TmAdd (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 * (2 + 5)</span>
<span class="fu">--</span>
<span class="co">-- This is true regardless of whether the addition is on the left or the right:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmAdd (TmInt 3) (TmMul (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 + 2 * 5</span>
<span class="fu">--</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmMul (TmAdd (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- (3 + 2) * 5</span>
<span class="fu">--</span>
<span class="co">-- Exponentiation binds more tightly than multiplication, so we don't want any brackets if exponentiate and then multiply:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmMul (TmExp (TmInt 3) (TmInt 2)) (TmInt 5))</span>
<span class="co">-- 3 ^ 2 * 5</span>
<span class="fu">--</span>
<span class="co">-- If we're multiplying and then exponentiating, we'll want brackets:</span>
<span class="co">-- &gt;&gt;&gt; render 0.5 40 prettyTerm (TmExp (TmInt 3) (TmMul (TmInt 2) (TmInt 5)))</span>
<span class="co">-- 3 ^ (2 * 5)</span>
<span class="ot">prettyTerm ::</span> <span class="dt">Term</span>
           <span class="ot">-&gt;</span> <span class="dt">Doc</span>
prettyTerm <span class="fu">=</span>
  mkPretty prettyTermRules</code></pre></div>
<p>Again, like with <a href="n.html"><em>N</em></a>, we don’t need to change the tests or the REPL, and they both continue to work.</p>
<p>It’s always worth having a play around in the REPL at this point, as something somewhere between a double-check and a victory lap:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">*</span> <span class="dv">5</span>
<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">*</span> <span class="dv">5</span> <span class="fu">==&gt;</span> <span class="dv">17</span>
<span class="fu">&gt;</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="dv">5</span>
(<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">*</span> <span class="dv">5</span> <span class="fu">==&gt;</span> <span class="dv">25</span>
<span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>
<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">==&gt;</span> <span class="dv">6</span>
<span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>)
<span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span>) <span class="fu">==&gt;</span> <span class="dv">6</span></code></pre></div>
<h1 id="cranking-up-the-testing">Cranking up the testing</h1>
<p>There’s a problem though - <code>needsParens</code> is incorrect.</p>
<p>A <a href="https://www.reddit.com/r/haskell/comments/4pdfkx/symbolic_computer_algebra_print_tree/">post on reddit</a> covered some similar ground, but with different code for the equivalent of <code>needsParens</code>.</p>
<p>Clearly it’s time for more <code>QuickCheck</code> in order to sort out what is going on.</p>
<p>We’re going to build generators for a set of operators, and use that to generate arbitrary expressions. Once we have that, we’ll check that pretty printing the expression and parsing it back in returns the original expression.</p>
<p>We’ll also check that we either a parsing failure or a different expression if we delete any matched pair of parentheses from the pretty printed string in the middle of that round trip test.</p>
<p>That seems like it should make sure that we’re putting parentheses in the right places, and that we’re not adding any redundant parentheses.</p>
<p>To start with, we’ll need an <code>Arbitrary</code> instance for <code>OperatorInfo</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">OperatorInfo</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span>
    <span class="kw">let</span>
      genAssoc <span class="fu">=</span>
        elements [<span class="dt">AssocNone</span>, <span class="dt">AssocLeft</span>, <span class="dt">AssocRight</span>]
      genPrecedence <span class="fu">=</span>
        choose (<span class="dv">0</span>, <span class="dv">9</span>)
    <span class="kw">in</span>
      <span class="dt">OperatorInfo</span> <span class="fu">&lt;$&gt;</span> genAssoc <span class="fu">&lt;*&gt;</span> genPrecedence
  shrink (<span class="dt">OperatorInfo</span> a p) <span class="fu">=</span>
    fmap (<span class="dt">OperatorInfo</span> a) (shrink p)</code></pre></div>
<p>We’re going to create some code to generate a table of operators.</p>
<p>We’ll use a map from <code>String</code>s to <code>OperatorInfo</code>, wrapped in a <code>newtype</code> so that we can write an <code>Arbitrary</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>

<span class="kw">newtype</span> <span class="dt">OperatorMap</span> <span class="fu">=</span> <span class="dt">OperatorMap</span> {
<span class="ot">    getOperatorMap ::</span> <span class="dt">M.Map</span> <span class="dt">String</span> <span class="dt">OperatorInfo</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>The entries in the map are created from one of a number of single character names and a arbitrary <code>OperatorInfo</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genOperatorEntry ::</span> <span class="dt">Gen</span> (<span class="dt">String</span>, <span class="dt">OperatorInfo</span>)
genOperatorEntry <span class="fu">=</span>
  (,) <span class="fu">&lt;$&gt;</span> elements (map pure <span class="st">&quot;+=*&amp;^%$#@!&quot;</span>) <span class="fu">&lt;*&gt;</span> arbitrary</code></pre></div>
<p>The <code>OperatorMap</code> is built from a non-empty list of these operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genOperatorMap ::</span> <span class="dt">Gen</span> <span class="dt">OperatorMap</span>
genOperatorMap <span class="fu">=</span>
  fmap (<span class="dt">OperatorMap</span> <span class="fu">.</span> M.fromList) (listOf1 genOperatorEntry)</code></pre></div>
<p>For the shrinking, we don’t want to shrink the operator names in the entries:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkOperatorEntry ::</span> (<span class="dt">String</span>, <span class="dt">OperatorInfo</span>)
                    <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">OperatorInfo</span>)]
shrinkOperatorEntry (s, oi) <span class="fu">=</span>
  fmap (\oi' <span class="ot">-&gt;</span> (s, oi')) (shrink oi)</code></pre></div>
<p>and we can use the <code>shrinkList</code> helper to build the shrinking function for the whole map:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkOperatorMap ::</span> <span class="dt">OperatorMap</span>
                  <span class="ot">-&gt;</span> [<span class="dt">OperatorMap</span>]
shrinkOperatorMap (<span class="dt">OperatorMap</span> m) <span class="fu">=</span>
  fmap (<span class="dt">OperatorMap</span> <span class="fu">.</span> M.fromList) <span class="fu">.</span>
  filter (not <span class="fu">.</span> null) <span class="fu">.</span>
  shrinkList shrinkOperatorEntry <span class="fu">.</span>
  M.toList <span class="fu">$</span>
  m</code></pre></div>
<p>Now we have what we need for an <code>Arbitrary</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">OperatorMap</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span>
    genOperatorMap
  shrink <span class="fu">=</span>
    shrinkOperatorMap</code></pre></div>
<p>Thus armed, we create a generic expression type. We use the lowest-effort form of generics here: <code>String</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span>
    <span class="dt">Const</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Op</span> <span class="dt">String</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>We are going to need support for generation, pretty printing and parsing of <code>Expr</code>.</p>
<p>We can use the <code>OperatorMap</code> to generate these expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genExpr ::</span> <span class="dt">OperatorMap</span>
        <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Expr</span>
genExpr <span class="fu">=</span>
  sized <span class="fu">.</span>
  genExpr'

<span class="ot">genExpr' ::</span> <span class="dt">OperatorMap</span>
         <span class="ot">-&gt;</span> <span class="dt">Int</span>
         <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Expr</span>
genExpr' _ <span class="dv">0</span> <span class="fu">=</span>
    <span class="dt">Const</span> <span class="fu">&lt;$&gt;</span> arbitrary
genExpr' om<span class="fu">@</span>(<span class="dt">OperatorMap</span> m) s <span class="fu">=</span>
    oneof [
      <span class="dt">Const</span> <span class="fu">&lt;$&gt;</span> arbitrary
    , <span class="dt">Op</span> <span class="fu">&lt;$&gt;</span> elements (M.keys m) <span class="fu">&lt;*&gt;</span> child2 <span class="fu">&lt;*&gt;</span> child2
    ]
  <span class="kw">where</span>
    s2 <span class="fu">=</span> s <span class="ot">`div`</span> <span class="dv">2</span>
    child2 <span class="fu">=</span> genExpr' om s2</code></pre></div>
<p>and the shrinking function is straight-forward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shrinkExpr ::</span> <span class="dt">Expr</span>
           <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]
shrinkExpr (<span class="dt">Const</span> _) <span class="fu">=</span>
  []
shrinkExpr (<span class="dt">Op</span> s e1 e2) <span class="fu">=</span>
  e1 <span class="fu">:</span>
  e2 <span class="fu">:</span>
  fmap (\e1' <span class="ot">-&gt;</span> <span class="dt">Op</span> s e1' e2) (shrinkExpr e1) <span class="fu">++</span>
  fmap (\e2' <span class="ot">-&gt;</span> <span class="dt">Op</span> s e1 e2') (shrinkExpr e2)</code></pre></div>
<p>The <code>OperatorMap</code> can be turned into a pretty printer fairly mechanically:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toPrettyRules ::</span> <span class="dt">OperatorMap</span>
              <span class="ot">-&gt;</span> [<span class="dt">PrettyRule</span> <span class="dt">Expr</span>]
toPrettyRules (<span class="dt">OperatorMap</span> m) <span class="fu">=</span>
    intRule <span class="fu">:</span> map convertEntry (M.toList m)
  <span class="kw">where</span>
    intRule <span class="fu">=</span>
      <span class="dt">PrettyRegular</span> prettyInt
    prettyInt (<span class="dt">Const</span> i) <span class="fu">=</span>
      <span class="dt">Just</span> <span class="fu">$</span> int i
    prettyInt _ <span class="fu">=</span>
      <span class="dt">Nothing</span>
    convertEntry (s, oi) <span class="fu">=</span>
      <span class="dt">PrettyOp</span> oi (matchOp s) (prettyOp s)
    matchOp s (<span class="dt">Op</span> t e1 e2)
      <span class="fu">|</span> s <span class="fu">==</span> t <span class="fu">=</span> <span class="dt">Just</span> (e1, e2)
      <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>
    matchOp _ _ <span class="fu">=</span>
      <span class="dt">Nothing</span>
    prettyOp s d1 d2 <span class="fu">=</span>
      d1 <span class="fu">&lt;+&gt;</span> text s <span class="fu">&lt;+&gt;</span> d2

<span class="ot">mkExprPretty ::</span> <span class="dt">OperatorMap</span>
             <span class="ot">-&gt;</span> <span class="dt">Expr</span>
             <span class="ot">-&gt;</span> <span class="dt">Doc</span>
mkExprPretty m <span class="fu">=</span>
  mkPretty (toPrettyRules m)</code></pre></div>
<p>and the same is true with the parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toParserRules ::</span> <span class="dt">TokenParsing</span> m
              <span class="ot">=&gt;</span> <span class="dt">OperatorMap</span>
              <span class="ot">-&gt;</span> [<span class="dt">ParseRule</span> m <span class="dt">Expr</span>]
toParserRules (<span class="dt">OperatorMap</span> m) <span class="fu">=</span>
    intRule <span class="fu">:</span> map convertEntry (M.toList m)
  <span class="kw">where</span>
    intRule <span class="fu">=</span>
      <span class="dt">ParseRegular</span> parseInt
    parseInt <span class="fu">=</span>
      (<span class="dt">Const</span> <span class="fu">.</span> fromInteger) <span class="fu">&lt;$&gt;</span> integer
    convertEntry (s, oi) <span class="fu">=</span>
      <span class="dt">ParseOp</span> oi ((\s' <span class="ot">-&gt;</span> <span class="dt">Op</span> s') <span class="fu">&lt;$&gt;</span> symbol s)

<span class="ot">mkExprParser ::</span> (<span class="dt">TokenParsing</span> m)
             <span class="ot">=&gt;</span> <span class="dt">OperatorMap</span>
             <span class="ot">-&gt;</span> m <span class="dt">Expr</span>
mkExprParser m <span class="fu">=</span>
    mkParser (toParserRules m)
  <span class="kw">where</span></code></pre></div>
<p>At this point, we have the tools to write the property that checks that we can make a round trip through the pretty printer and then the parser:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propPrettyParse ::</span> <span class="dt">OperatorMap</span>
                <span class="ot">-&gt;</span> <span class="dt">Property</span>
propPrettyParse om <span class="fu">=</span>
  <span class="kw">let</span>
    parseExpr <span class="fu">=</span> mkExprParser om
    prettyExpr <span class="fu">=</span> mkExprPretty om
    roundTrip <span class="fu">=</span>
      parseFromString parseExpr <span class="fu">.</span>
      prettyToString <span class="fu">.</span>
      prettyExpr
  <span class="kw">in</span>
    forAllShrink (genExpr om) shrinkExpr <span class="fu">$</span> \expr <span class="ot">-&gt;</span>
      <span class="kw">case</span> roundTrip expr <span class="kw">of</span>
        <span class="dt">Left</span> _ <span class="ot">-&gt;</span> property <span class="dt">False</span>
        <span class="dt">Right</span> expr' <span class="ot">-&gt;</span> expr <span class="fu">===</span> expr'</code></pre></div>
<p>We’ll do some quick and dirty utility functions to find the positions of match pairs of parentheses in a string:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findParens ::</span> <span class="dt">String</span>
           <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]
findParens <span class="fu">=</span>
    (\(x,_,_) <span class="ot">-&gt;</span> x) <span class="fu">.</span> foldr f ([], [], <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="fu">.</span> reverse
  <span class="kw">where</span>
    f <span class="ch">'('</span> (done, opens, ix) <span class="fu">=</span>
      (done, ix <span class="fu">:</span> opens, ix <span class="fu">+</span> <span class="dv">1</span>)
    f <span class="ch">')'</span> (done, o <span class="fu">:</span> opens, ix) <span class="fu">=</span>
      ((o, ix) <span class="fu">:</span> done, opens, ix <span class="fu">+</span> <span class="dv">1</span>)
    f _ (done, opens, ix) <span class="fu">=</span>
      (done, opens, ix <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>and to remove those parentheses from a string:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">removeParens ::</span> <span class="dt">String</span>
             <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
             <span class="ot">-&gt;</span> <span class="dt">String</span>
removeParens str (s, e) <span class="fu">=</span>
  map fst <span class="fu">.</span>
  filter ((\i <span class="ot">-&gt;</span> i <span class="fu">/=</span> s <span class="fu">&amp;&amp;</span> i <span class="fu">/=</span> e) <span class="fu">.</span> snd) <span class="fu">.</span>
  zip str <span class="fu">$</span>
  [<span class="dv">0</span><span class="fu">..</span>]</code></pre></div>
<p>We can combine these to make something which produces a list of strings where each of the matched pairs of parentheses have been removed:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parenRemovals ::</span> <span class="dt">String</span>
                <span class="ot">-&gt;</span> [<span class="dt">String</span>]
parenRemovals s <span class="fu">=</span>
  map (removeParens s) <span class="fu">.</span>
  findParens <span class="fu">$</span>
  s</code></pre></div>
<p>This will return an empty list if there are no parentheses, and that’s fine for what we’re using it for.</p>
<p>Now we can test that we’re using the minimal number of parentheses. If that is the case, then removing a pair of parentheses will either cause the parsing to fail or will cause a change in what gets parsed back in:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">propPrettyParseParens ::</span> <span class="dt">OperatorMap</span>
                      <span class="ot">-&gt;</span> <span class="dt">Property</span>
propPrettyParseParens om <span class="fu">=</span>
  <span class="kw">let</span>
    parseExpr <span class="fu">=</span> 
      mkExprParser om
    prettyExpr <span class="fu">=</span> 
      mkExprPretty om
    roundTripsWithParensRemoved <span class="fu">=</span>
      fmap (parseFromString parseExpr) <span class="fu">.</span>
      parenRemovals <span class="fu">.</span>
      prettyToString <span class="fu">.</span>
      prettyExpr
  <span class="kw">in</span>
    forAllShrink (genExpr om) shrinkExpr <span class="fu">$</span> \expr <span class="ot">-&gt;</span>
      <span class="co">-- check all of the round-trips with a single pair</span>
      <span class="co">-- of parens removed</span>
      flip all (roundTripsWithParensRemoved expr) <span class="fu">$</span> \rt <span class="ot">-&gt;</span>
        <span class="kw">case</span> rt <span class="kw">of</span>
          <span class="dt">Left</span> _ <span class="ot">-&gt;</span>
            <span class="dt">True</span>
          <span class="dt">Right</span> expr' <span class="ot">-&gt;</span>
            expr <span class="fu">/=</span> expr'</code></pre></div>
<p>Let’s see how we go with these properties:</p>
<pre><code>common
  text
    pretty-parse round trip:         FAIL (0.03s)
      *** Failed! Falsifiable (after 15 tests and 4 shrinks):
      OperatorMap {getOperatorMap = fromList [(&quot;#&quot;,OperatorInfo {assoc = AssocLeft, precedence = 0}),(&quot;%&quot;,OperatorInfo {assoc = AssocLeft, precedence = 0}),(&quot;&amp;&quot;,OperatorInfo {assoc = AssocNone, precedence = 0})]}
      Op &quot;#&quot; (Op &quot;&amp;&quot; (Const (-4)) (Const 4)) (Const 10)
      Op &quot;#&quot; (Op &quot;&amp;&quot; (Const (-4)) (Const 4)) (Const 10) /= Op &quot;&amp;&quot; (Const (-4)) (Const 4)
    pretty-parse correct parens:   FAIL
      *** Failed! Falsifiable (after 20 tests and 9 shrinks):
      OperatorMap {getOperatorMap = fromList [(&quot;$&quot;,OperatorInfo {assoc = AssocNone, precedence = 0}),(&quot;=&quot;,OperatorInfo {assoc = AssocNone, precedence = 1})]}
      Op &quot;$&quot; (Op &quot;=&quot; (Const 3) (Const (-13))) (Const 1)</code></pre>
<p>Hmm, not well.</p>
<p>We can try shifting our code across to the code in the Reddit post, but since it didn’t mention the <code>AssocNone</code> case we’ll leave our handling of that alone:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">needsParens ::</span> <span class="dt">Argument</span>
            <span class="ot">-&gt;</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Bool</span>
needsParens _ _ <span class="dt">Nothing</span> <span class="fu">=</span>
  <span class="dt">False</span>
needsParens arg info (<span class="dt">Just</span> argInfo) <span class="fu">=</span>
  assoc argInfo <span class="fu">==</span> <span class="dt">AssocNone</span> <span class="fu">||</span> 
  ( precedence argInfo <span class="fu">&lt;=</span> precedence info <span class="fu">&amp;&amp;</span>
    ( precedence argInfo <span class="fu">/=</span> precedence info <span class="fu">||</span> 
      assoc info <span class="fu">/=</span> assoc argInfo <span class="fu">||</span> 
      not (argumentAssociates arg (assoc info))
    )
  )</code></pre></div>
<p>This improves things quite a bit:</p>
<pre><code>common
  text
    pretty-parse round trip:         OK (0.05s)
      +++ OK, passed 100 tests.
    pretty-parse correct parens:   FAIL (0.01s)
      *** Failed! Falsifiable (after 9 tests and 8 shrinks):
      OperatorMap {getOperatorMap = fromList [(&quot;$&quot;,OperatorInfo {assoc = AssocNone, precedence = 0}),(&quot;%&quot;,OperatorInfo {assoc = AssocNone, precedence = 1})]}
      Op &quot;$&quot; (Const (-8)) (Op &quot;%&quot; (Const 8) (Const 0))</code></pre>
<p>except we’re putting too many parentheses in for the <code>AssocNone</code> case when other operators of the same precedence are in play.</p>
<p>It turns out that the code from the Reddit post handles the <code>AssocNone</code> case as it stands:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">needsParens ::</span> <span class="dt">Argument</span>
            <span class="ot">-&gt;</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">OperatorInfo</span>
            <span class="ot">-&gt;</span> <span class="dt">Bool</span>
needsParens _ _ <span class="dt">Nothing</span> <span class="fu">=</span>
  <span class="dt">False</span>
needsParens arg info (<span class="dt">Just</span> argInfo) <span class="fu">=</span>
  precedence argInfo <span class="fu">&lt;=</span> precedence info <span class="fu">&amp;&amp;</span>
  ( precedence argInfo <span class="fu">/=</span> precedence info <span class="fu">||</span> 
    assoc info <span class="fu">/=</span> assoc argInfo <span class="fu">||</span> 
    not (argumentAssociates arg (assoc info))
  )</code></pre></div>
<p>Now the tests pass, and there is much rejoicing:</p>
<pre><code>common
  text
    pretty-parse round trip:         OK
      +++ OK, passed 100 tests.
    pretty-parse correct parens:   OK
      +++ OK, passed 100 tests.</code></pre>
<p>There was also a link in that Reddit thread to <a href="http://www.cs.tufts.edu/~nr/pubs/unparse-abstract.html">a paper on unparsing</a> that is also worth a read. On one hand, it would have been nice to have had the right search terms to find that earlier. On the other hand, we now have some nice tests around our unparsing utilities.</p>
<p>Now it’s definitely time to look at combining various languages. <a href="nb.html">Read on!</a></p>
<h1 id="exercises-for-the-adventurous">Exercises for the adventurous</h1>
<ul>
<li>Add the logic operators for conjunction and disjunction to <em>B</em> , using <code>&amp;&amp;</code> and <code>||</code> as infix operators.
<ul>
<li>Make sure that the semantics cause them to short-circuit appropriately.</li>
</ul></li>
<li>Add the logic operator for negation to <em>B</em> using <code>~</code> as a prefix operator.</li>
</ul>
    </div>
    
    <div class="panel-footer">
        <h5>Posted on May 27, 2016 </h5>
    </div>
    
</div>

            <div class="row">
                <div class="col-md-5"> Site proudly generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> </div>
                <div class="col-md-7">
                    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
                    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>
                </div>
            </div>
        </div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59162164-1', 'auto');
  ga('send', 'pageview');
</script>

    </body>
</html>
