\documentclass[aspectration=169]{beamer}

\title{Little Languages}
\author{Dave Laing}
\date{YOW! Lambda Jam 2016}

\usepackage[normalem]{ulem}
\usepackage{color}
\usepackage{minted}
\usepackage{prftree}

\setbeamertemplate{navigation symbols}{}

\AtBeginSection[]%
{%
\begin{frame}[plain]%
  \begin{center}%
    \usebeamerfont{section title}\usebeamercolor[fg]{section title}\insertsection%
  \end{center}%
\end{frame}%
}

\begin{document}

\begin{frame}
\maketitle
\end{frame}

\section{Introduction}

\begin{frame}[c]
  \begin{center}
    Haskell is great for writing DSLs.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
    There are some techniques and libraries out there that can really help.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
    Theory helps more.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
    Get comfortable with the theory and reap the awesome.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
   Bonus points: Approach the modularity of the theory. 
  \end{center}
\end{frame}

\section{B}

\begin{frame}[c]
  \begin{center}
Terms (maths)
  \end{center}
  \begin{displaymath}
    \begin{aligned}
t =& \ \text{true} \\
  |& \ \text{false}  \\
  |& \ \text{if $t$ then $t$ else $t$}
    \end{aligned}
  \end{displaymath}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
Terms (Haskell)
  \end{center}
  \begin{minted}{haskell}
data Term =
    TmTrue
  | TmFalse
  | TmIf Term Term Term
  \end{minted}
\end{frame} 

\section{Extending B (part 1)}

\begin{frame}[fragile]
  \begin{center}
    An extension
  \end{center}
  \begin{minted}{haskell}
tmNot :: Term -> Term
tmNot x = TmIf x TmFalse TmTrue

tmAnd x y :: Term -> Term -> Term
tmAnd x y = TmIf x y False

tmOr x y :: Term -> Term -> Term
tmOr x y = TmIf x True y
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{center}
    An extension
  \end{center}
  \begin{minted}{haskell}
data Term =
    ...
  | TmNot Term
  | TmAnd Term Term
  | TmOr Term Term
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{center}
An evaluator (?)
  \end{center}
  \begin{minted}{haskell}
eval :: Term 
     -> Term
eval TmTrue = TmTrue
eval TmFalse = TmFalse
eval (TmIf t1 t2 t3) =
  case eval t1 of
    TmTrue -> t2
    TmFalse -> t3
  \end{minted}
\end{frame} 

\begin{frame}[c]
  \begin{center}
Is this correct?
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
What does correctness mean here?
  \end{center}
\end{frame}

\section{Values}

\begin{frame}[c]
  \begin{center}
   Values are the terms that don't need evaluation. 
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
Values (maths)
  \end{center}
  \begin{displaymath}
    \begin{aligned}
v =& \ \text{true} \\
  |& \ \text{false}  \\
    \end{aligned}
  \end{displaymath}
\end{frame}

\begin{frame}[c]
  \begin{center}
Values (maths)
  \end{center}
  \begin{displaymath}
    \prftree[r]{V-True}{\text{true val}}
  \end{displaymath}
  \begin{displaymath}
    \prftree[r]{V-False}{\text{false val}}
  \end{displaymath}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
Values (Haskell)
  \end{center}
 \begin{minted}{haskell}
isValue :: Term 
        -> Bool
isValue TmTrue = 
  True
isValue TmFalse = 
  True
isValue _ = 
  False
 \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
Values (Haskell)
  \end{center}
 \begin{minted}{haskell}
value :: Term 
        -> Maybe Term
value TmTrue = 
  Just TmTrue
value TmFalse = 
  Just TmFalse
value _ = 
  Nothing
 \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}
    \prftree[r]{V-True}{\text{true val}}
  \end{displaymath}
 \begin{minted}{haskell}
valueTmTrue :: Term 
            -> Maybe Term
valueTmTrue TmTrue = 
  Just TmTrue
valueTmTrue _ = 
  Nothing
 \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}
    \prftree[r]{V-False}{\text{false val}}
  \end{displaymath}
 \begin{minted}{haskell}
valueTmFalse :: Term 
             -> Maybe Term
valueTmFalse TmFalse = 
  Just TmFalse
valueTmFalse _ = 
  Nothing
 \end{minted}
\end{frame}

\begin{frame}[fragile]
 \begin{minted}{haskell}
value :: Term 
      -> Maybe Term
value tm =
  valueTmTrue tm <|>
  valueTmFalse tm
 \end{minted}
\end{frame}

\begin{frame}[fragile]
 \begin{minted}{haskell}
import Data.Foldable (asum)

asum :: (Foldable t, Alternative f) 
     => t f a -> f a
 \end{minted}
\end{frame}

\begin{frame}[fragile]
 \begin{minted}{haskell}
valueRules :: [Term -> Maybe Term]
valueRules =
  [ valueTmTrue
  , valueTmFalse
  ]

value :: Term 
      -> Maybe Term
value tm =
  asum .
  fmap ($ tm) $
  valueRules
 \end{minted}
\end{frame}

\section{Small-step semantics of B}

\begin{frame}[c]
  \begin{center}
Small-step semantics (maths)
  \end{center}
  \begin{displaymath}
    \prftree[r]{E-IfTrue}
    {\text{if true then $t_2$ else $t_3$} \longrightarrow t_2}
  \end{displaymath}
  \begin{displaymath}
    \prftree[r]{E-IfFalse}
    {\text{if false then $t_2$ else $t_3$} \longrightarrow t_3}
  \end{displaymath}
  \begin{displaymath}
    \prftree[r]{E-If}
    {t_1 \longrightarrow t_1^{\prime}}
    {\text{if $t_1$ then $t_2$ else $t_3$} \longrightarrow \text{if $t_1^{\prime}$ then $t_2$ else $t_3$}}
  \end{displaymath}
\end{frame}

\begin{frame}[c]
  \begin{center}
Let's evaluate a term.
  \end{center}
\end{frame}

\begin{frame}[c]
Original
  \begin{displaymath}
    \text{if (if f then f else t) then f else t}
  \end{displaymath}
Step 1
  \begin{displaymath}
    \prftree[r]{E-If}
    {\prftree[r]{E-IfFalse}{\text{if f then f else t} \longrightarrow \text{t}}}
    {\text{if (if f then f else t) then f else t} \longrightarrow \text{if t then f else
      t}}
  \end{displaymath}
Step 2
  \begin{displaymath}
    \prftree[r]{E-IfTrue}
    {\text{if t then f else t} \longrightarrow f}
  \end{displaymath}
Final
  \begin{displaymath}
    \text{f}
  \end{displaymath}
\end{frame}

\begin{frame}[c]
  \begin{center}
If no step is defined for a term, it is a \em{normal form}.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
All values are normal forms.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
A normal form that is not a value is \em{stuck}.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
We use $\tt{Maybe}$ to handle pattern match failures in the rules.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
We use $\tt{Maybe}$ to handle the partiality of the combined step function.
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}
    \prftree[r]{E-IfTrue}
    {\text{if true then $t_2$ else $t_3$} \longrightarrow t_2}
  \end{displaymath}
  \begin{minted}{haskell}
eIfTrue :: Term 
        -> Maybe Term
eIfTrue (TmIf TmTrue tm2 _) =
  Just tm2
eIfTrue _ =
  Nothing
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}
    \prftree[r]{E-IfFalse}
    {\text{if false then $t_2$ else $t_3$} \longrightarrow t_3}
  \end{displaymath}
  \begin{minted}{haskell}
eIfFalse :: Term 
         -> Maybe Term
eIfFalse (TmIf TmFalse _ tm3) =
  Just tm3
eIfFalse _ =
  Nothing
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}
    \prftree[r]{E-If}
    {t_1 \longrightarrow t_1^{\prime}}
    {\text{if $t_1$ then $t_2$ else $t_3$} \longrightarrow \text{if $t_1^{\prime}$ then $t_2$ else $t_3$}}
  \end{displaymath}
  \begin{minted}{haskell}
eIf :: (Term -> Maybe Term) 
    -> Term 
    -> Maybe Term
eIf step (TmIf tm1 tm2 tm3) = do
  tm1' <- step tm1
  return $ TmIf tm1' tm2 tm3
eIf =
  Nothing
  \end{minted}
\end{frame}

\begin{frame}[fragile]
 \begin{minted}{haskell}
smallStepRules :: [Term -> Maybe Term]
smallStepRules =
  [ eIfTrue
  , eIfFalse
  , eIf smallStep
  ]

smallStep :: Term 
          -> Maybe Term
smallStep tm =
  asum .
  fmap ($ tm) $
  smallStepRules
 \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
An evaluator (!)
  \end{center}
 \begin{minted}{haskell}
smallStepEval :: Term 
              -> Term
smallStepEval tm =
  case smallStep tm of
    Nothing -> tm
    Just tm' -> eval tm'
 \end{minted}
\end{frame}

\section{Properties of the small-step semantics}

\begin{frame}[c]
  \begin{center}
There are some properties that we want to hold for our small-step function.
  \end{center}
\end{frame}

\begin{frame}[c]
  Property 1
  \begin{center}
All values are normal forms.
  \end{center}
\end{frame}

\begin{frame}[c]
  Property 2
  \begin{center}
No terms are stuck.
  \end{center}
\end{frame}

\begin{frame}[c]
  Property 3
  \begin{center}
Small-step is determinate.
  \end{center}
\end{frame}

\begin{frame}[c]
  Property 4
  \begin{center}
Small-step is normalizing.
  \end{center}
\end{frame}

\section{Testing the small-step semantics}

\begin{frame}[fragile]
  \begin{center}
  Need some generators and friends
  \end{center}
  \begin{minted}{haskell}
genAnyTerm :: Gen Term
shrAnyTerm :: Term -> [Term]
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
  We can wrap them in newtypes
  \end{center}
  \begin{minted}{haskell}
newtype AnyTerm = 
  AnyTerm { 
    getAnyTerm :: Term 
  } deriving (Eq, Ord, Show)
   
instance Arbitrary AnyTerm where 
  arbitrary = 
    AnyTerm <$> genAnyTerm
  shrink = 
    fmap AnyTerm .
    shrAnyTerm .
    getAnyTerm
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
  We can use them in properties directly
  \end{center}
  \begin{minted}{haskell}
forAllShrink genAnyTerm shrAnyTerm $ \tm -> ...
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  We also need some helpers
  \begin{minted}{haskell}
isValue      = 
  isJust . value

canStep      =
  isJust . smallStep

isNormalform = 
  isNothing . smallStep

termSize TmFalse = 
  1
termSize TmTrue  =
  1
termSize (TmIf tm1 tm2 tm3) = 
  1 + termSize tm1 + termSize tm2 + termSize tm3
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Property 1
  \begin{center}
All values are normal forms.
  \end{center}
  \begin{minted}{haskell}
prop_valueIsNormal :: AnyTerm -> Property
prop_valueIsNormal (AnyTerm tm) =
  isValue tm ==> isNormalForm tm
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Property 2
  \begin{center}
No terms are stuck.
  \end{center}
  \begin{minted}{haskell}
prop_normalIsValue :: AnyTerm -> Property
prop_normalIsValue (AnyTerm tm) =
  isNormalForm tm ==> isValue tm
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Property 3
  \begin{center}
Small-step is determinate.
  \end{center}
  \begin{minted}{haskell}
prop_determinate :: AnyTerm -> Property
prop_determinate (AnyTerm tm) =
  canStep tm ==>
    let
      distinctResults =
        length .
        group .
        mapMaybe ($ tm) $
        smallStepRules
    in
      distinctResults === 1
  \end{minted}
\end{frame}

\begin{frame}[fragile]
Property 1-3 (and then some)
  \begin{minted}{haskell}
prop_unique :: AnyTerm -> Property
prop_unique (AnyTerm tm) =
  let
    matches =
      length .
      mapMaybe ($ tm) $
      valueRules ++ smallStepRules
  in
    matches === 1
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Property 4
  \begin{center}
Small-step is normalizing.
  \end{center}
  \begin{minted}{haskell}
prop_normalizing :: AnyTerm -> Property
prop_normalizing (AnyTerm tm) =
  case smallStep tm of
    Nothing -> True
    Just tm' -> termSize tm' < termSize tm
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Bonus Property
  \begin{minted}{haskell}
prop_correct_fast :: AnyTerm -> Property
prop_correct_fast (AnyTerm tm) =
  smallStepEval tm === fastCowboyEval tm
  \end{minted}
\end{frame}

\section{A type system for B}

\begin{frame}[fragile]
  \begin{minted}{haskell}
data Type =
  TyBool
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
inferTerm :: Term 
          -> Type
inferTerm _ =
  TyBool
  \end{minted}
\end{frame}

\begin{frame}[c]
  \begin{center}
Type system (maths)
  \end{center}
  \begin{displaymath}
    \prftree[r]{T-True}
    {\text{true} \colon \text{Bool}}
  \end{displaymath}
  \begin{displaymath}
    \prftree[r]{T-False}
    {\text{false} \colon \text{Bool}}
  \end{displaymath}
  \begin{displaymath}
    \prftree[r]{T-If}
    {t_1 \colon \text{Bool}}
    {t_2 \colon \text{T}}
    {t_3 \colon \text{T}}
    {\text{if $t_1$ then $t_2$ else $t_3$} \colon \text{T}}
  \end{displaymath}
\end{frame}

% error handling
\begin{frame}[fragile]
  \begin{minted}{haskell}
data TypeError =
    UnknownType
  | Unexpected { actual :: Type, expected :: Type }
  | ExpectedEq { type1 :: Type, type2 :: Type }
  deriving (Eq, Ord,Show)

expect :: MonadError TypeError m 
       => Type 
       -> Type 
       -> m ()

expectEq :: MonadError TypeError m 
       => Type 
       -> Type 
       -> m ()
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}
    \prftree[r]{T-True}
    {\text{true} \colon \text{Bool}}
  \end{displaymath}
  \begin{minted}{haskell}
inferTmTrue :: Monad m 
            => Term 
            -> Maybe (m Type)
inferTmTrue TmTrue =
  Just $ return TyBool
inferTmTrue _ =
  Nothing
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}
    \prftree[r]{T-False}
    {\text{false} \colon \text{Bool}}
  \end{displaymath}
  \begin{minted}{haskell}
inferTmFalse :: Monad m 
             => Term 
             -> Maybe (m Type)
inferTmFalse TmFalse =
  Just $ return TyBool
inferTmFalse _ =
  Nothing
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}
    \prftree[r]{T-If}
    {t_1 \colon \text{Bool}}
    {t_2 \colon \text{T}}
    {t_3 \colon \text{T}}
    {\text{if $t_1$ then $t_2$ else $t_3$} \colon \text{T}}
  \end{displaymath}
  \begin{minted}{haskell}
inferTmIf :: MonadError TypeError m 
          => (Term -> m Type)
          -> Term 
          -> Maybe (m Type)
inferTmIf infer (TmIf tm1 tm2 tm3) = Just $ do
  ty1 <- infer tm1
  expect ty1 TyBool
  ty2 <- infer tm2
  ty3 <- infer tm3
  expectEq ty2 ty3
  return ty2
inferTmIf _ _ =
  Nothing
  \end{minted}
\end{frame}

% gathering the rules
\begin{frame}[fragile]
  \begin{minted}{haskell}
inferRules :: MonadError TypeError m 
           => [Term -> Maybe (m Type)]
inferRules =
  [ inferTmTrue
  , inferTmFalse
  , inferTmIf infer
  ]

infer :: MonadError TypeError m 
      => Term 
      -> m Type
infer tm =
  fromMaybe (throwError UnknownType) .
  asum .
  fmap ($ tm) $
  inferRules
  \end{minted}
\end{frame}

\section{Properties of the type system}

\begin{frame}[c]
  \begin{center}
    Progress: Well-typed terms are either values or can take a step.
  \end{center}
\end{frame}

\begin{frame}[c]
  \begin{center}
    Preservation: Well-typed terms do not change type when they take a step.
  \end{center}
\end{frame}

\begin{frame}[fragile,c]
  \begin{center}
    Aside: Not all ill-typed terms are stuck
  \end{center}
  \begin{minted}{haskell}
> smallStep $ TmIf TmTrue TmFalse (TmInt 12)
TmFalse
  \end{minted}
\end{frame}

\section{Testing the type system}

\begin{frame}[fragile]
  \begin{center}
  Need some more generators and friends
  \end{center}
  \begin{minted}{haskell}
genAnyType       :: Gen Type
genNotType       :: Type -> Gen Type
genWellTypedTerm :: Type -> Gen Term
genIllTypedTerm  :: Type -> Gen Term
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
newtype WellTypedTerm = WellTypedTerm Term

instance Arbitrary WellTypedTerm where
  arbitrary = genType >>= genWellTypedTerm
  shrink = shrinkWellTypedTerm
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
prop_progress :: WellTypedTerm -> Property
prop_progress (WellTypedTerm tm) =
  isValue tm .||. canStep tm
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
prop_preservation :: WellTypedTerm -> Property
prop_preservation (WellTypedTerm tm) =
  case smallStep tm of
    Nothing -> property True
    Just tm' -> infer tm === infer tm'
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{center}
   Good to double check that ill-typed terms result in type errors and that well-typed terms
   result in types.
  \end{center}
  \begin{minted}{haskell}
prop_illTypedInfer :: IllTypedTerm -> Property
prop_illTypedInfer (IllTypedTerm tm ) =
  isLeft . runInfer . inferTerm $ tm

prop_wellTypedInfer :: WellTypedTerm -> Property
prop_wellTypedInfer (WellTypedTerm tm ) =
  isRight . runInfer . inferTerm $ tm
  \end{minted}
\end{frame} 

\section{Parsing and printing B}

\begin{frame}[c]
  \begin{center}
Parse with $\tt{parsers}$ and $\tt{trifecta}$, print with $\tt{ansi-wl-pprint}$.
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
parseTmFalse :: (Monad m , TokenParsing m)
             => m Term           
parseTmFalse =
  TmFalse <$ symbol "False" <?> "False"

prettyTmFalse :: Term -> Maybe Doc
prettyTmFalse TmFalse =
  Just $ text "False"
prettyTmFalse _ =
  Nothing
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
parseTmTrue :: (Monad m , TokenParsing m)
            => m Term
parseTmTrue =
  TmTrue <$ symbol "True" <?> "True"

prettyTmTrue :: Term -> Maybe Doc
prettyTmTrue TmTrue =
  Just $ text "True"
prettyTmTrue _ =
  Nothing
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
parseTmIf :: (Monad m , TokenParsing m)
          => m Term -> m Term
parseTmIf parseTerm =
  TmIf <$
    symbol "if" <*> parseTerm <*
    symbol "then" <*> parseTerm <*
    symbol "else" <*> parseTerm
  <?> "if-then-else"
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
prettyTmIf :: (Term -> Doc) -> Term -> Maybe Doc
prettyTmIf prettyTerm (TmIf tm1 tm2 tm3) =
  Just $
    text "if" <+> prettyTerm tm1 </>
    text "then" <+> prettyTerm tm2 </>
    text "else" <+> prettyTerm tm3
prettyTmIf _ _ =
  Nothing
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
withParens :: TokenParsing m 
           => m Term -> m Term
withParens p = parens p <|> p

parseTermRules :: (Monad m , TokenParsing m)
               => [m Term]
parseTermRules =
  [ parseTmFalse
  , parseTmTrue
  , parseTmIf parseTerm
  ]

parseTerm :: (Monad m , TokenParsing m)
          => m Term
parseTerm =
  ( withParens .
    asum $
    parseTermRules
  ) <?> "term"
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
prettyTermRules :: [Term -> Maybe Doc]
prettyTermRules =
  [ prettyTmFalse
  , prettyTmTrue
  , prettyTmIf prettyTerm
  ]

prettyTerm :: Term -> Doc
prettyTerm tm =
  fromMaybe (text "???") .
  asum .
  fmap ($ tm) $
  prettyTermRules
  \end{minted}
\end{frame} 

\section{Parsing B}

\begin{frame}[fragile]
Tip: Use the token parsers / identifier styles if you can
  \begin{minted}{haskell}
identifierStyle :: TokenParsing m
                => IdentifierStyle m
identifierStyle =
  IdentifierStyle {
    _styleName      = "identitfier"
  , _styleStart     = lower <|> char '_'
  , _styleLetter    = alphaNum <|> char '_'
  , _styleReserved  = HS.fromList 
      ["if" , "then" , "else"]
  , _styleHighlight = Identifier
  , _styleReservedHighlight = ReservedIdentifier
  }

reservedIdentifier :: (Monad m , TokenParsing m)
                   => String -> m ()
reservedIdentifier =
  reserve identifierStyle
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
Tip: Steal the highlighting from $\tt{trifecta}$ for your printing.
  \begin{minted}{haskell}
import Text.Parser.Token.Highlight  (Highlight (..))
import Text.Trifecta.Highlight      (withHighlight)

reservedIdentifier :: String -> Doc
reservedIdentifier =
  withHighlight ReservedIdentifier .
  text
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
parseTmIf :: (Monad m , TokenParsing m)
          => m Term -> m Term
parseTmIf parseTerm =
  TmIf <$
    reservedIdentifier "if" <*> parseTerm <*
    reservedIdentifier "then" <*> parseTerm <*
    reservedIdentifier "else" <*> parseTerm
  <?> "if-then-else"
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
prettyTmIf :: (Term -> Doc) -> Term -> Maybe Doc
prettyTmIf prettyTerm (TmIf tm1 tm2 tm3) =
  Just $
    reservedIdentifier "if" <+> prettyTerm tm1 </>
    reservedIdentifier "then" <+> prettyTerm tm2 </>
    reservedIdentifier "else" <+> prettyTerm tm3
prettyTmIf _ _ =
  Nothing
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
Tip: At least do minimal testing of your parser and printer
  \begin{minted}{haskell}
prop_prettyParse :: AnyTerm -> Property
prop_prettyParse (AnyTerm tm) =
  case (parseTermString . prettyTermString) tm of
    Left _ -> property False
    Right tm' -> tm === tm'
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{center}
   Now we have the core of a REPL 
  \end{center}
  \begin{minted}{haskell}
parseAndEval :: String
             -> Doc
parseAndEval s =
  case parseFromString parseTerm s of
    Left d -> d
    Right tm -> case runInfer . inferTerm $ tm of
      Left e -> 
        prettyTypeError e
      Right ty ->
        prettyTerm (smallStepEval tm) <+> 
        text ":" <+> 
        prettyType ty
  \end{minted}
\end{frame} 

\section{B with Class}

\begin{frame}[fragile]
  \begin{minted}{haskell}
data BoolTerm tm =
    TmFalse
  | TmTrue
  | TmIf tm tm tm

makeClassyPrisms ''BoolTerm
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
class AsBoolTerm s tm | s -> tm where
  _BoolTerm :: Prism' s (BoolTerm tm)
  _TmFalse  :: Prism' s ()
  _TmTrue   :: Prism' s ()
  _TmIf     :: Prism' s (tm, tm, tm)

  _TmFalse = _BoolTerm . _TmFalse
  _TmTrue  = _BoolTerm . _TmTrue
  _TmIf    = _BoolTerm . _TmIf

instance AsBoolTerm (BoolTerm tm) tm
  _BoolTerm = id
  _TmFalse = ...
  _TmTrue = ...
  _TmIf = ...
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
data MyTerm =
    MyBoolTerm (BoolTerm MyTerm)
  | MyNatTerm  (NatTerm MyTerm)

makeClassyPrisms ''MyTerm

instance AsBoolTerm MyTerm MyTerm where
  _BoolTerm = _MyBoolTerm
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
> :t preview _TmFalse
AsBoolTerm tm => tm -> Maybe ()

> preview _TmFalse TmFalse
Just ()

> preview _TmFalse (MyBoolTerm TmFalse)
Just ()

> preview _TmFalse (TmIf TmTrue TmFalse TmTrue)
Nothing
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
> :t review _TmFalse
AsBoolTerm tm => () -> tm

> (review _TmFalse ()) :: BoolTerm
TmFalse

> (review _TmFalse ()) :: MyTerm
MyBoolTerm TmFalse
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
data BoolType =
  TyBool
  deriving (Eq, Ord, Show)

makeClassyPrisms ''BoolType
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
eIfTrue :: AsBoolTerm tm tm
        => tm
        -> Maybe tm
eIfTrue tm = do
  (tm1, tm2, _) <- preview _TmIf tm
  _ <- preview _TmTrue tm1
  return tm2
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
eIf :: AsBoolTerm tm tm
    => (tm -> Maybe tm)
    -> tm
    -> Maybe tm
eIf step tm = do
  (tm1, tm2, tm3) <- preview _TmIf tm
  tm1' <- step tm1
  return $ review _TmIf (tm1', tm2, tm3)
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
inferTmIf :: ( Eq ty
             , AsUnexpected e ty , AsExpectedEq e ty
             , MonadError e m
             , AsBoolTerm tm tm , AsBoolType ty ty
             )
          => (tm -> m ty)
          -> tm
          -> Maybe (m ty)
inferTmIf infer tm = do
  (tm1, tm2, tm3) <- preview _TmIf tm
  return $ do$
    ty1 <- infer tm1
    expect ty1 (review _TyBool ())
    ty2 <- infer tm2
    ty3 <- infer tm3
    expectEq ty2 ty3
    return ty3
  \end{minted}
\end{frame} 

\section{Annotating the AST}

\begin{frame}[fragile]
  \begin{overprint}
   \onslide<1>
\begin{verbatim}
> if S O then False else True


Unexpected type: 
  actual: Nat
  expected: Bool
\end{verbatim}
   \onslide<2>
\begin{verbatim}
> if S O then False else True
if S O then False else True<EOF>
   ~~~
Unexpected type: 
  actual: Nat
  expected: Bool
\end{verbatim}
  \end{overprint}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
data NoteTerm n tm =
  TmNote n tm

makeClassyPrisms ''NoteTerm

data NoteType n ty =
  TyNote n ty

makeClassyPrisms ''NoteType
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
withSpan :: ( Monad m
            , DeltaParsing m
            , AsNoteTerm tm Span tm
            )
         => m tm
         -> m tm
withSpan p = do
  (tm :~ s) <- spanned p
  return $ review _TmNote (s, tm)
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
inferTmNote :: ( AsNoteType ty n ty
               , AsNoteTerm tm n tm
               , Monad m
               )
             => (tm -> m ty)
             -> tm
             -> Maybe (m ty)
inferTmNote infer tm = do
  (n, tm) <- preview _TmNote tm
  return $ do
    ty <- infer tm
    return $ review _TyNote (n, ty)
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
prettyUnexpected :: (ty -> Doc)
                 -> (ty, ty)
                 -> Doc
prettyUnexpected prettyType (ac, ex) =
  hang 2 (text "Unexpected type:" PP.<$>
          text "actual:" <+> prettyType ac PP.<$>
          text "expected:" <+> prettyType ex)
  \end{minted}
\end{frame} 

\begin{frame}[fragile]
  \begin{minted}{haskell}
prettyUnexpectedSrcLoc :: ( Show ty
                          , Renderable n
                          )
                       => (ty -> Doc)
                       -> (n, ty)
                       -> ty
                       -> Doc
prettyUnexpectedSrcLoc prettyType (n, ac) ex =
  (render n) PP.<$>
  hang 2 (text "Unexpected type:" PP.<$>
          text "actual:" <+> prettyType ac PP.<$>
          text "expected:" <+> prettyType ex)
  \end{minted}
\end{frame} 

\section{STLC}

\begin{frame}[c]
  Terms
  \begin{displaymath}
    \begin{aligned}
t =& \ \text{x} & \text{(Var)}\\
  |& \ \lambda x \colon T \ldotp t & \text{(Lam)}\\
  |& \ \text{t t} & \text{(App)}
    \end{aligned}
  \end{displaymath}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
   Var
  \end{center}
  \begin{minted}{haskell}
x + 1
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{center}
   Lam
  \end{center}
  \begin{minted}{haskell}
\x : Int -> Int => x + 1
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{center}
   App
  \end{center}
  \begin{minted}{haskell}
(\x : Int -> Int => x + 1) 2
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{center}
   Variables can be free or bound.
  \end{center}
  \begin{minted}{haskell}
 \x : Int => x + y
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{center}
   Variables can be free or bound.
  \end{center}
  \begin{minted}{haskell}
 \x : Int => x + (\x : Int => x * x) (x + 1)
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{center}
   Substitution can be simple.
  \end{center}
  \begin{minted}{haskell}
(\x : Int => x + y) 2
             2 + y
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{center}
   Substitution can be tricky.
  \end{center}
  \begin{minted}{haskell}
(\x : Int => x + (\x : Int => x * x) (x + 1)) 2
             2 + (\x : Int => x * x) (2 + 1)
             2 + (\x : Int => x * x) 3
             2 +              3 * 3
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{center}
    Monads do substitution!
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \begin{center}
    $\tt{bound}$ does the bookkeeping for us.
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
data Var b a = 
    B b 
  | F a

newtype Scope b f a = 
  Scope (f (Var b (f a))
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
abstract1 :: (Monad f, Eq a) 
          => a 
          -> f a 
          -> Scope () f a
abstract1 :: String 
          -> Term String 
          -> Scope () Term String

lam :: String 
    -> Term String 
    -> Scope () Term String
lam v tm = abstract1 v tm
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
instantiate1 :: Monad f 
             => f a 
             -> Scope n f a 
             -> f a 
instantiate1 :: Term String 
             -> Scope () Term String 
             -> Term String

invLam :: String 
       -> Scope () Term String 
       -> Term String
invLam v s = instantiate1 (return v) s

appLam :: Term String 
       -> Scope () Term String 
       -> Term String
appLam x f = instantiate1 x f
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
abstract :: Monad f 
         => (a -> Maybe b) 
         -> f a 
         -> Scope b f a 
abstract :: (String -> Maybe Int) 
         -> Term String 
         -> Scope Int Term String

multiLam :: [String] 
         -> Term String 
         -> Scope Int Term String
multiLam vs tm = abstract (`elemIndex` vs) tm
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
instantiate :: Monad f 
            => (b -> f a) 
            -> Scope b f a 
            -> f a
instantiate :: (Int -> Term String) 
            -> Scope Int Term String 
            -> Term String

invMultiLam :: [String] 
            -> Scope Int Term String 
            -> Term String
invMultiLam vs s = instantiate (return . (vs !!)) s

appMultiLam :: [Term String] 
            -> Scope Int Term String 
            -> Term String
appMultiLam tms s = instantiate (tms !!) s
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
data StlcType ty =
    TyArr ty ty
  deriving (Eq, Ord, Show)

makeClassyPrisms ''StlcTerm
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
data StlcTerm ty tm a =
    TmVar a
  | TmLam String ty (Scope () tm a)
  | TmApp tm tm
  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)

makeClassyPrisms ''StlcTerm
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
instance Eq1 (StlcTerm ty) where
  (==#) = (==)

instance Ord1 (StlcTerm ty) where
  compare1 = compare

instance Show1 (StlcTerm ty) where
  showsPrec1 = showsPrec
  \end{minted}  
\end{frame}

\begin{frame}[c]
  \begin{center}
  There is a typeclass $\tt{Bound}$ that provides $\tt{>>>=}$, which helps do
  substitution ``through'' other structures.
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
instance Monad tm => Monad (StlcTerm ty tm) where
  return = TmVar 

  TmVar x       >>= f = f x
  TmLam v t s   >>= f = TmLam v t (s >>>= f)
  TmApp tm1 tm2 >>= f = TmApp (tm1 >>= f) (tm2 >>= f)
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
data StlcVar a =
    TmVar a
  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)

makeClassyPrisms ''StlcVar

data StlcTerm ty tm a =
    TmLam String ty (Scope () tm a)
  | TmApp tm tm
  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)
makeClassyPrisms ''StlcTerm

instance Bound (StlcTerm ty) where
  TmLam v t s   >>>= f = TmLam v t (s >>>= f)
  TmApp tm1 tm2 >>>= f = TmApp (tm1 >>= f) (tm2 >>= f)
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
data MyTerm a =
    TmVar a
    TmStlc (StlcTerm MyType (MyTerm a) a)
  | TmBool (BoolTerm (MyTerm a))
  deriving (Eq, Ord, Show, Functor, Foldable, Traversable)

instance Monad MyTerm where
  return          = TmVar

  TmVar x   >>= f = f x
  TmStlc tm >>= f = TmStlc (tm >>>= f)
  TmBool tm >>= f = TmBool (tm >>>= f)
  \end{minted}  
\end{frame}

\begin{frame}[c]
  Values
  \begin{displaymath}
    \begin{aligned}
v =& \ \lambda x \colon T \ldotp t
    \end{aligned}
  \end{displaymath}
\end{frame}

\begin{frame}
  Small-step semantics
  \begin{displaymath}  
    \prftree[r]{E-App1}
    {t_1 \longrightarrow {t_1}^{\prime} }
    {t_1 t_2 \longrightarrow {t_1}^{\prime} t_2}
  \end{displaymath}  
  \begin{displaymath}  
    \prftree[r]{E-App1}
    {t_2 \longrightarrow {t_2}^{\prime} }
    {v_1 t_2 \longrightarrow v_1 {t_2}^{\prime}}
  \end{displaymath}  
  \begin{displaymath}  
    \prftree[r]{T-AppAbs}
    {(\lambda x \colon T_{11} \ldotp t_{12})v_2 \longrightarrow [x \mapsto v_2]t_{12}}
  \end{displaymath}  
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}  
    \prftree[r]{T-AppAbs}
    {(\lambda x \colon T_{11} \ldotp t_{12})v_2 \longrightarrow [x \mapsto v_2]t_{12}}
  \end{displaymath}  
  \begin{minted}{haskell}
eAppAbs :: ( AsSTLCTerm tm ty tm a
           , Monad tm 
           )
        => tm a
        -> Maybe (tm a)
eAppAbs tm = do
  (tm1, tm2) <- preview _TmApp tm
  (_, _, s) <- preview _TmLam tm1
  return $ instantiate1 tm2 s
  \end{minted}  
\end{frame}

\begin{frame}
  Typing rules
  \begin{displaymath}  
    \prftree[r]{T-Var}
    {x \colon T \in \Gamma}
    {\Gamma \vdash x \colon T}
  \end{displaymath}  
  \begin{displaymath}  
    \prftree[r]{T-Abs}
    {\Gamma, x_1 \colon T_1 \vdash t_2 \colon T_2}
    {\Gamma \vdash \lambda x_1 \colon T_1 \ldotp t_2 \colon T_1 \rightarrow T_2}
  \end{displaymath}  
  \begin{displaymath}  
    \prftree[r]{T-App}
    {\Gamma \vdash t_1 \colon T_1 \rightarrow T_2}
    {\Gamma \vdash t_2 \colon T_1}
    {t_1 t_2 \colon T_2}
  \end{displaymath}  
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}  
    \prftree[r]{T-Var}
    {x \colon T \in \Gamma}
    {\Gamma \vdash x \colon T}
  \end{displaymath}  
  \begin{minted}{haskell}
inferTmVar :: ( Ord a
              , AsSTLCType ty ty
              , AsSTLCTerm tm ty tm a
              , MonadReader (M.Map a ty) m
              , AsFreeVar e a
              , MonadError e m
              )
           => tm a
           -> Maybe (m ty)
inferTmVar tm = do
  v <- preview _TmVar tm
  case asks (M.lookup v) of
    Nothing -> throwing _FreeVar a 
    Just ty -> return ty
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}  
    \prftree[r]{T-Abs}
    {\Gamma, x_1 \colon T_1 \vdash t_2 \colon T_2}
    {\Gamma \vdash \lambda x_1 \colon T_1 \ldotp t_2 \colon T_1 \rightarrow T_2}
  \end{displaymath}  
  \begin{minted}{haskell}
inferTmLam :: ( AsSTLCType ty ty
              , AsSTLCTerm tm ty tm String
              , MonadReader (M.Map String ty) m
              , Monad tm
              )
           => (tm String -> m ty)
           -> tm String
           -> Maybe (m ty)
inferTmLam infer tm = do
  (n, ty1, s) <- preview _TmLam
  ty2 <- local (M.insert n ty1) $
    infer (instantiate1 (review _TmVar n) s)
  return $ review _TyArr (ty1, ty2)
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{displaymath}  
    \prftree[r]{T-App}
    {\Gamma \vdash t_1 \colon T_1 \rightarrow T_2}
    {\Gamma \vdash t_2 \colon T_1}
    {t_1 t_2 \colon T_2}
  \end{displaymath}  
  \begin{minted}{haskell}
inferTmApp :: ( Eq ty
              , AsSTLCType ty ty, AsSTLCTerm tm ty tm a
              , AsUnexpected e ty, AsNotArrow e ty
              , MonadError e m
              )
           => (tm a -> m ty) -> tm a -> Maybe (m ty)
inferTmApp infer tm = do
  (tm1, tm2) <- preview _TmApp tm
  return $ do
    ty1 <- infer tm1
    ty2 <- infer tm2
    case preview _TyArr ty1 of
      Nothing -> throwing _NotArrow (ty1, ty2)
      Just (tyFrom, tyTo) = do
        expect tyFrom ty2
        return tyTo
  \end{minted}  
\end{frame}

\section{Extending B (part 2)}

\begin{frame}[fragile]
  \begin{minted}{haskell}
(\not : Bool -> Bool => 
  (\x : Bool => 
    if x then False else True
  )
) (... code using not ...)
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
let 
  not x = if x then False else True
in
  ... code using not ...
  \end{minted}  
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{haskell}
import Prelude (not)

... code using not ...
  \end{minted}  
\end{frame}

\begin{frame}[c]
Thanks!
\end{frame}
  
\begin{frame}[c]
All of this and more will appear on dlaing.org before too long. 
\end{frame}

\section{Further avenues}

\begin{frame}[c]
\begin{itemize}
\item other LC additions
\item pattern matching
\item HM inference and/or bidirectional typing
\item bidirectional parsing and printing with QuickCheck support
\item syntax wrappers / hbound
\item smallcheck
\item reusable tools 
\item LLVM
\end{itemize}
\end{frame}

\end{document}

